<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"arthur-delacroix.github.io","root":"/","scheme":"Gemini","version":"8.0.1","exturl":false,"sidebar":{"position":"left","width":300,"display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Arthur&#39;s Blog">
<meta property="og:url" content="https://arthur-delacroix.github.io/home/page/10/index.html">
<meta property="og:site_name" content="Arthur&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Arthur Delacroix">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://arthur-delacroix.github.io/home/page/10/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Arthur's Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Arthur's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">20</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">111</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Arthur Delacroix"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Arthur Delacroix</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">111</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/Arthur-Delacroix/arthur-delacroix.github.io" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Arthur-Delacroix&#x2F;arthur-delacroix.github.io" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/7176171" title="BiliBili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;7176171" rel="noopener" target="_blank"><i class="fas fa-play-circle fa-fw"></i></a>
      </span>
  </div>



      </section>
        <div class="back-to-top animated">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://arthur-delacroix.github.io/2020/10/10/HexMap/2-5%20%E8%AE%A9%E9%A2%9C%E8%89%B2%E8%BF%87%E6%B8%A1%E6%9B%B4%E5%8A%A0%E5%B9%B3%E6%BB%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Arthur Delacroix">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arthur's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/10/HexMap/2-5%20%E8%AE%A9%E9%A2%9C%E8%89%B2%E8%BF%87%E6%B8%A1%E6%9B%B4%E5%8A%A0%E5%B9%B3%E6%BB%91/" class="post-title-link" itemprop="url">2-5 让颜色过渡更加平滑</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-10 21:43:07" itemprop="dateCreated datePublished" datetime="2020-10-10T21:43:07+00:00">2020-10-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Unity3D-Hex-Map/" itemprop="url" rel="index"><span itemprop="name">Unity3D Hex Map</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>　　在上一章中，我们重构了为三角面片赋值颜色的代码，为每个不同的顶点赋值了不同的颜色。实现了最基本的颜色不同切相邻的两个地图单元之间，会有颜色过渡的功能。但是视觉效果上并没有达到我们的预期。在这一章中，我们将优化现在的颜色混合视觉效果，让颜色过渡更加平滑。<br>　　首先，颜色不同切相邻的两个地图单元之间的边界颜色，应该是两个地图单元颜色的平均值。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个相邻的cell，其交界处的颜色应该是两个cell颜色的平均值</span></span><br><span class="line">    Color edgeColor = (cell.color + neighbor.color) * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为三角面片的顶点赋颜色值</span></span><br><span class="line">    <span class="comment">//AddTriangleColor(cell.color, neighbor.color, neighbor.color);</span></span><br><span class="line">    AddTriangleColor(cell.color, edgeColor, edgeColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-5-1.png"></p>
<p>　　经过修改，虽然视觉效果好了一些，但是颜色交界的地方过渡依然显得有些突兀。这是因为在颜色过渡不平滑的位置，会有三个地图单元共享一个顶点位置的颜色，我们之前的方法只是在两两混合颜色。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-5-2.png"></p>
<p>　　按照这个思路，我们在混合N方位地图单元的颜色时，还需要考虑N+1和N-1位置地图单元的颜色。</p>
<figure class="highlight csharp"><figcaption><span>HexDirection.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexDirectionExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取当前相邻cell 之前的一个cell的方位</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>当前相邻cell的方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HexDirection <span class="title">Previous</span>(<span class="params"><span class="keyword">this</span> HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//如果当前cell位置为NE，即索引为0，其之前的一个cell方位应该为NE，即索引为6</span></span><br><span class="line">        <span class="comment">//除此之外的情况，只要当前索引值减1即可</span></span><br><span class="line">        <span class="keyword">return</span> direction == HexDirection.NE ? HexDirection.NW : (direction - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取当前相邻cell 之后的一个cell的方位</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>当前相邻cell的方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HexDirection <span class="title">Next</span>(<span class="params"><span class="keyword">this</span> HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//与Previous方法中类似，方位索引为6时，回到0，其余情况则方位索引加1</span></span><br><span class="line">        <span class="keyword">return</span> direction == HexDirection.NW ? HexDirection.NE : (direction + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　现在，我们可以通过新增的两个方法，来获取N+1和N-1位置地图单元的颜色了。然后再分别进行颜色混合。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前相邻方位cell，索引值-1相邻cell的实例</span></span><br><span class="line">    HexCell prevNeighbor = cell.GetNeighbor(direction.Previous()) ?? cell;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取与自身当前相邻的cell的颜色值</span></span><br><span class="line">    <span class="comment">//每个cell会在 Triangulate(HexCell cell) 方法中将与自身相邻的cell遍历一次</span></span><br><span class="line">    <span class="comment">//?? 为 可空合并运算符，即cell.GetNeighbor(direction)的值为null时，使用 cell的值</span></span><br><span class="line">    HexCell neighbor = cell.GetNeighbor(direction) ?? cell;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前相邻方位cell，索引值+1相邻cell的实例</span></span><br><span class="line">    HexCell nextNeighbor = cell.GetNeighbor(direction.Next()) ?? cell;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个相邻的cell，其交界处的颜色应该是两个cell颜色的平均值</span></span><br><span class="line">    <span class="comment">//Color edgeColor = (cell.color + neighbor.color) * 0.5f;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取到相邻方位cell，以及相邻方位cell +1和-1 cell的实例，接下来进行颜色混合</span></span><br><span class="line">    <span class="comment">//三角面片3个顶点颜色分别为</span></span><br><span class="line">    <span class="comment">//自身颜色</span></span><br><span class="line">    <span class="comment">//自身颜色，自身颜色+相邻cell方位减1颜色，相邻cell颜色</span></span><br><span class="line">    <span class="comment">//自身颜色，自身颜色+相邻cell方位加1颜色，相邻cell颜色</span></span><br><span class="line">    AddTriangleColor(</span><br><span class="line">        cell.color,</span><br><span class="line">        (cell.color+prevNeighbor.color+neighbor.color)/<span class="number">3.0f</span>,</span><br><span class="line">        (cell.color+nextNeighbor.color+neighbor.color)/<span class="number">3.0f</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-5-3.png"></p>
<p>　　现在，我们就得到了新的颜色混合效果。但是通过观察发现，在地图边缘的这些地图单元，颜色混合是存在一些问题的。造成这种现象的原因是边缘的单元格缺失了N+1和N-1位置的地图单元，导致了颜色混合还是会有明显的边界。在下一章中，我们需要更换一下思路，来解决这个问题。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/315a3f87f036cfe4c7fc49763a804a79d5d1904f">Github代码</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://arthur-delacroix.github.io/2020/10/09/HexMap/2-4%20%E6%B7%B7%E5%90%88%E4%B8%89%E8%A7%92%E9%9D%A2%E7%89%87%E9%A2%9C%E8%89%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Arthur Delacroix">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arthur's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/09/HexMap/2-4%20%E6%B7%B7%E5%90%88%E4%B8%89%E8%A7%92%E9%9D%A2%E7%89%87%E9%A2%9C%E8%89%B2/" class="post-title-link" itemprop="url">2-4 混合三角面片颜色</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-09 15:12:39" itemprop="dateCreated datePublished" datetime="2020-10-09T15:12:39+00:00">2020-10-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Unity3D-Hex-Map/" itemprop="url" rel="index"><span itemprop="name">Unity3D Hex Map</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>　　在上一章中我们因为引入了HexDirection枚举，所以对一些方法进行了重构。接下来需要实现相邻两个地图单元的颜色混合功能。这里首先需要修改<code>HexMesh.cs</code>脚本中的<code>AddTriangleColor</code>方法。这个方法原本的参数只有一个，在构建三角面片的时候，会将这个参数的颜色信息赋值到三角面片的三个顶点信息中。为了实现颜色混合，需要再添加两个参数，让三角面片的每个顶点分别有不同的颜色值。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 为每个三角面片的3个顶点分别赋予不同的颜色值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;c1&quot;&gt;</span>第一个顶点的颜色信息(中心点的颜色)<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;c2&quot;&gt;</span>第二个顶点的颜色信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;c3&quot;&gt;</span>第三个顶点的颜色信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddTriangleColor</span>(<span class="params">Color c1, Color c2, Color c3</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    colors.Add(c1);</span><br><span class="line">    colors.Add(c2);</span><br><span class="line">    colors.Add(c3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，我们在构建三角面片的时候就可以进行颜色的混合了。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//获取与自身当前相邻的cell的颜色值</span></span><br><span class="line">    <span class="comment">//每个cell会在 Triangulate(HexCell cell) 方法中将与自身相邻的cell遍历一次</span></span><br><span class="line">    HexCell neighbor = cell.GetNeighbor(direction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为三角面片的顶点赋颜色值</span></span><br><span class="line">    AddTriangleColor(cell.color, neighbor.color, neighbor.color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　运行以上代码的时候，Unity会产生一个空引用异常。这是因为，并不是每个地图单元都有6个与之相邻的地图单元。所以，这里要进行一次判断。当一个方位上没有地图单元的时候，就用自身的颜色代替。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//获取与自身当前相邻的cell的颜色值</span></span><br><span class="line">    <span class="comment">//每个cell会在 Triangulate(HexCell cell) 方法中将与自身相邻的cell遍历一次</span></span><br><span class="line">    <span class="comment">//?? 为 可空合并运算符，即cell.GetNeighbor(direction)的值为null时，使用 cell的值</span></span><br><span class="line">    HexCell neighbor = cell.GetNeighbor(direction) ?? cell;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-4-1.png"></p>
<blockquote>
<p>“??”的含义：<br>这被称为可空合并运算符，简单来说”a??b”即”a!=null?a:b”的简写。<br><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/nullable-value-types#conversion-from-a-nullable-value-type-to-an-underlying-type">MSDN连接</a>，“从可为空的值类型转换为基础类型”部分。<br>这里有个小诡计，因为Unity在把一个东西与组件比较时会自定义,(注:Unity中判断一个对象不为空时可以直接写成if(someThings),这在C#原本语法里是没有的)而这个运算符会绕过它并直接与null比较,不过这是销毁对象时才需要考虑的问题。</p>
</blockquote>
<p>　　现在，我们虽然完成了相邻地图单元之间的颜色混合，但是视觉效果显得非常奇怪，完全不是我们想象中的样子。接下来我们需要慢慢解决这些问题。下一章中，我们将会让颜色混合更加平滑。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/ddd6faa23d19d72ca918668864dabaedf2ab35b3">Github代码</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://arthur-delacroix.github.io/2020/10/08/HexMap/2-3%20%E9%87%8D%E6%9E%84%E9%83%A8%E5%88%86%E7%8E%B0%E6%9C%89%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Arthur Delacroix">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arthur's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/08/HexMap/2-3%20%E9%87%8D%E6%9E%84%E9%83%A8%E5%88%86%E7%8E%B0%E6%9C%89%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">2-3 重构部分现有方法</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-08 10:49:11" itemprop="dateCreated datePublished" datetime="2020-10-08T10:49:11+00:00">2020-10-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Unity3D-Hex-Map/" itemprop="url" rel="index"><span itemprop="name">Unity3D Hex Map</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>　　在上一章中，我们创建了地图单元之间的互相链接关系。现在，我们需要利用已经创建好的链接关系，重构一些我们之前需要复杂计算的方法。<br>　　首先回到<code>HexMetrics.cs</code>脚本中，添加两个新的静态方法，用来获取地图单元的顶点位置信息。这样我们就可以将原本的<code>Vector3[] corners</code>枚举设置为私有了。</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Vector3[] corners =</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取cell的direction位置的顶点</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>顶点方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">GetFirstCorner</span>(<span class="params">HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> corners[(<span class="keyword">int</span>)direction];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取cell的direction+1位置的顶点</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>顶点方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">GetSecondtCorner</span>(<span class="params">HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> corners[(<span class="keyword">int</span>)direction + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来回到<code>HexMesh.cs</code>脚本中，在<code>private void Triangulate(HexCell cell)</code>方法中，我们可以替换掉之前使用<code>corners</code>枚举获取顶点的代码。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//private void Triangulate(HexCell cell)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取单个cell的中点位置</span></span><br><span class="line">    Vector3 center = cell.transform.localPosition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据中点位置计算出其余两个顶点的信息</span></span><br><span class="line">    AddTriangle(</span><br><span class="line">        center,</span><br><span class="line">        center + HexMetrics.GetFirstCorner(direction),</span><br><span class="line">        center + HexMetrics.GetSecondCorner(direction)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为有了HexDirection，这里不再直接使用corners枚举来获取cell的顶点位置信息，而使用HexDirection方位来获取</span></span><br><span class="line">    <span class="comment">//根据中点位置计算出其余的顶点位置信息，并按照顺序构建三角面片</span></span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt; 6; i++)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    //构建三角面片</span></span><br><span class="line">    <span class="comment">//    AddTriangle(</span></span><br><span class="line">    <span class="comment">//        center,</span></span><br><span class="line">    <span class="comment">//        center + HexMetrics.corners[i],</span></span><br><span class="line">    <span class="comment">//        center + HexMetrics.corners[i + 1]</span></span><br><span class="line">    <span class="comment">//    );</span></span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最后，我们新建一个<code>Triangulate(HexCell cell)</code>方法，使用HexDirection方位来循环添加单个地图单元的6个点点位置信息。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 使用HexDirection方位，为单个cell循环添加其6个顶点信息</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 此方法之后会进行优化合并</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cell&quot;&gt;</span>单个cell的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++)</span><br><span class="line">    &#123;</span><br><span class="line">        Triangulate(d, cell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，前置的一些准备工作就完成了，我们将之前直接使用<code>corners</code>枚举的代码，替换为了使用HexDirection方位的代码，避免了一些复杂的计算，也保证了<code>corners</code>的安全性。<br>　　接下来的章节中，我们将开始实现两个地图单元之间颜色混合的功能了。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/b7679f24ac0bec07b992cb7429ad9c785061c601">Github代码</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://arthur-delacroix.github.io/2020/10/07/HexMap/2-2%20%E9%93%BE%E6%8E%A5%E7%9B%B8%E9%82%BB%E7%9A%84%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Arthur Delacroix">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arthur's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/07/HexMap/2-2%20%E9%93%BE%E6%8E%A5%E7%9B%B8%E9%82%BB%E7%9A%84%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83/" class="post-title-link" itemprop="url">2-2 链接相邻的力图单元</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-07 13:27:53" itemprop="dateCreated datePublished" datetime="2020-10-07T13:27:53+00:00">2020-10-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Unity3D-Hex-Map/" itemprop="url" rel="index"><span itemprop="name">Unity3D Hex Map</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>　　在上一章节中，我们通过扩展方法，可以计算出一个地图单元自身相对于其周围地图单元的位置，并完善了相关的方法。接下来，我们要将地图内的所有地图单元互相链接起来。<br>　　在<code>HexGrid.cs</code>中使用<code>CreateCell</code>方法创建地图单元的时候，建立每个地图单元之间的位置链接关系。在这里，我们是从左至右逐行查看每个地图单元时，就可以知道已经创建了哪些地图单元，这些创建好的地图单元就是我们要进行链接的地图单元。<br>　　最简单的链接关系就是E-W链接。每一行的第一个地图单元，是没有E方向的相邻地图单元的。除此之外，其他的单元格都是有E方向的相邻单元格。而且这些地图单元都是在我们遍历它们并建立链接之前，就已经被创建好了。所以这里可以很容易的建立所有地图单元的E-W方向的链接。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-2-1.png"></p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为每个cell赋颜色初始值</span></span><br><span class="line">    cell.color = defaultColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断cell是否为每一行第一个</span></span><br><span class="line">    <span class="comment">//如果不是第一个，则cell会有W方位相邻的cell，就可以建立E-W链接</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cell.SetNeighbor(HexDirection.W, cells[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该变量用来存储被实例化的cellLabelPrefab预置</span></span><br><span class="line">    Text label = Instantiate&lt;Text&gt;(cellLabelPrefab);</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-2-2.png"></p>
<p>　　横向的链接关系建立完毕后，我们来看地图单元之间的纵向关系。由于每一行地图单元之间是呈锯齿状交错的，所以建立两行地图单元之间的链接需要不同的处理方法。在这里我们先处理偶数行的SE方向链接。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-2-3.png"></p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为每个cell赋颜色初始值</span></span><br><span class="line">    cell.color = defaultColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断cell是否为每一行第一个</span></span><br><span class="line">    <span class="comment">//如果不是第一个，则cell会有W方位相邻的cell，就可以建立E-W链接</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cell.SetNeighbor(HexDirection.W, cells[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里判断是否为第一行，因为行之间的链接会不太一样，尤其是第一行，需要做一次额外判断</span></span><br><span class="line">    <span class="keyword">if</span> (z &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里的&amp;为位运算符 MSDN：https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators</span></span><br><span class="line">        <span class="comment">//这里使用位运算符，判断是否为偶数行</span></span><br><span class="line">        <span class="keyword">if</span> ((z &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当为偶数行的时候，创建SE方向的链接</span></span><br><span class="line">            <span class="comment">//cells[1 - width]为SE方向的实例，图片参考 http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-2-3.png</span></span><br><span class="line">            cell.SetNeighbor(HexDirection.SE, cells[<span class="number">1</span> - width]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该变量用来存储被实例化的cellLabelPrefab预置</span></span><br><span class="line">    Text label = Instantiate&lt;Text&gt;(cellLabelPrefab);</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>什么是位运算符？<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators">MSDN连接</a></br><br>大家都知道”&amp;&amp;”是布尔运算符里的”与”运算,”&amp;”就是”按位与”。它们的执行逻辑相同，但后者是对于每一位进行运算。<br>两个Bit都是1,与运算的结果就是1。例如：10101010 &amp; 00001111结果是00001010。<br>从计算机原理层面上来说，所有的数字都是用二进制表示的。二进制中的1、2、3、4写作1、10、11、100。如你所见，表示是否为偶数的最低有效位是第一位。<br>我们把二进制的与运算作为一个遮罩，忽略除了第一位之外的其他位数，如果结果是0，那就表示这是一个偶数。</p>
</blockquote>
<p>　　与SE方向的链接关系类似，这里我们可以使用相同的方法创建SW方向的链接。要注意，每一行的第一个地图单元是没有SW方向的链接的。<br>　　<br><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-2-4.png"></p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里使用位运算符，判断是否为偶数行</span></span><br><span class="line">    <span class="keyword">if</span> ((z &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当为偶数行的时候，创建SE方向的链接</span></span><br><span class="line">        <span class="comment">//cells[i - width]为SE方向的实例，也就是右下方的cell</span></span><br><span class="line">        cell.SetNeighbor(HexDirection.SE, cells[i - width]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每行的第一个cell是没有左下角(SW)方向的链接，这里要判断cell是否为第一个</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cells[i - width - 1]为SW方向的实例，也就是左下方的cell</span></span><br><span class="line">            cell.SetNeighbor(HexDirection.SW, cells[i - width - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　奇数行与偶数行有相同的逻辑，只不过SE-NW、SW-NE方向的链接，与偶数行是相互镜像的。</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里使用位运算符，判断是否为偶数行</span></span><br><span class="line">    <span class="keyword">if</span> ((z &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        …</span><br><span class="line">        <span class="comment">//这里是奇数行建立链接的部分</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//i - width 为自身SW方向的实例</span></span><br><span class="line">            cell.SetNeighbor(HexDirection.SW, cells[i - width]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断奇数行cell是否为每行最后一个，因为奇数行最后一个cell是没有SE方向的实例</span></span><br><span class="line">            <span class="keyword">if</span> (x &lt; width - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//i - width + 1 为奇数行自身SE方向的实例</span></span><br><span class="line">                cell.SetNeighbor(HexDirection.SE, cells[i - width + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　通过以上的代码，我们创建了SE-NW、SW-NE、W-E方向的链接。通过观察可以发现，除了横向的W-E链接，我们都是先创建每个地图单元的SW和SE方向的链接，也就是将自身左下、右下的地图单元实例先进行链接，同时<code>SetNeighbor</code>方法会创建SW和SE的镜像链接，也就是NE和NW链接。所以最特殊的第一行也就和其他的地图单元自动创建了方位链接关系。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-2-5.png"></p>
<p>　　通过观察和代码可以发现，在整个地图系统中，并不是每个地图单元都有全部的6个相邻地图单元，也就是说，在边缘处的地图单元，其Neighbors数组并没有填满。有些边缘处地图单元最多有5个与其相邻的地图单元，最少的则有2个。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-2-6.png"></p>
<p>　　现在，我们已经将所有的地图单元建立了相互的链接关系，这是颜色混合的前置工作之一。接下来会进行一些代码的调整，并实现单元格之间颜色过渡的效果。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/7179c3b1142fb19b7e922def8f85e8fbb74f1a6a">Github代码</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://arthur-delacroix.github.io/2020/10/06/HexMap/2-1%20%E8%AE%A1%E7%AE%97%E7%9B%B8%E9%82%BB%E7%9A%84%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E7%9A%84%E4%BD%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Arthur Delacroix">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arthur's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/06/HexMap/2-1%20%E8%AE%A1%E7%AE%97%E7%9B%B8%E9%82%BB%E7%9A%84%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E7%9A%84%E4%BD%8D%E7%BD%AE/" class="post-title-link" itemprop="url">2-1 计算相邻的地图单元的位置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-06 11:55:40" itemprop="dateCreated datePublished" datetime="2020-10-06T11:55:40+00:00">2020-10-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Unity3D-Hex-Map/" itemprop="url" rel="index"><span itemprop="name">Unity3D Hex Map</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>　　上一章中我们完成了改变单个地图单元颜色的功能。但是通过观察可以发现，如果相邻的两个地图单元颜色不相同，他们之间的颜色过渡会显得非常的生硬。两者的对比效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-1-5.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-1-1.png"></p>
<p>　　观察对比图可以发现，地图单元之间拥有颜色过渡后，视觉效果会更好一些。在接下来的部分，我们暂时将改变色时重新构建整个地图Mesh的问题放一边，重点放在视觉表现上面。</p>
<p>　　要想产生平滑的颜色过渡，我们首先需要知道每个地图单元与谁相邻，才可以得到相邻地图单元的颜色，进一步进行颜色的平滑过渡。在这里我们创建一个新的脚本，命名为<code>HexDirection</code>，其中声明一个枚举，用来标识一个地图单元与其相邻的其他地图单元的方位。其分别为东北（NE）、东（ E )、东南(SE)、西南(SW)、西(W)、西北(NW)。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-1-2.png"></p>
<figure class="highlight csharp"><figcaption><span>HexDirection.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示相邻cell方位的枚举</span></span><br><span class="line"><span class="comment">//从左上角顺时针依次开始</span></span><br><span class="line"><span class="comment">//参考图：http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-1-2.png</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> HexDirection</span><br><span class="line">&#123;</span><br><span class="line">    NE,</span><br><span class="line">    E, </span><br><span class="line">    SE, </span><br><span class="line">    SW, </span><br><span class="line">    W, </span><br><span class="line">    NW</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>关于枚举类型<br><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/enum">MSDN连接</a></br><br>可以使用<code>enum</code>关键字来定义枚举，是有名字的有序列表。这种类型的变量可以使用这些名称中的一个作为它的值，每个名称都对应一个数字，默认情况下从0开始。当你需要有限长度的可命名有序列表时，这些非常有用。<br>实际上枚举就是简单的整数。你可以对它们进行加、减操作，转换成整数再转回来。同样也可以转换成少数其他类型，但整数是其基本类型。</p>
</blockquote>
<p>　　回到HexCell.cs脚本中，在开头部分添加一个数组，用来存储相邻地图单元的实例。这里将该数组设置为Private，并使用<code>[SerializeField]</code>标记这个变量，使其能够在Inspector面板中显示出来。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来存储每个cell的 相邻cell实例</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> HexCell[] neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　在这里，我们会保留相邻地图单元的引用，虽然可以通过坐标来直接获取相邻地图单元，但是在有引用关系的情况下会更加方便一些，而且保留引用关系在之后的一些操作中也很便利。</p>
<p>　　回到Unity中，选中Hex Cell的预置，我们可以看到neighbors变量已经显示在了Inspector面板上。因为每个地图单元最多可以有6个相邻地图单元。所以这里将neighbors数组的长度设置为6。效果如下：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-1-3.png"></p>
<p>　　接下来在HexCell.cs脚本中，创建一个公共方法，用来获取<code>neighbors</code>数组中的内容。因为之前声明的<code>HexDirection</code>枚举，其取值范围在0-5之间，同时<code>neighbors</code>数组长度为6，所以这里不用检查数组下标是否越界。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用来获取neighbors中相应方位cell的实例</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 这里注意，虽然HexDirection取值为0-5，neighbors长度为6，不会越界</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 但是不是所有cell都有6个相邻的cell_neighbor，所以可能取出为空，之后会添加判断</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>相邻cell的方位 枚举<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>相应方位cell 的实例<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HexCell <span class="title">GetNeighbor</span>(<span class="params">HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> neighbors[(<span class="keyword">int</span>)direction];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　因为<code>neighbors</code>数组为private，所以还需要一个将相邻地图单元实例赋值到数组中的一个方法。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 将相邻的cell实例赋值到neighbors中对应的位置</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 这里注意neighbors的索引下标，应与HexDirection方位的int值对应</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>相邻cell的方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cell&quot;&gt;</span>相邻cell的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetNeighbor</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        neighbors[(<span class="keyword">int</span>)direction] = cell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　因为方位是相对的。例如一个地图单元A，其E方位的地图单元实例为B，那么也可以说A在B的W方位。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-1-4.png"></p>
<p>　　所以在获取自身相邻地图单元实例的时候，同时将自身加入其相邻单元格实例的<code>neighbors</code>数组中。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 将相邻的cell实例赋值到neighbors中对应的位置</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 这里注意neighbors的索引下标，应与HexDirection方位的int值对应</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>相邻cell的方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cell&quot;&gt;</span>相邻cell的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetNeighbor</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        neighbors[(<span class="keyword">int</span>)direction] = cell;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在赋值自身的neighbors实例的同时，也将自身实例赋值到相邻cell的neighbors数组中</span></span><br><span class="line">        cell.neighbors[(<span class="keyword">int</span>)direction.Opposite()] = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，让我们到HexDirection.cs脚本中完成<code>Oppositie()</code>方法。这个方法主要是将地图单元自身实例，添加到相邻地图单元<code>neighbors</code>数组中的对应位置。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexDirection.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexDirectionExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 参考图 http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-1-4.png</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 根据 相邻cell 位于 自身cell 的位置，获得 自身cell 位于 相邻cell 的位置</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 也就是得到相反位置</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HexDirection <span class="title">Opposite</span>(<span class="params"><span class="keyword">this</span> HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//return (int)direction &lt; 3 ? (direction + 3) : (direction - 3);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//已知了 相邻cell 的位置，自身cell位置与相邻cell位置相反</span></span><br><span class="line">        <span class="comment">//即 W(1) - E(4)这样的对应关系，之间正好相差3</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int</span>)direction &lt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (direction + <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (direction - <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>什么是扩展方法？<br><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/extension-methods">MSDN连接</a></br><br>扩展方法是一个静态类中的静态方法，但使用起来像是某些类型的实例方法。这个类型可以是任何东西:自定义类、接口、结构体、原生数据结构或者是枚举。扩展方法的第一个参数之前必须有this关键字,它定义方法将操作的类型和实例的值。<br>这个特性允许我们在任何东西上添加方法,就像是静态方法的参数可以是任何类型。在有节制适量使用的情况下这个特性非常方便。但过度使用会造成代码结构的混乱。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/18aca13c0edcfd279b0b54cd0fedbfaea4b91f9e">Github代码</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://arthur-delacroix.github.io/2020/10/05/HexMap/1-10%20%E7%AE%80%E5%8D%95%E7%9A%84%E5%9C%B0%E5%9B%BE%E7%BC%96%E8%BE%91%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Arthur Delacroix">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arthur's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/05/HexMap/1-10%20%E7%AE%80%E5%8D%95%E7%9A%84%E5%9C%B0%E5%9B%BE%E7%BC%96%E8%BE%91%E5%99%A8/" class="post-title-link" itemprop="url">1-10 简单的地图编辑器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-05 11:55:40" itemprop="dateCreated datePublished" datetime="2020-10-05T11:55:40+00:00">2020-10-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Unity3D-Hex-Map/" itemprop="url" rel="index"><span itemprop="name">Unity3D Hex Map</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>　　在上一章中，我们实现了为被点击的地图单元添加指定的颜色。现在我们将这个功能拓展一下，制作一个简单的地图编辑器。在HexGrid.cs脚本中找到<code>TouchCell</code>方法，这个方法主要用来判断鼠标的点击位置并改变被点击地图单元的颜色。这里我们要对<code>TouchCell</code>方法进行一些修改，添加一个参数，使其可以接受任何颜色的信息，并将其访问修饰符改为public。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ColorCell</span>(<span class="params">Vector3 _position, Color _color</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _position = transform.InverseTransformPoint(_position);</span><br><span class="line">    HexCoordinates _coordinates = HexCoordinates.FromPosition(_position);</span><br><span class="line">    <span class="keyword">int</span> _index = _coordinates.X + _coordinates.Z * width + _coordinates.Z / <span class="number">2</span>;</span><br><span class="line">    HexCell _cell = cells[_index];</span><br><span class="line">    _cell.color = _color;</span><br><span class="line">    hexMesh.Triangulate(cells);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　接下来，创建HexMapEditor脚本，将HexGrid.cs脚本Update方法中的内容和HandleInput方法移动到这里。然后创建一个存储颜色的数组用来保存多个备选颜色，创建一个私有的颜色变量用来保存已选中的颜色值。最后添加一个公共方法来选择颜色。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备选颜色数组</span></span><br><span class="line">    <span class="keyword">public</span> Color[] colors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//HexGrid实例，用来调用其中的ColorCell方法</span></span><br><span class="line">    <span class="keyword">public</span> HexGrid hexGrid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已选中的颜色</span></span><br><span class="line">    <span class="keyword">private</span> Color activeColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里使用指定的camera代替 Camera.main方式，避免遍历场景中的Object</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Camera mainCamera;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//为activeColor赋初始值</span></span><br><span class="line">        SelectColor(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            HandleInput();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 鼠标左键单击会调用此方法，以鼠标为发射点，经过主摄像机练成射线</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 检测射线穿过Collider的位置</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 此方法移动到了HexMapEditor中</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleInput</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//射线起点为鼠标位置，经过主摄像机</span></span><br><span class="line">        Ray _inputRay = mainCamera.ScreenPointToRay(Input.mousePosition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检测射线是否碰撞到了collider</span></span><br><span class="line">        RaycastHit _hit;</span><br><span class="line">        <span class="keyword">if</span> (Physics.Raycast(_inputRay, <span class="keyword">out</span> _hit))</span><br><span class="line">        &#123;</span><br><span class="line">            hexGrid.ColorCell(_hit.point, activeColor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 为选中颜色activeColor 赋值</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;_index&quot;&gt;</span>备选颜色数组colors 中的颜色值索引<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectColor</span>(<span class="params"><span class="keyword">int</span> _index</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        activeColor = colors[_index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　新建一个canvas，重命名为<code>Hex Map Editor</code>不需要对其进行修改，保持默认即可。然后将HexMapEditor脚本挂载到canvas上，为<code>Colors</code>数组添加几个不同的颜色。最后将挂载Hex Grid.cs脚本的物体Hex Grid拖入到HexMapEditor中变量<code>Hex Grid</code>栏内。效果如下：<br>　　<br><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-10-1.png"></p>
<p>　　这里注意，在创建cancas的时候，可以调整Canvas Scaler的UI Scale Mode属性为Scale With Screen Size，这样输入屏幕的长度和宽度，就能更好的匹配UI的大小了。</p>
<p>　　在canvas下创建一个Panel，重命名为<code>Color Panel</code>，挂载Toggle Group组件，效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-10-2.png"></p>
<p>　　接着，在Color Panel下创建若干个单选按钮(Components/ UI/toggle)，其数量为HexMapEditor中<code>colors</code>数组的长度。效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-10-3.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-10-4.png"></p>
<p>　　完成以上步骤后，选中Color Panel下面的所有子物体，其中Toggle组件中有<code>Group</code>一栏，将Color Panel的Toggle Group组件拖入其中。这样，就能把这些Toggle组件关联到一起了，当一个被打开的时候，另外的Toggle组件会自动关闭。效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-10-5.png"></p>
<p>　　关于Toggle组件中事件调用的时机问题：</p>
<p>　　当我们每次选中或取消选中一个Toggle按钮时，Toggle组件中挂载的事件都会被调用。也就是说，当我们在Toggle按钮组中切换颜色的时候，<code>SelectColor()</code>方法会被调用两次。不过不用担心，因为每次Toggle组件被选中的事件调用总在最后，所以结果一定是正确的。或者我们可以通过判断当前组件是否被选中（<code>Toggle组件Is On</code>属性），来决定是否执行<code>SelectColor()</code>方法。</p>
<p>　　在每个Toggle组件中，有<code>On Value Changed</code>事件，将这个这件绑定到<code>HexMapEditor.SelectColor</code>方法上，并设置其参数，即Toggle组件表示的颜色与<code>HexMapEditor.Color</code>数组的颜色索引相同。效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-10-6.png"></p>
<p>　　最后，让我们将Color Panel覆盖到正六边形地图之上。这时候点击一个Toggle按钮，会发现每一次鼠标点击，不仅改变了Toggle按钮的状态，还同时改变了其后面地图单元的颜色。这说明鼠标在一次点击的时候不仅UI相应了鼠标点击，同时地图系统也响应了鼠标点击。我们可以使用事件系统来将两个事件分开处理，也就是当鼠标悬停在UI上时，六边形地图不会响应鼠标的点击事件。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//通过IsPointerOverGameObject区分点击在UI或cell上</span></span><br><span class="line">        <span class="comment">//IsPointerOverGameObject点击在UI上时候为true。其他为false</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">0</span>) &amp;&amp; !EventSystem.current.IsPointerOverGameObject())</span><br><span class="line">        &#123;</span><br><span class="line">            HandleInput();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，我们就完成了一个很简单的地图编辑器，在一组单选按钮组中选择一个颜色后，点击任意的地图单元，这个地图单元就会变成相应的颜色。虽然在改变颜色的过程中，我们是通过重新构建整个六边形地图做到的，但是目前市局效果和逻辑是正确的。<br>　　在接下来的章节中，我们会先将注意力放在视觉效果部分，首先要让地图单元之间的颜色过渡更加自然，然后添加地形的高低起伏。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/1c74505102f46c26e21321d230a123a27a3d991c">Github代码</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://arthur-delacroix.github.io/2020/10/04/HexMap/1-9%20%E6%94%B9%E5%8F%98%E9%80%89%E4%B8%AD%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E7%9A%84%E9%A2%9C%E8%89%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Arthur Delacroix">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arthur's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/04/HexMap/1-9%20%E6%94%B9%E5%8F%98%E9%80%89%E4%B8%AD%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E7%9A%84%E9%A2%9C%E8%89%B2/" class="post-title-link" itemprop="url">1-9 改变选中地图单元的颜色</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-04 09:51:40" itemprop="dateCreated datePublished" datetime="2020-10-04T09:51:40+00:00">2020-10-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Unity3D-Hex-Map/" itemprop="url" rel="index"><span itemprop="name">Unity3D Hex Map</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>　　在上一章中，我们通过坐标转换，可以知道鼠标点击在了哪一个地图单元上。接下来，我们在这个基础上改变被鼠标点击的地图单元的颜色。</p>
<p>　　在<code>HexGrid.cs</code>中声明两个变量，分别为默认颜色和点击后变化的颜色，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cell的默认颜色</span></span><br><span class="line"><span class="keyword">public</span> Color defaultColor = Color.white;</span><br><span class="line"><span class="comment">//cell被点击后的颜色</span></span><br><span class="line"><span class="keyword">public</span> Color touchedColor = Color.magenta;</span><br></pre></td></tr></table></figure>

<p>　　回到Unity中，选中Hex Grid物体，在Inspector面板中就能看到下图的效果，当然，我们也可以自定义初始颜色和点击后的颜色，如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-9-1.png"></p>
<p>　　回到<code>HexCell.cs</code>中，在这里我们声明一个变量，用来存储每个地图单元自己的颜色。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在实例化每个cell的时候会调用该实例</span></span><br><span class="line">    <span class="comment">//针对每个cell，重新计算它的坐标值</span></span><br><span class="line">    <span class="keyword">public</span> HexCoordinates coordinates;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储cell自身的颜色</span></span><br><span class="line">    <span class="keyword">public</span> Color color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　为每个地图单元赋初始颜色值，可以在HexGrid.CreateCell方法中实现。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//在不改变cell排列的情况下，重新计算每个cell的坐标位置</span></span><br><span class="line">    cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为每个cell赋颜色初始值</span></span><br><span class="line">    cell.color = defaultColor;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　当然，我们还需要将颜色的信息赋值给地图单元的Mesh组件，这样才能将颜色显示出来。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储cell每个顶点的颜色信息</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Color&gt; colors;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//初始化vertices、triangles链表 用于存储顶点和面片信息</span></span><br><span class="line">    vertices = <span class="keyword">new</span> List&lt;Vector3&gt;();</span><br><span class="line">    triangles = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化colors链表，用于存储顶点颜色信息</span></span><br><span class="line">    colors = <span class="keyword">new</span> List&lt;Color&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexCell[] cells</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    triangles.Clear();</span><br><span class="line">    colors.Clear();</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将所有的顶点位置信息，顶点位置信息的索引存储到链表中</span></span><br><span class="line">    hexMesh.vertices = vertices.ToArray();</span><br><span class="line">    hexMesh.triangles = triangles.ToArray();</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//将所有顶点的颜色信息存储在colors链表中</span></span><br><span class="line">    hexMesh.colors = colors.ToArray();</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接着，在进行每个三角面片构建的时候，我们将颜色的信息赋值给每一个顶点，这样在构建出地图单元的时候，就带有了我们定义的初始颜色了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexCell[] cells</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//根据中点位置计算出其余的顶点位置信息，并按照顺序构建三角面片</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//构建三角面片</span></span><br><span class="line">        AddTriangle(</span><br><span class="line">            center,</span><br><span class="line">            center + HexMetrics.corners[i],</span><br><span class="line">            center + HexMetrics.corners[i + <span class="number">1</span>]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为三角面片的顶点赋颜色值</span></span><br><span class="line">        AddTriangleColor(cell.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 为每个三角面片的3个顶点赋颜色值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;color&quot;&gt;</span>三角面片顶点的颜色信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddTriangleColor</span>(<span class="params">Color color</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    colors.Add(color);</span><br><span class="line">    colors.Add(color);</span><br><span class="line">    colors.Add(color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们回到HexGrid.TouchCell方法中。这个方法的流程可以理解为：先将Unity内普通的坐标，转换成六边形地图中的坐标，即从Unity的Vector3(8.7, 0, 13.9)坐标转换为六边形地图的(0, -1, 1)坐标。</p>
<p>　　接着，我们还需要知道被点击的地图单元在数组<code>HexGrid.cell[]</code>中具体的位置，也就是被惦记的地图单元在数组<code>HexGrid.cell[]</code>中的下标。才可以为该地图单元赋值新的颜色。</p>
<p>　　如果要改变其颜色，依照现有的方法，我们还需要重新构建整个六边形地图的Mesh，因为这个Mesh是整体存储在一个变量中的。但是我们真的有必要因为某个地图单元的颜色改变而重新构建整个正六边形地图的Mesh吗？答案很显然，重新构建整个Mesh是不合理的。</p>
<p>　　但是现在还不是优化这个步骤的时候，因为随着项目的功能不断增加，代码会变得越来越复杂，Mesh的外观也会变得复杂。所以现在做的任何优化在之后的代码中都会变得没有意义。虽然重新构建整个正六边形地图的Mesh虽然很无脑，但是却十分有效，目前我们先这样为地图单元更改颜色。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TouchCell</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用转换坐标的方法，定位具体点击到哪个cell上了</span></span><br><span class="line">    HexCoordinates coordinates = HexCoordinates.FromPosition(position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算出cell位于cells[]数组中的位置</span></span><br><span class="line">    <span class="keyword">int</span> index = coordinates.X + coordinates.Z * width + coordinates.Z / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取这个cell的实例</span></span><br><span class="line">    HexCell cell = cells[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为这个cell赋值颜色</span></span><br><span class="line">    cell.color = touchedColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新构建整个map的mesh</span></span><br><span class="line">    hexMesh.Triangulate(cells);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　代码完成之后，我们点击某一个地图单元，但是并没有任何的改变，被点击的地图单元也没有改变颜色。这是因为Unity中默认的着色器没有使用顶点颜色。我们需要自己创建一个自定义着色器（Assets/Create/Shader/Standard Surface Shader），并修改其中的代码。其实我们只需要对Unity新建的着色器进行2处很小的改动：1 在输入部分添加颜色信息。2 输出时让反射率与颜色值相乘。而且我们不必关心透明通道，只需要集中在rgb通道即可。代码如下： s</p>
<figure class="highlight csharp"><figcaption><span>HexCell.shader</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/HexCell&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> Input</span><br><span class="line">        &#123;</span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">            <span class="comment">//添加颜色输入</span></span><br><span class="line">            float4 color:COLOR;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">surf</span> (<span class="params">Input IN, inout SurfaceOutputStandard o</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            …</span><br><span class="line">            <span class="comment">//o.Albedo = c.rgb;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//输出部分，反射率与输入的颜色值相乘</span></span><br><span class="line">            o.Albedo = c.rgb * IN.color;</span><br><span class="line">            </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，新建一个材质球，使用我们修改后的shader，并将这个材质球替换掉场景中Hex Mesh物体组件上的材质球。最后效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-9-2.png"></p>
<p>　　这里要注意，某些情况下，点击地图单元后，可能会产生一些奇怪的阴影效果！这是因为在某些Unity版本中Standard Surface Shader可能会有阴影问题。如果发生了阴影抖动或者带状阴影的问题，这说明Z轴发生了冲突。调整全局方向光的阴影偏斜角度应该可以解决这个问题。</p>
<p>　　这样我们就完成了基本的交互功能了。当我们点击一个地图单元后，这个地图单元就会变成我们预先定义好的被点击的颜色。下一章中我们在这个基础上更进一步，制作一个简单的地图编辑器功能，可以为不同的地图单元赋值不同的颜色。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://arthur-delacroix.github.io/2020/10/03/HexMap/1-8%20%E8%8E%B7%E5%8F%96%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E4%BD%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Arthur Delacroix">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arthur's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/03/HexMap/1-8%20%E8%8E%B7%E5%8F%96%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E4%BD%8D%E7%BD%AE/" class="post-title-link" itemprop="url">1-8 获取鼠标点击位置</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-03 17:50:07" itemprop="dateCreated datePublished" datetime="2020-10-03T17:50:07+00:00">2020-10-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Unity3D-Hex-Map/" itemprop="url" rel="index"><span itemprop="name">Unity3D Hex Map</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>　　在之前的章节中，我们完成了一个正六边形地图系统的基本框架。但是目前这个地图系统是无法与玩家产生任何交互的。在一般策略游戏中，地图系统最基本的交互方式，就是响应玩家的鼠标点击事件。即玩家鼠标左键单击一个地图单元，这个地图单元便会改变颜色，或者播放一段预置的动画，来响应玩家的操作。我们可以通过鼠标向场景中发射一条射线的方式，来检测鼠标是否点击在了某个地图单元上。</p>
<p>　　目前，我们先把交互代码放在<code>HexGrid.cs</code>脚本里，随着项目在之后的章节中不断完善，将会把与玩家交互的代码移动到其他的脚本中。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//之后鼠标点击交互相关代码会移动到其他脚本中</span></span><br><span class="line">    <span class="comment">//检测鼠标左键是否点击</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetMouseButton(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        HandleInput();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 鼠标左键单击会调用此方法，以鼠标为发射点，经过主摄像机练成射线</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 检测射线穿过Collider的位置</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleInput</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//射线起点为鼠标位置，经过主摄像机</span></span><br><span class="line">    Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测射线是否碰撞到了collider</span></span><br><span class="line">    RaycastHit hit;</span><br><span class="line">    <span class="keyword">if</span> (Physics.Raycast(inputRay, <span class="keyword">out</span> hit))</span><br><span class="line">    &#123;</span><br><span class="line">        TouchCell(hit.point);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将射线的触碰点转换到自身的坐标系中</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;position&quot;&gt;</span>触碰到的collider的位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TouchCell</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将触碰点的坐标系，转换到自身的坐标系</span></span><br><span class="line">    position = transform.InverseTransformPoint(position);</span><br><span class="line">    Debug.Log(<span class="string">&quot;touched at &quot;</span> + position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　现在，我们完成了鼠标左键单击后发射一条射线的功能，这条射线如果穿过了一个带有Collider组件的模型，那么将会返回一个Vector3的位置信息。但是，现在的地图单元是没有Collider组件的，我们在HexMesh.cs脚本中为它添加MeshCollider组件。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了检测射线碰撞Collider</span></span><br><span class="line"><span class="keyword">private</span> MeshCollider meshCollider;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化MeshFilter组件的，实例化hexMesh，并给其命名</span></span><br><span class="line">    GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="keyword">new</span> Mesh();</span><br><span class="line">    hexMesh.name = <span class="string">&quot;Hex Mesh&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为HexMesh物体添加MeshCollider组件</span></span><br><span class="line">    meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;();</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　为Hex Mesh这个物体添加了<code>MeshCollider</code>组件后，我们需要将创建的Mesh数据赋值给<code>MeshCollider</code>组件，这样它就可以根据Mesh信息成成碰撞网格了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexCell[] cells</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    meshCollider.sharedMesh = hexMesh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，射线穿过Hex Mesh这个物体时，通过<code>MeshCollider</code>组件就可以返回射线的碰撞信息了。</p>
<p>　　可能会有小伙伴问，为什么不使用更简单高效的<code>Box Collider</code>？这是因为<code>Box Collider</code>不能很准确的吻合正六边形地图单元的轮廓，尤其是在3个地图单元相邻的情况下，<code>Box Collider</code>可能会重叠到一起，最终导致我们无法判断鼠标到底点击在了哪个地图单元上。而且随着项目的不断深入，我们的地形单元并不会一直保持在同意水平面上。所以使用<code>MeshCollider</code>会更加方便计算和判断。</p>
<p>　　以上代码完成后，我们在Unity的Scene窗口中点击任意一个地图单元，Console窗口中就会输出鼠标点击的坐标信息了。但是这个信息并没有体现出我们具体点击的是哪一个地图单元，所以需要将鼠标的点击的坐标信息，转换成六边形的坐标信息。这个步骤需要在HexCoordinates.cs中进行。</p>
<p>　　我们需要在首先要在HexGrid.TouchCell方法内，添加对HexCoordinates.cs中发发的调用，这个方法命名为FromPosition，专门用来将射线触碰MeshCollider的坐标，转换成正六边形地图的坐标。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TouchCell</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将触碰点的坐标系，转换到自身的坐标系</span></span><br><span class="line">    position = transform.InverseTransformPoint(position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用转换坐标的方法，定位具体点击到哪个cell上了</span></span><br><span class="line">    HexCoordinates coordinates = HexCoordinates.FromPosition(position);</span><br><span class="line"></span><br><span class="line">    Debug.Log(<span class="string">&quot;touched at &quot;</span> + coordinates.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　现在，我们来思考FromPosition这个方法要处理的事情。要将原有的射线触碰Collider信息转换成正六边形地图信息，可以将X、Y、Z几个轴向分开处理。这里首先处理X轴坐标，只需要将转换前的坐标除以地图单元的宽度即可，而且当Z值为0的时候，X和Y是护卫相反数的。在这里我们先假设Z值为0，所以很容易就能得出X和Y的值。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HexCoordinates <span class="title">FromPosition</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当Z为0的时候，X和Y互为相反数</span></span><br><span class="line">    <span class="comment">//X的值可以通过 实际X的值除以2倍内切圆半径来得到</span></span><br><span class="line">    <span class="keyword">float</span> x = position.x / (HexMetrics.innerRadius * <span class="number">2f</span>);</span><br><span class="line">    <span class="keyword">float</span> y = -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，Z不为0的时候，我们需要对X和Y进行偏移，才能得出正确的结果。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> offset = position.z / (HexMetrics.outerRadius * <span class="number">3f</span>);</span><br><span class="line">x -= offset;</span><br><span class="line">y -= offset;</span><br></pre></td></tr></table></figure>

<p>　　当计算出X和Y的值后，我们可以利用X+Y+Z=0这个特性，求出Z的坐标。然后将这些坐标进行四舍五入，就可以得到转换后的正六边形地图坐标了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对得出的坐标进行四舍五入，得到转换后的Hexmap坐标</span></span><br><span class="line"><span class="keyword">int</span> iX = Mathf.RoundToInt(x);</span><br><span class="line"><span class="keyword">int</span> iY = Mathf.RoundToInt(y);</span><br><span class="line"><span class="keyword">int</span> iZ = Mathf.RoundToInt(-x - y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HexCoordinates(iX, iZ);</span><br></pre></td></tr></table></figure>

<p>　　以上这些步骤虽然看起来没什么问题，但是仔细想一下就会发现，这样计算的最终坐标，很可能相加并不为0.让我们来加一段验证这个想法的代码：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对得出的坐标进行四舍五入，得到转换后的Hexmap坐标</span></span><br><span class="line"><span class="keyword">int</span> iX = Mathf.RoundToInt(x);</span><br><span class="line"><span class="keyword">int</span> iY = Mathf.RoundToInt(y);</span><br><span class="line"><span class="keyword">int</span> iZ = Mathf.RoundToInt(-x - y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证X+Y+Z是否为0</span></span><br><span class="line"><span class="keyword">if</span> (iX + iY + iZ != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Debug.LogWarning(<span class="string">&quot;rounding error!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HexCoordinates(iX, iZ);</span><br></pre></td></tr></table></figure>

<p>　　我们再次运行程序的时候发现，这个报错信息确实会弹出。而且是发生在鼠标点击的位置接近正六边形边界的时候。所以应该是在四舍五的过程中出现了问题，因为离地图单元的中心越远，四舍五入时舍去的值就越多，所以我们做一个合理的假设：舍去值更大的坐标是错误的。</p>
<p>　　知道了产生错误的原因，解决起来就比较简单了。解决方法就是废弃具有最大舍去增量的坐标值，然后用其它的两个坐标去重新构建它。这里我们只需要去重建X和Z，不需要关注Y，因为Y本来就是由X和Z求得的。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (iX + iY + iZ != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">float</span> dX = Mathf.Abs(x - iX);</span><br><span class="line">    <span class="keyword">float</span> dY = Mathf.Abs(y - iY);</span><br><span class="line">    <span class="keyword">float</span> dZ = Mathf.Abs(-x - y - iZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断哪个舍去的值最多</span></span><br><span class="line">    <span class="comment">//利用X+Y+Z=0的特性，使用两个舍去较小的值得，求出社区较大的那个</span></span><br><span class="line">    <span class="keyword">if</span> (dX &gt; dY &amp;&amp; dX &gt; dZ)</span><br><span class="line">    &#123;</span><br><span class="line">        iX = -iY - iZ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dZ &gt; dY)</span><br><span class="line">    &#123;</span><br><span class="line">        iZ = -iX - iY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　通过判断，我们重新计算四舍五入中，舍去的值最多的那个坐标。这样我们就得到了最终正确结果。</p>
<p>　　在下一章中，我们利用本章判断鼠标点击在哪个地图单元上的功能，给被点击的地图单元改变颜色，让地图系统拥有最基本的交互。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://arthur-delacroix.github.io/2020/10/02/HexMap/1-7%20%E5%B0%86%E5%9D%90%E6%A0%87%E5%80%BC%E6%98%BE%E7%A4%BA%E5%9C%A8Inspector%E4%B8%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Arthur Delacroix">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arthur's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/02/HexMap/1-7%20%E5%B0%86%E5%9D%90%E6%A0%87%E5%80%BC%E6%98%BE%E7%A4%BA%E5%9C%A8Inspector%E4%B8%8A/" class="post-title-link" itemprop="url">1-7 将坐标值显示在Inspector上</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-02 02:40:30" itemprop="dateCreated datePublished" datetime="2020-10-02T02:40:30+00:00">2020-10-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Unity3D-Hex-Map/" itemprop="url" rel="index"><span itemprop="name">Unity3D Hex Map</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>2 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>　　在上一章中，我们重新排列了每个地图单元的坐标值，并且添加了Y维度的坐标轴。随着项目不断复杂。在Unity runtime下，选中一个地图单元后，在Inspector门面板只能看到<code>coordinates</code>这个变量的名称，而不是显示这个地图单元的坐标值。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-7-1.png"></p>
<p>　　虽然我们选中一个地图单元后，可以通过观察Scene窗口中它的坐标值，来确定这个地图单元的位置。但是在Inspector中增加坐标值显示，会更加方便美观。接下来我们实现这个功能。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来显示在Inspector上cell坐标</span></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x, z;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储重新计算后的X坐标值</span></span><br><span class="line"><span class="comment">//public int X &#123; get; private set; &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> X</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储重新计算后的Z坐标值</span></span><br><span class="line"><span class="comment">//public int Z &#123; get; private set; &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Z</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 重载默认的构造函数</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x&quot;&gt;</span>为转换后的X坐标赋初始值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;z&quot;&gt;</span>为转换后的Z坐标赋初始值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HexCoordinates</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//X = x;</span></span><br><span class="line">    <span class="comment">//Z = z;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.z = z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　如下图所示，我们利用<code>[SerializeField]</code>将X和Y的坐标值显示在了Inspector面板上。但是这两个坐标值是可编辑状态，这并不是我们希望达到的效果。因为坐标值应该是固定不变的，而且这样竖向排列也不美观。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-7-2.png"></p>
<p>　　为了解决这个问题，我们为HexCoordinates创建一个自定义特性来改变它的显示方式。</p>
<p>　　在项目中创建Editor文件夹，并且在该文件夹内创建<code>HexCoordinatesDrawer.cs</code>脚本。这是一个只用于编辑器的脚本，扩展自<code>UnityEditor.PropertyDrawer</code>，并且需要<code>UnityEditor.CustomPropertyDrawer</code>特性来让其正确关联起来。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinatesDrawer.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CustomPropertyDrawer(typeof(HexCoordinates))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCoordinatesDrawer</span> : <span class="title">PropertyDrawer</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　<code>HexCoordinatesDrawer</code>继承了<code>PropertyDrawer</code>，<code>PropertyDrawers</code>通过<code>OnGUI()</code>方法显示其内容，该方法提供了要在其中绘制的屏幕矩形、序列化的属性数据以及它所属的字段的标签。这里添加OnGUI()方法，在此方法中重新绘制X和Z的坐标。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinatesDrawer.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Rect position, SerializedProperty property, GUIContent label</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，只需要提取出X和Z的坐标，使用HexCoordinates中重载的ToString()方法在指定的位置重新绘制GUI即可。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinatesDrawer.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将X和Z的坐标从HexCoordinates中提取出来</span></span><br><span class="line">HexCoordinates coordinates = <span class="keyword">new</span> HexCoordinates(</span><br><span class="line">    property.FindPropertyRelative(<span class="string">&quot;x&quot;</span>).intValue,</span><br><span class="line">    property.FindPropertyRelative(<span class="string">&quot;z&quot;</span>).intValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用HexCoordinates中重载的ToString方法，显示坐标</span></span><br><span class="line">GUI.Label(position, coordinates.ToString());</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-7-3.png"></p>
<p>　　现在，坐标可以正确的显示出来了。但是这里只显示了数字，丢失了类型名。这里使用EditorGUI.PrefoxLabel()方法来或能重新绘制类型名。这个方法还有一个往外的好处，它可以返回一个经过吊证的矩形，该矩形与右侧的做标数值显示区域大小刚好匹配。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinatesDrawer.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘制坐标的类型名称</span></span><br><span class="line">position = EditorGUI.PrefixLabel(position, label);</span><br><span class="line"><span class="comment">//利用HexCoordinates中重载的ToString方法，显示坐标</span></span><br><span class="line">GUI.Label(position, coordinates.ToString());</span><br></pre></td></tr></table></figure>

<p>　　最终效果如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-7-4.png"></p>
<p>　　现在，我们在Unity中进行调试的时候，选中了某一个地图单元，Inspector面板中变回显示这个单元格的X Y Z坐标了。下一步，我们将添加一些简单的交互，当出表点击地图单元的时候，嚷被点击的地图单元改变颜色。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://arthur-delacroix.github.io/2020/10/01/HexMap/1-6%20%E4%BF%AE%E6%94%B9%E6%AD%A3%E5%85%AD%E8%BE%B9%E5%BD%A2%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E7%9A%84%E5%9D%90%E6%A0%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Arthur Delacroix">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Arthur's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/01/HexMap/1-6%20%E4%BF%AE%E6%94%B9%E6%AD%A3%E5%85%AD%E8%BE%B9%E5%BD%A2%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E7%9A%84%E5%9D%90%E6%A0%87/" class="post-title-link" itemprop="url">1-6 修改正六边形地图单元的坐标</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-10-01 13:03:27" itemprop="dateCreated datePublished" datetime="2020-10-01T13:03:27+00:00">2020-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Unity3D-Hex-Map/" itemprop="url" rel="index"><span itemprop="name">Unity3D Hex Map</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>5.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>　　地图系统是一个回合制策略游戏的基础，一个灵活、稳固、拓展性强的地图系统会给游戏带来更多的可能。</p>
<p>　　上一章中，我们正确的生成了所有的正六边形地图单元，现在让我们来重新观察一下这些地图单元的坐标，如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-6-1.png"></p>
<p>　　通过观察上图我们可以发现，在水平的Z轴方向上，每个地图单元的排列都很正常，但是在垂直的X轴方向上，地图单元排列成了锯齿状。导致这个问题的原因是之前我们取消偶数行偏移造成的。相比于正方形的地图元素排列，正六边形的地图元素排列在处理坐标时并没有那么容易。为了方便之后的一些操作，首先创建一个<code>HexCoordinates</code>结构体，我们可以用它来转换现有的坐标系。转换后的X与Z坐标，只公开get属性，确保其不被修改。使用<code>System.Serializable</code>标记这个结构体，使其可以序列化，以便Unity在runtime模式下也可以识别它。</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> HexCoordinates</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//存储重新计算后的X坐标值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> X &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储重新计算后的Z坐标值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Z &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 重载默认的构造函数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x&quot;&gt;</span>为转换后的X坐标赋初始值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;z&quot;&gt;</span>为转换后的Z坐标赋初始值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HexCoordinates</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Z = z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，创建一个计算坐标偏移的静态方法，我们稍后会完成这个方法，现在只返回传入的参数值即可。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 进行X与Z的坐标转换，将X方向锯齿状的排列，改为斜向的排列</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x&quot;&gt;</span>原始cell的x轴坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;z&quot;&gt;</span>原始cell的z轴坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>目前返回传入的参数值<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HexCoordinates <span class="title">FromOffsetCoordinates</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HexCoordinates(x, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　然后，为了方便之后的观察和调试方便，我们需要重载<code>ToString()</code>方法。如果使用原始的<code>ToString()</code>方法，只会返回struct的名称，这里我们需要返回X和Z的坐标值，修改代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 重载默认的ToString方法，使其返回的是X和Z的坐标值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>X和Z的坐标值<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + X.ToString() + <span class="string">&quot;, &quot;</span> + Z.ToString() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最后，我们还需要声明<code>ToStringOnSeparateLines()</code>方法，用来将X和Z的值输出到之前的UI元素上，这个方法与重载的<code>ToString()</code>方法很类似，只是添加了<code>\n</code>进行换行。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将转换后的X和Z的坐标值添加换行符，以便显示在UGUI的每个cell上</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>添加换行符后的X和Z，符合Text组件的富文本格式<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">ToStringOnSeparateLines</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> X.ToString() + <span class="string">&quot;\n&quot;</span> + Z.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　完成了这些步骤后，让我们回到<code>FromOffsetCoordinates(int x, int z)</code>方法中。</p>
<p>　　这里有个很重要的一点需要注意，在之前的所有步骤中，每个地图单元和其坐标显示，是完全一一对应的，我们在修改地图单元排列方式的同时，其坐标值也会跟着改变。但是在接下来的步骤中，我们会脱离开这种相互影响的关系，只专注于修改坐标。即通过<code>FromOffsetCoordinates(int x, int z)</code>方法将地图单元网格和坐标值两者排列分开。也可以理解为在保持所有地图单元网格排列为矩形不变的情况下，只重新排列每个网格对应的坐标值，这样我们就将坐标与网格分开看待了。在之后的一些步骤中，做到只修改网格或坐标其中之一，而不影响另一个的排列方式的效果。</p>
<p>　　所以，这里我们就要取消坐标值的偶数行的偏移，让X轴的坐标依然是斜向排列的。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 进行X与Z的坐标转换，将X方向锯齿状的排列，改为斜向的排列</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 这个方法将mesh和坐标值分开处理了</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 这里的入参只是处理X和Z的坐标，与mesh的排列和位置无关</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x&quot;&gt;</span>原始cell的x轴坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;z&quot;&gt;</span>原始cell的z轴坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>目前返回传入的参数值<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HexCoordinates <span class="title">FromOffsetCoordinates</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HexCoordinates(x - z / <span class="number">2</span>, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　完成这个方法后，我们回到<code>HexGrid.CreateCell(int x, int z, int i)</code>方法中。这个方法是负责排列每个地图元素、计算每个地图元素的坐标值、将坐标值传递到Text组件上并显示出来。所以要在此方法中调用<code>struct HexCoordinates</code>修改坐标的<code>FromOffsetCoordinates</code>方法，和为Text输出富文本格式坐标值的<code>ToStringOnSeparateLines</code>方法。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置被实例化地图单元的父级和位置</span></span><br><span class="line">    cell.transform.SetParent(transform, <span class="literal">false</span>);</span><br><span class="line">    cell.transform.localPosition = position;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在不改变cell排列的情况下，重新计算每个cell的坐标位置</span></span><br><span class="line">    cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z);</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置label的文字，就是cell在数组中的位置</span></span><br><span class="line">    <span class="comment">//label.text = x.ToString() + &quot;\n&quot; + z.ToString();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将转换后的坐标值复制给UGUI的Text组件，将它显示出来</span></span><br><span class="line">    label.text = cell.coordinates.ToStringOnSeparateLines();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最后，在HexCell组件中创建一个HexCoordinates的实例，这样，在HexGrid实例化地图元素的时候，会自动调用每个地图元素HexCell组件上的HexCoordinates实例进行坐标的转换。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell .cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在实例化每个cell的时候会调用该实例</span></span><br><span class="line">    <span class="comment">//针对每个cell，重新计算它的坐标值</span></span><br><span class="line">    <span class="keyword">public</span> HexCoordinates coordinates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　经过以上步骤的操作，我们的坐标转换就完成了。最终在不改变地图单元mesh排列的情况下，达到了下图的坐标排列效果：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-6-2.png"></p>
<p>　　将修改坐标前后的效果对比一下，更加方便理解和找出其中的规律：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-5-5.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-6-3.png"></p>
<p>　　经过观察转换后的效果，我们发现这样一个问题：如果一个人物站在某个正六边形地图单元上，那他可以朝6个方向移动，分别为右上、右、右下、左下、左、左上。目前我们在这里只有X和Z维度，Z可以描述左右移动和偏移量，X可以描述右上和左下移动和偏移量。这里缺少了描述左上和右下移动和偏移量的坐标。所以，我们需要在这个平面中再添加一个维度，用来描述这两个对称方向的移动和偏移量。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-6-4.png"></p>
<p>　　通过观察上图可以发现，其实只需要将X轴镜像翻转一下，便可以得到Y轴。并且在坐标系的任意一个位置，X+Y+Z的值适中为0。也就是说，一个轴上的坐标值增大，另一个轴上就会减少，这样就产生了6个移动方向。这些坐标通常称为立方体坐标，因为它是三维的,其拓扑结构类似于立方体。</p>
<p>　　通过以上观察和总结，添加Y维度的坐标就变得很容易了。只需要利用X+Y+Z坐标始终为0这个特性即可。我们可以在<code>HexCoordinates</code>中创建一个方法用来计算Y的坐标值，然后在<code>ToString</code>和<code>ToStringOnSeparateLines</code>方法中调用它。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算Y的坐标值并存储下来</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Y</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -X - Z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 进行X与Z的坐标转换，将X方向锯齿状的排列，改为斜向的排列</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 这个方法将mesh和坐标值分开处理了</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 这里的入参只是处理X和Z的坐标，与mesh的排列和位置无关</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x&quot;&gt;</span>原始cell的x轴坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;z&quot;&gt;</span>原始cell的z轴坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>目前返回传入的参数值<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HexCoordinates <span class="title">FromOffsetCoordinates</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HexCoordinates(x - z / <span class="number">2</span>, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 重载默认的ToString方法，使其返回的是转换后的X和Z的坐标值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>X和Z的坐标值<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//return &quot;(&quot; + X.ToString() + &quot;, &quot; + Z.ToString() + &quot;)&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入了Y坐标值的表示</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + X.ToString() + <span class="string">&quot;, &quot;</span> + Y.ToString() + <span class="string">&quot;, &quot;</span> + Z.ToString() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将转换后的X和Z的坐标值添加换行符，以便显示在UGUI的每个cell上</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>添加换行符后的X和Z，符合Text组件的富文本格式<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">ToStringOnSeparateLines</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//return X.ToString() + &quot;\n&quot; + Z.ToString();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入了Y坐标值的输出</span></span><br><span class="line">    <span class="keyword">return</span> X.ToString() + <span class="string">&quot;\n&quot;</span> + Y.ToString() + <span class="string">&quot;\n&quot;</span> + Z.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　完成以上代码后，回到Unity，点击Play按钮查看效果如下图。这样我们在不改变mesh排列的情况下，重新排列了每个地图单元的坐标。并且添加了Y维度的坐标轴，完善了整个地图的坐标系统。</p>
<p>　　下一章，我们会使用脚本将计算好的坐标显示在Inspector上，这样将更加便于我们调试和观察坐标的变化。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-6-5.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/home/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/home/">1</a><span class="space">&hellip;</span><a class="page-number" href="/home/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/home/page/11/">11</a><a class="page-number" href="/home/page/12/">12</a><a class="extend next" rel="next" href="/home/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Arthur Delacroix</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">245k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:43</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>















  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>








  

  
      <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = '//cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>

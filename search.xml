<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World!</title>
    <url>/2019/01/01/hello-world/</url>
    <content><![CDATA[<p>终于把个人博客搭建起来了，对于一个html方向完全空白的人来说实属不易啊！</p>
<p>今后会在博客中不定期更新一些技术文章的心得体会，还有一些简单的个人案例。</p>
<p>12321321321321321</p>
]]></content>
  </entry>
  <entry>
    <title>CrossMe 谜题答案 2.101 - 2.150</title>
    <url>/2023/11/05/CrossMe/CrossMe_2_101_150/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>2.101</strong></td>
<td align="center"><strong>2.102</strong></td>
<td align="center"><strong>2.103</strong></td>
<td align="center"><strong>2.104</strong></td>
<td align="center"><strong>2.105</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.101.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.102.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.103.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.104.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.105.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.106</strong></td>
<td align="center"><strong>2.107</strong></td>
<td align="center"><strong>2.108</strong></td>
<td align="center"><strong>2.109</strong></td>
<td align="center"><strong>2.110</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.106.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.107.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.108.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.109.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.110.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.111</strong></td>
<td align="center"><strong>2.112</strong></td>
<td align="center"><strong>2.113</strong></td>
<td align="center"><strong>2.114</strong></td>
<td align="center"><strong>2.115</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.111.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.112.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.113.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.114.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.115.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.116</strong></td>
<td align="center"><strong>2.117</strong></td>
<td align="center"><strong>2.118</strong></td>
<td align="center"><strong>2.119</strong></td>
<td align="center"><strong>2.120</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.116.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.117.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.118.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.119.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.120.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.121</strong></td>
<td align="center"><strong>2.122</strong></td>
<td align="center"><strong>2.123</strong></td>
<td align="center"><strong>2.124</strong></td>
<td align="center"><strong>2.125</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.121.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.122.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.123.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.124.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.125.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.126</strong></td>
<td align="center"><strong>2.127</strong></td>
<td align="center"><strong>2.128</strong></td>
<td align="center"><strong>2.129</strong></td>
<td align="center"><strong>2.130</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.126.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.127.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.128.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.129.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.130.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.131</strong></td>
<td align="center"><strong>2.132</strong></td>
<td align="center"><strong>2.133</strong></td>
<td align="center"><strong>2.134</strong></td>
<td align="center"><strong>2.135</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.131.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.132.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.133.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.134.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.135.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.136</strong></td>
<td align="center"><strong>2.137</strong></td>
<td align="center"><strong>2.138</strong></td>
<td align="center"><strong>2.139</strong></td>
<td align="center"><strong>2.140</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.136.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.137.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.138.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.139.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.140.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.141</strong></td>
<td align="center"><strong>2.142</strong></td>
<td align="center"><strong>2.143</strong></td>
<td align="center"><strong>2.144</strong></td>
<td align="center"><strong>2.145</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.141.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.142.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.143.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.144.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.145.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.146</strong></td>
<td align="center"><strong>2.147</strong></td>
<td align="center"><strong>2.148</strong></td>
<td align="center"><strong>2.149</strong></td>
<td align="center"><strong>2.150</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.146.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.147.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.148.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.149.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.150.jpg?raw=true"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>CrossMe</tag>
        <tag>Nonogram</tag>
      </tags>
  </entry>
  <entry>
    <title>CrossMe 谜题答案 2.151 - 2.200</title>
    <url>/2023/11/06/CrossMe/CrossMe_2_151_200/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>2.151</strong></td>
<td align="center"><strong>2.152</strong></td>
<td align="center"><strong>2.153</strong></td>
<td align="center"><strong>2.154</strong></td>
<td align="center"><strong>2.155</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.151.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.152.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.153.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.154.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.155.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.156</strong></td>
<td align="center"><strong>2.157</strong></td>
<td align="center"><strong>2.158</strong></td>
<td align="center"><strong>2.159</strong></td>
<td align="center"><strong>2.160</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.156.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.157.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.158.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.159.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.160.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.161</strong></td>
<td align="center"><strong>2.162</strong></td>
<td align="center"><strong>2.163</strong></td>
<td align="center"><strong>2.164</strong></td>
<td align="center"><strong>2.165</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.161.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.162.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.163.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.164.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.165.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.166</strong></td>
<td align="center"><strong>2.167</strong></td>
<td align="center"><strong>2.168</strong></td>
<td align="center"><strong>2.169</strong></td>
<td align="center"><strong>2.170</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.166.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.167.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.168.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.169.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.170.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.171</strong></td>
<td align="center"><strong>2.172</strong></td>
<td align="center"><strong>2.173</strong></td>
<td align="center"><strong>2.174</strong></td>
<td align="center"><strong>2.175</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.171.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.172.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.173.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.174.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.175.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.176</strong></td>
<td align="center"><strong>2.177</strong></td>
<td align="center"><strong>2.178</strong></td>
<td align="center"><strong>2.179</strong></td>
<td align="center"><strong>2.180</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.176.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.177.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.178.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.179.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.180.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.181</strong></td>
<td align="center"><strong>2.182</strong></td>
<td align="center"><strong>2.183</strong></td>
<td align="center"><strong>2.184</strong></td>
<td align="center"><strong>2.185</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.181.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.182.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.183.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.184.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.185.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.186</strong></td>
<td align="center"><strong>2.187</strong></td>
<td align="center"><strong>2.188</strong></td>
<td align="center"><strong>2.189</strong></td>
<td align="center"><strong>2.190</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.186.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.187.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.188.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.189.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.190.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.191</strong></td>
<td align="center"><strong>2.192</strong></td>
<td align="center"><strong>2.193</strong></td>
<td align="center"><strong>2.194</strong></td>
<td align="center"><strong>2.195</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.191.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.192.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.193.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.194.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.195.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.196</strong></td>
<td align="center"><strong>2.197</strong></td>
<td align="center"><strong>2.198</strong></td>
<td align="center"><strong>2.199</strong></td>
<td align="center"><strong>2.200</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.196.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.197.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.198.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.199.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.200.jpg?raw=true"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>CrossMe</tag>
        <tag>Nonogram</tag>
      </tags>
  </entry>
  <entry>
    <title>CrossMe 谜题答案 2.201 - 2.250</title>
    <url>/2023/11/08/CrossMe/CrossMe_2_201_250/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>2.201</strong></td>
<td align="center"><strong>2.202</strong></td>
<td align="center"><strong>2.203</strong></td>
<td align="center"><strong>2.204</strong></td>
<td align="center"><strong>2.205</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.201.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.202.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.203.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.204.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.205.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.206</strong></td>
<td align="center"><strong>2.207</strong></td>
<td align="center"><strong>2.208</strong></td>
<td align="center"><strong>2.209</strong></td>
<td align="center"><strong>2.210</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.206.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.207.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.208.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.209.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.210.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.211</strong></td>
<td align="center"><strong>2.212</strong></td>
<td align="center"><strong>2.213</strong></td>
<td align="center"><strong>2.214</strong></td>
<td align="center"><strong>2.215</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.211.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.212.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.213.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.214.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.215.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.216</strong></td>
<td align="center"><strong>2.217</strong></td>
<td align="center"><strong>2.218</strong></td>
<td align="center"><strong>2.219</strong></td>
<td align="center"><strong>2.220</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.216.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.217.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.218.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.219.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.220.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.221</strong></td>
<td align="center"><strong>2.222</strong></td>
<td align="center"><strong>2.223</strong></td>
<td align="center"><strong>2.224</strong></td>
<td align="center"><strong>2.225</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.221.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.222.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.223.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.224.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.225.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.226</strong></td>
<td align="center"><strong>2.227</strong></td>
<td align="center"><strong>2.228</strong></td>
<td align="center"><strong>2.229</strong></td>
<td align="center"><strong>2.230</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.226.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.227.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.228.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.229.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.230.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.231</strong></td>
<td align="center"><strong>2.232</strong></td>
<td align="center"><strong>2.233</strong></td>
<td align="center"><strong>2.234</strong></td>
<td align="center"><strong>2.235</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.231.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.232.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.233.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.234.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.235.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.236</strong></td>
<td align="center"><strong>2.237</strong></td>
<td align="center"><strong>2.238</strong></td>
<td align="center"><strong>2.239</strong></td>
<td align="center"><strong>2.240</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.236.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.237.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.238.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.239.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.240.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.241</strong></td>
<td align="center"><strong>2.242</strong></td>
<td align="center"><strong>2.243</strong></td>
<td align="center"><strong>2.244</strong></td>
<td align="center"><strong>2.245</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.241.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.242.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.243.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.244.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.245.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.246</strong></td>
<td align="center"><strong>2.247</strong></td>
<td align="center"><strong>2.248</strong></td>
<td align="center"><strong>2.249</strong></td>
<td align="center"><strong>2.250</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.246.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.247.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.248.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.249.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.250.jpg?raw=true"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>CrossMe</tag>
        <tag>Nonogram</tag>
      </tags>
  </entry>
  <entry>
    <title>CrossMe 谜题答案 2.1 - 2.51</title>
    <url>/2023/11/02/CrossMe/CrossMe_2_1_51/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>2.1</strong></td>
<td align="center"><strong>2.2</strong></td>
<td align="center"><strong>2.3</strong></td>
<td align="center"><strong>2.4</strong></td>
<td align="center"><strong>2.5</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.1.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.2.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.3.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.4.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.5.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.6</strong></td>
<td align="center"><strong>2.7</strong></td>
<td align="center"><strong>2.8</strong></td>
<td align="center"><strong>2.9</strong></td>
<td align="center"><strong>2.10</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.6.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.7.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.8.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.9.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.10.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.11</strong></td>
<td align="center"><strong>2.12</strong></td>
<td align="center"><strong>2.13</strong></td>
<td align="center"><strong>2.14</strong></td>
<td align="center"><strong>2.15</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.11.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.12.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.13.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.14.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.15.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.16</strong></td>
<td align="center"><strong>2.17</strong></td>
<td align="center"><strong>2.18</strong></td>
<td align="center"><strong>2.19</strong></td>
<td align="center"><strong>2.20</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.16.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.17.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.18.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.19.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.20.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.21</strong></td>
<td align="center"><strong>2.22</strong></td>
<td align="center"><strong>2.23</strong></td>
<td align="center"><strong>2.24</strong></td>
<td align="center"><strong>2.25</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.21.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.22.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.23.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.24.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.25.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.26</strong></td>
<td align="center"><strong>2.27</strong></td>
<td align="center"><strong>2.28</strong></td>
<td align="center"><strong>2.29</strong></td>
<td align="center"><strong>2.30</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.26.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.27.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.28.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.29.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.30.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.31</strong></td>
<td align="center"><strong>2.32</strong></td>
<td align="center"><strong>2.33</strong></td>
<td align="center"><strong>2.34</strong></td>
<td align="center"><strong>2.35</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.31.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.32.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.33.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.34.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.35.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.36</strong></td>
<td align="center"><strong>2.37</strong></td>
<td align="center"><strong>2.38</strong></td>
<td align="center"><strong>2.39</strong></td>
<td align="center"><strong>2.40</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.36.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.37.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.38.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.39.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.40.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.41</strong></td>
<td align="center"><strong>2.42</strong></td>
<td align="center"><strong>2.43</strong></td>
<td align="center"><strong>2.44</strong></td>
<td align="center"><strong>2.45</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.41.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.42.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.43.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.44.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.45.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.46</strong></td>
<td align="center"><strong>2.47</strong></td>
<td align="center"><strong>2.48</strong></td>
<td align="center"><strong>2.49</strong></td>
<td align="center"><strong>2.50</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.46.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.47.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.48.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.49.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.50.jpg?raw=true"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>CrossMe</tag>
        <tag>Nonogram</tag>
      </tags>
  </entry>
  <entry>
    <title>CrossMe 谜题答案 2.251 - 2.300</title>
    <url>/2023/11/10/CrossMe/CrossMe_2_251_300/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>2.251</strong></td>
<td align="center"><strong>2.252</strong></td>
<td align="center"><strong>2.253</strong></td>
<td align="center"><strong>2.254</strong></td>
<td align="center"><strong>2.255</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.251.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.252.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.253.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.254.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.255.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.256</strong></td>
<td align="center"><strong>2.257</strong></td>
<td align="center"><strong>2.258</strong></td>
<td align="center"><strong>2.259</strong></td>
<td align="center"><strong>2.260</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.256.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.257.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.258.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.259.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.260.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.261</strong></td>
<td align="center"><strong>2.262</strong></td>
<td align="center"><strong>2.263</strong></td>
<td align="center"><strong>2.264</strong></td>
<td align="center"><strong>2.265</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.261.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.262.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.263.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.264.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.265.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.266</strong></td>
<td align="center"><strong>2.267</strong></td>
<td align="center"><strong>2.268</strong></td>
<td align="center"><strong>2.269</strong></td>
<td align="center"><strong>2.270</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.266.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.267.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.268.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.269.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.270.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.271</strong></td>
<td align="center"><strong>2.272</strong></td>
<td align="center"><strong>2.273</strong></td>
<td align="center"><strong>2.274</strong></td>
<td align="center"><strong>2.275</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.271.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.272.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.273.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.274.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.275.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.276</strong></td>
<td align="center"><strong>2.277</strong></td>
<td align="center"><strong>2.278</strong></td>
<td align="center"><strong>2.279</strong></td>
<td align="center"><strong>2.280</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.276.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.277.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.278.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.279.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.280.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.281</strong></td>
<td align="center"><strong>2.282</strong></td>
<td align="center"><strong>2.283</strong></td>
<td align="center"><strong>2.284</strong></td>
<td align="center"><strong>2.285</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.281.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.282.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.283.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.284.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.285.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.286</strong></td>
<td align="center"><strong>2.287</strong></td>
<td align="center"><strong>2.288</strong></td>
<td align="center"><strong>2.289</strong></td>
<td align="center"><strong>2.290</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.286.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.287.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.288.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.289.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.290.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.291</strong></td>
<td align="center"><strong>2.292</strong></td>
<td align="center"><strong>2.293</strong></td>
<td align="center"><strong>2.294</strong></td>
<td align="center"><strong>2.295</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.291.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.292.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.293.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.294.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.295.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.296</strong></td>
<td align="center"><strong>2.297</strong></td>
<td align="center"><strong>2.298</strong></td>
<td align="center"><strong>2.299</strong></td>
<td align="center"><strong>2.300</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.296.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.297.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.298.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.299.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.300.jpg?raw=true"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>CrossMe</tag>
        <tag>Nonogram</tag>
      </tags>
  </entry>
  <entry>
    <title>CrossMe 谜题答案 2.301 - 2.350</title>
    <url>/2023/11/12/CrossMe/CrossMe_2_301_350/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>2.301</strong></td>
<td align="center"><strong>2.302</strong></td>
<td align="center"><strong>2.303</strong></td>
<td align="center"><strong>2.304</strong></td>
<td align="center"><strong>2.305</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.301.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.302.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.303.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.304.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.305.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.306</strong></td>
<td align="center"><strong>2.307</strong></td>
<td align="center"><strong>2.308</strong></td>
<td align="center"><strong>2.309</strong></td>
<td align="center"><strong>2.310</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.306.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.307.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.308.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.309.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.310.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.311</strong></td>
<td align="center"><strong>2.312</strong></td>
<td align="center"><strong>2.313</strong></td>
<td align="center"><strong>2.314</strong></td>
<td align="center"><strong>2.315</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.311.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.312.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.313.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.314.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.315.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.316</strong></td>
<td align="center"><strong>2.317</strong></td>
<td align="center"><strong>2.318</strong></td>
<td align="center"><strong>2.319</strong></td>
<td align="center"><strong>2.320</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.316.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.317.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.318.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.319.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.320.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.321</strong></td>
<td align="center"><strong>2.322</strong></td>
<td align="center"><strong>2.323</strong></td>
<td align="center"><strong>2.324</strong></td>
<td align="center"><strong>2.325</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.321.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.322.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.323.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.324.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.325.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.326</strong></td>
<td align="center"><strong>2.327</strong></td>
<td align="center"><strong>2.328</strong></td>
<td align="center"><strong>2.329</strong></td>
<td align="center"><strong>2.330</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.326.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.327.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.328.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.329.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.330.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.331</strong></td>
<td align="center"><strong>2.332</strong></td>
<td align="center"><strong>2.333</strong></td>
<td align="center"><strong>2.334</strong></td>
<td align="center"><strong>2.335</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.331.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.332.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.333.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.334.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.335.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.336</strong></td>
<td align="center"><strong>2.337</strong></td>
<td align="center"><strong>2.338</strong></td>
<td align="center"><strong>2.339</strong></td>
<td align="center"><strong>2.340</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.336.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.337.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.338.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.339.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.340.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.341</strong></td>
<td align="center"><strong>2.342</strong></td>
<td align="center"><strong>2.343</strong></td>
<td align="center"><strong>2.344</strong></td>
<td align="center"><strong>2.345</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.341.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.342.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.343.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.344.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.345.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.346</strong></td>
<td align="center"><strong>2.347</strong></td>
<td align="center"><strong>2.348</strong></td>
<td align="center"><strong>2.349</strong></td>
<td align="center"><strong>2.350</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.346.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.347.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.348.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.349.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.350.jpg?raw=true"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>CrossMe</tag>
        <tag>Nonogram</tag>
      </tags>
  </entry>
  <entry>
    <title>CrossMe 谜题答案 2.351 - 2.400</title>
    <url>/2023/11/15/CrossMe/CrossMe_2_351_400/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>2.351</strong></td>
<td align="center"><strong>2.352</strong></td>
<td align="center"><strong>2.353</strong></td>
<td align="center"><strong>2.354</strong></td>
<td align="center"><strong>2.355</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.351.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.352.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.353.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.354.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.355.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.356</strong></td>
<td align="center"><strong>2.357</strong></td>
<td align="center"><strong>2.358</strong></td>
<td align="center"><strong>2.359</strong></td>
<td align="center"><strong>2.360</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.356.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.357.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.358.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.359.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.360.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.361</strong></td>
<td align="center"><strong>2.362</strong></td>
<td align="center"><strong>2.363</strong></td>
<td align="center"><strong>2.364</strong></td>
<td align="center"><strong>2.365</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.361.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.362.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.363.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.364.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.365.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.366</strong></td>
<td align="center"><strong>2.367</strong></td>
<td align="center"><strong>2.368</strong></td>
<td align="center"><strong>2.369</strong></td>
<td align="center"><strong>2.370</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.366.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.367.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.368.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.369.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.370.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.371</strong></td>
<td align="center"><strong>2.372</strong></td>
<td align="center"><strong>2.373</strong></td>
<td align="center"><strong>2.374</strong></td>
<td align="center"><strong>2.375</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.371.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.372.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.373.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.374.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.375.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.376</strong></td>
<td align="center"><strong>2.377</strong></td>
<td align="center"><strong>2.378</strong></td>
<td align="center"><strong>2.379</strong></td>
<td align="center"><strong>2.380</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.376.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.377.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.378.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.379.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.380.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.381</strong></td>
<td align="center"><strong>2.382</strong></td>
<td align="center"><strong>2.383</strong></td>
<td align="center"><strong>2.384</strong></td>
<td align="center"><strong>2.385</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.381.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.382.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.383.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.384.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.385.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.386</strong></td>
<td align="center"><strong>2.387</strong></td>
<td align="center"><strong>2.388</strong></td>
<td align="center"><strong>2.389</strong></td>
<td align="center"><strong>2.390</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.386.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.387.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.388.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.389.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.390.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.391</strong></td>
<td align="center"><strong>2.392</strong></td>
<td align="center"><strong>2.393</strong></td>
<td align="center"><strong>2.394</strong></td>
<td align="center"><strong>2.395</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.391.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.392.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.393.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.394.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.395.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.396</strong></td>
<td align="center"><strong>2.397</strong></td>
<td align="center"><strong>2.398</strong></td>
<td align="center"><strong>2.399</strong></td>
<td align="center"><strong>2.400</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.396.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.397.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.398.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.399.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.400.jpg?raw=true"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>CrossMe</tag>
        <tag>Nonogram</tag>
      </tags>
  </entry>
  <entry>
    <title>CrossMe 谜题答案 2.401 - 2.450</title>
    <url>/2023/11/17/CrossMe/CrossMe_2_401_450/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>2.401</strong></td>
<td align="center"><strong>2.402</strong></td>
<td align="center"><strong>2.403</strong></td>
<td align="center"><strong>2.404</strong></td>
<td align="center"><strong>2.405</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.401.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.402.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.403.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.404.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.405.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.406</strong></td>
<td align="center"><strong>2.407</strong></td>
<td align="center"><strong>2.408</strong></td>
<td align="center"><strong>2.409</strong></td>
<td align="center"><strong>2.410</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.406.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.407.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.408.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.409.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.410.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.411</strong></td>
<td align="center"><strong>2.412</strong></td>
<td align="center"><strong>2.413</strong></td>
<td align="center"><strong>2.414</strong></td>
<td align="center"><strong>2.415</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.411.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.412.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.413.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.414.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.415.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.416</strong></td>
<td align="center"><strong>2.417</strong></td>
<td align="center"><strong>2.418</strong></td>
<td align="center"><strong>2.419</strong></td>
<td align="center"><strong>2.420</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.416.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.417.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.418.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.419.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.420.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.421</strong></td>
<td align="center"><strong>2.422</strong></td>
<td align="center"><strong>2.423</strong></td>
<td align="center"><strong>2.424</strong></td>
<td align="center"><strong>2.425</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.421.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.422.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.423.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.424.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.425.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.426</strong></td>
<td align="center"><strong>2.427</strong></td>
<td align="center"><strong>2.428</strong></td>
<td align="center"><strong>2.429</strong></td>
<td align="center"><strong>2.430</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.426.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.427.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.428.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.429.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.430.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.431</strong></td>
<td align="center"><strong>2.432</strong></td>
<td align="center"><strong>2.433</strong></td>
<td align="center"><strong>2.434</strong></td>
<td align="center"><strong>2.435</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.431.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.432.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.433.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.434.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.435.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.436</strong></td>
<td align="center"><strong>2.437</strong></td>
<td align="center"><strong>2.438</strong></td>
<td align="center"><strong>2.439</strong></td>
<td align="center"><strong>2.440</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.436.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.437.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.438.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.439.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.440.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.441</strong></td>
<td align="center"><strong>2.442</strong></td>
<td align="center"><strong>2.443</strong></td>
<td align="center"><strong>2.444</strong></td>
<td align="center"><strong>2.445</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.441.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.442.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.443.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.444.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.445.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.446</strong></td>
<td align="center"><strong>2.447</strong></td>
<td align="center"><strong>2.448</strong></td>
<td align="center"><strong>2.449</strong></td>
<td align="center"><strong>2.450</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.446.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.447.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.448.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.449.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.450.jpg?raw=true"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>CrossMe</tag>
        <tag>Nonogram</tag>
      </tags>
  </entry>
  <entry>
    <title>CrossMe 谜题答案 2.451 - 2.500</title>
    <url>/2023/11/16/CrossMe/CrossMe_2_451_500/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>2.451</strong></td>
<td align="center"><strong>2.452</strong></td>
<td align="center"><strong>2.453</strong></td>
<td align="center"><strong>2.454</strong></td>
<td align="center"><strong>2.455</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.451.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.452.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.453.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.454.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.455.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.456</strong></td>
<td align="center"><strong>2.457</strong></td>
<td align="center"><strong>2.458</strong></td>
<td align="center"><strong>2.459</strong></td>
<td align="center"><strong>2.460</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.456.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.457.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.458.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.459.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.460.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.461</strong></td>
<td align="center"><strong>2.462</strong></td>
<td align="center"><strong>2.463</strong></td>
<td align="center"><strong>2.464</strong></td>
<td align="center"><strong>2.465</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.461.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.462.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.463.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.464.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.465.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.466</strong></td>
<td align="center"><strong>2.467</strong></td>
<td align="center"><strong>2.468</strong></td>
<td align="center"><strong>2.469</strong></td>
<td align="center"><strong>2.470</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.466.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.467.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.468.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.469.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.470.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.471</strong></td>
<td align="center"><strong>2.472</strong></td>
<td align="center"><strong>2.473</strong></td>
<td align="center"><strong>2.474</strong></td>
<td align="center"><strong>2.475</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.471.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.472.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.473.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.474.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.475.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.476</strong></td>
<td align="center"><strong>2.477</strong></td>
<td align="center"><strong>2.478</strong></td>
<td align="center"><strong>2.479</strong></td>
<td align="center"><strong>2.480</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.476.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.477.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.478.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.479.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.480.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.481</strong></td>
<td align="center"><strong>2.482</strong></td>
<td align="center"><strong>2.483</strong></td>
<td align="center"><strong>2.484</strong></td>
<td align="center"><strong>2.485</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.481.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.482.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.483.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.484.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.485.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.486</strong></td>
<td align="center"><strong>2.487</strong></td>
<td align="center"><strong>2.488</strong></td>
<td align="center"><strong>2.489</strong></td>
<td align="center"><strong>2.490</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.486.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.487.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.488.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.489.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.490.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.491</strong></td>
<td align="center"><strong>2.492</strong></td>
<td align="center"><strong>2.493</strong></td>
<td align="center"><strong>2.494</strong></td>
<td align="center"><strong>2.495</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.491.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.492.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.493.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.494.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.495.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.496</strong></td>
<td align="center"><strong>2.497</strong></td>
<td align="center"><strong>2.498</strong></td>
<td align="center"><strong>2.499</strong></td>
<td align="center"><strong>2.500</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.496.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.497.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.498.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.499.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.500.jpg?raw=true"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>CrossMe</tag>
        <tag>Nonogram</tag>
      </tags>
  </entry>
  <entry>
    <title>CrossMe 谜题答案 2.501 - 2.550</title>
    <url>/2023/11/19/CrossMe/CrossMe_2_501_550/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>2.501</strong></td>
<td align="center"><strong>2.502</strong></td>
<td align="center"><strong>2.503</strong></td>
<td align="center"><strong>2.504</strong></td>
<td align="center"><strong>2.505</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.501.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.502.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.503.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.504.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.505.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.506</strong></td>
<td align="center"><strong>2.507</strong></td>
<td align="center"><strong>2.508</strong></td>
<td align="center"><strong>2.509</strong></td>
<td align="center"><strong>2.510</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.506.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.507.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.508.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.509.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.510.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.511</strong></td>
<td align="center"><strong>2.512</strong></td>
<td align="center"><strong>2.513</strong></td>
<td align="center"><strong>2.514</strong></td>
<td align="center"><strong>2.515</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.511.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.512.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.513.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.514.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.515.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.516</strong></td>
<td align="center"><strong>2.517</strong></td>
<td align="center"><strong>2.518</strong></td>
<td align="center"><strong>2.519</strong></td>
<td align="center"><strong>2.520</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.516.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.517.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.518.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.519.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.520.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.521</strong></td>
<td align="center"><strong>2.522</strong></td>
<td align="center"><strong>2.523</strong></td>
<td align="center"><strong>2.524</strong></td>
<td align="center"><strong>2.525</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.521.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.522.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.523.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.524.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.525.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.526</strong></td>
<td align="center"><strong>2.527</strong></td>
<td align="center"><strong>2.528</strong></td>
<td align="center"><strong>2.529</strong></td>
<td align="center"><strong>2.530</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.526.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.527.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.528.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.529.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.530.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.531</strong></td>
<td align="center"><strong>2.532</strong></td>
<td align="center"><strong>2.533</strong></td>
<td align="center"><strong>2.534</strong></td>
<td align="center"><strong>2.535</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.531.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.532.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.533.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.534.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.535.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.536</strong></td>
<td align="center"><strong>2.537</strong></td>
<td align="center"><strong>2.538</strong></td>
<td align="center"><strong>2.539</strong></td>
<td align="center"><strong>2.540</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.536.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.537.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.538.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.539.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.540.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.541</strong></td>
<td align="center"><strong>2.542</strong></td>
<td align="center"><strong>2.543</strong></td>
<td align="center"><strong>2.544</strong></td>
<td align="center"><strong>2.545</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.541.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.542.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.543.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.544.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.545.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.546</strong></td>
<td align="center"><strong>2.547</strong></td>
<td align="center"><strong>2.548</strong></td>
<td align="center"><strong>2.549</strong></td>
<td align="center"><strong>2.550</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.546.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.547.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.548.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.549.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.550.jpg?raw=true"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>CrossMe</tag>
        <tag>Nonogram</tag>
      </tags>
  </entry>
  <entry>
    <title>CrossMe 谜题答案 2.51 - 2.100</title>
    <url>/2023/11/03/CrossMe/CrossMe_2_51_100/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>2.51</strong></td>
<td align="center"><strong>2.52</strong></td>
<td align="center"><strong>2.53</strong></td>
<td align="center"><strong>2.54</strong></td>
<td align="center"><strong>2.55</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.51.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.52.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.53.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.54.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.55.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.56</strong></td>
<td align="center"><strong>2.57</strong></td>
<td align="center"><strong>2.58</strong></td>
<td align="center"><strong>2.59</strong></td>
<td align="center"><strong>2.60</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.56.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.57.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.58.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.59.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.60.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.61</strong></td>
<td align="center"><strong>2.62</strong></td>
<td align="center"><strong>2.63</strong></td>
<td align="center"><strong>2.64</strong></td>
<td align="center"><strong>2.65</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.61.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.62.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.63.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.64.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.65.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.66</strong></td>
<td align="center"><strong>2.67</strong></td>
<td align="center"><strong>2.68</strong></td>
<td align="center"><strong>2.69</strong></td>
<td align="center"><strong>2.70</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.66.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.67.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.68.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.69.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.70.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.71</strong></td>
<td align="center"><strong>2.72</strong></td>
<td align="center"><strong>2.73</strong></td>
<td align="center"><strong>2.74</strong></td>
<td align="center"><strong>2.75</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.71.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.72.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.73.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.74.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.75.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.76</strong></td>
<td align="center"><strong>2.77</strong></td>
<td align="center"><strong>2.78</strong></td>
<td align="center"><strong>2.79</strong></td>
<td align="center"><strong>2.80</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.76.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.77.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.78.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.79.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.80.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.81</strong></td>
<td align="center"><strong>2.82</strong></td>
<td align="center"><strong>2.83</strong></td>
<td align="center"><strong>2.84</strong></td>
<td align="center"><strong>2.85</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.81.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.82.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.83.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.84.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.85.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.86</strong></td>
<td align="center"><strong>2.87</strong></td>
<td align="center"><strong>2.88</strong></td>
<td align="center"><strong>2.89</strong></td>
<td align="center"><strong>2.90</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.86.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.87.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.88.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.89.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.90.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.91</strong></td>
<td align="center"><strong>2.92</strong></td>
<td align="center"><strong>2.93</strong></td>
<td align="center"><strong>2.94</strong></td>
<td align="center"><strong>2.95</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.91.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.92.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.93.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.94.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.95.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.96</strong></td>
<td align="center"><strong>2.97</strong></td>
<td align="center"><strong>2.98</strong></td>
<td align="center"><strong>2.99</strong></td>
<td align="center"><strong>2.100</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.96.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.97.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.98.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.99.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.100.jpg?raw=true"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>CrossMe</tag>
        <tag>Nonogram</tag>
      </tags>
  </entry>
  <entry>
    <title>CrossMe 谜题答案 2.551 - 2.600</title>
    <url>/2023/11/21/CrossMe/CrossMe_2_551_600/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>2.551</strong></td>
<td align="center"><strong>2.552</strong></td>
<td align="center"><strong>2.553</strong></td>
<td align="center"><strong>2.554</strong></td>
<td align="center"><strong>2.555</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.551.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.552.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.553.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.554.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.555.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.556</strong></td>
<td align="center"><strong>2.557</strong></td>
<td align="center"><strong>2.558</strong></td>
<td align="center"><strong>2.559</strong></td>
<td align="center"><strong>2.560</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.556.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.557.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.558.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.559.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.560.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.561</strong></td>
<td align="center"><strong>2.562</strong></td>
<td align="center"><strong>2.563</strong></td>
<td align="center"><strong>2.564</strong></td>
<td align="center"><strong>2.565</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.561.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.562.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.563.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.564.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.565.jpg?raw=true"></td>
</tr>
<tr>
<td align="center"><strong>2.566</strong></td>
<td align="center"><strong>2.567</strong></td>
<td align="center"><strong>2.568</strong></td>
<td align="center"><strong>2.569</strong></td>
<td align="center"><strong>2.570</strong></td>
</tr>
<tr>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.566.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.567.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.568.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.569.jpg?raw=true"></td>
<td align="center"><img src="https://github.com/Arthur-Delacroix/CrossMeSolution/blob/main/CrossMe/CrossMe/2/2.570.jpg?raw=true"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Games</category>
      </categories>
      <tags>
        <tag>CrossMe</tag>
        <tag>Nonogram</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Markdown 中的公式书写</title>
    <url>/2021/03/13/Github/Github%20Markdown%20%E4%B8%AD%E7%9A%84%E5%85%AC%E5%BC%8F%E4%B9%A6%E5%86%99/</url>
    <content><![CDATA[<h2 id="行内公式与行间公式"><a href="#行内公式与行间公式" class="headerlink" title="行内公式与行间公式"></a>行内公式与行间公式</h2><p>一般公式分为两种形式，行内公式和行间公式。</p>
<ul>
<li>行内公式：$\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt,.$</li>
</ul>
<p>代码：<br><code>$\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,.$</code></p>
<ul>
<li>行间公式：$$\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt,.$$</li>
</ul>
<p>代码：<br><code>$$\Gamma(z) = \int_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt\,.$$</code></p>
<hr>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table>
<thead>
<tr>
<th>名称</th>
<th>大写</th>
<th>code</th>
<th>小写</th>
<th>code</th>
</tr>
</thead>
<tbody><tr>
<td>alpha</td>
<td></td>
<td></td>
<td>$\alpha$</td>
<td><code>$\alpha$</code></td>
</tr>
<tr>
<td>beta</td>
<td></td>
<td></td>
<td>$\beta$</td>
<td><code>$\beta$</code></td>
</tr>
<tr>
<td>gamma</td>
<td>$\Gamma$</td>
<td><code>$\Gamma$</code></td>
<td>$\gamma$</td>
<td><code>$\gamma$</code></td>
</tr>
<tr>
<td>delta</td>
<td>$\Delta$</td>
<td><code>$\Delta$</code></td>
<td>$\delta$</td>
<td><code>$\delta$</code></td>
</tr>
<tr>
<td>epsilon</td>
<td></td>
<td></td>
<td>$\epsilon$</td>
<td><code>$\epsilon$</code></td>
</tr>
<tr>
<td>zeta</td>
<td></td>
<td></td>
<td>$\zeta$</td>
<td><code>$\zeta$</code></td>
</tr>
<tr>
<td>eta</td>
<td></td>
<td></td>
<td>$\eta$</td>
<td><code>$\eta$</code></td>
</tr>
<tr>
<td>theta</td>
<td>$\Theta$</td>
<td><code>$\Theta$</code></td>
<td>$\theta$</td>
<td><code>$\theta$</code></td>
</tr>
<tr>
<td>iota</td>
<td></td>
<td></td>
<td>$\iota$</td>
<td><code>$\iota$</code></td>
</tr>
<tr>
<td>kappa</td>
<td></td>
<td></td>
<td>$\kappa$</td>
<td><code>$\kappa$</code></td>
</tr>
<tr>
<td>lambda</td>
<td>$\Lambda$</td>
<td><code>$\Lambda$</code></td>
<td>$\lambda$</td>
<td><code>$\lambda$</code></td>
</tr>
<tr>
<td>mu</td>
<td></td>
<td></td>
<td>$\mu$</td>
<td><code>$\mu$</code></td>
</tr>
<tr>
<td>nu</td>
<td></td>
<td></td>
<td>$\nu$</td>
<td><code>$\nu$</code></td>
</tr>
<tr>
<td>xi</td>
<td>$\Xi$</td>
<td><code>$\Xi$</code></td>
<td>$\xi$</td>
<td><code>$\xi$</code></td>
</tr>
<tr>
<td>omicron</td>
<td></td>
<td></td>
<td>$\omicron$</td>
<td><code>$\omicron$</code></td>
</tr>
<tr>
<td>pi</td>
<td>$\Pi$</td>
<td><code>$\Pi$</code></td>
<td>$\pi$</td>
<td><code>$\pi$</code></td>
</tr>
<tr>
<td>rho</td>
<td></td>
<td></td>
<td>$\rho$</td>
<td><code>$\rho$</code></td>
</tr>
<tr>
<td>sigma</td>
<td>$\Sigma$</td>
<td><code>$\Sigma$</code></td>
<td>$\sigma$</td>
<td><code>$\sigma$</code></td>
</tr>
<tr>
<td>tau</td>
<td></td>
<td></td>
<td>$\tau$</td>
<td><code>$\tau$</code></td>
</tr>
<tr>
<td>upsilon</td>
<td>$\Upsilon$</td>
<td><code>$\Upsilon$</code></td>
<td>$\upsilon$</td>
<td><code>$\upsilon$</code></td>
</tr>
<tr>
<td>phi</td>
<td>$\Phi$</td>
<td><code>$\Phi$</code></td>
<td>$\phi$</td>
<td><code>$\phi$</code></td>
</tr>
<tr>
<td>chi</td>
<td></td>
<td></td>
<td>$\chi$</td>
<td><code>$\chi$</code></td>
</tr>
<tr>
<td>psi</td>
<td>$\Psi$</td>
<td><code>$\Psi$</code></td>
<td>$\psi$</td>
<td><code>$\psi$</code></td>
</tr>
<tr>
<td>omega</td>
<td>$\Omega$</td>
<td><code>$\Omega$</code></td>
<td>$\omega$</td>
<td><code>$\omega$</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h2><p>上标和下标分别使用<code>^</code>与<code>_</code>表示，例如<code>$x_i^2$</code>输出为：$x_i^2$。<br>默认情况下，上、下标符号仅仅对下一个组起作用。一个组即单个字符或者使用<code>&#123; &#125;</code>包裹起来的内容。如果使用<code>$10^10$</code>输出为：$10^10$，而<code>$10^&#123;10&#125;$</code>才是 $10^{10}$。<br>同时，大括号还能消除二义性，例如<code>$x^5^6$</code>将得到一个错误。必须使用大括号来界定<code>^</code>的结合性，如<code>$&#123;x^5&#125;^6$</code>：${x^5}^6$，或者<code>$x^&#123;5^6&#125;$</code>：$x^{5^6}$。</p>
<h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><h3 id="小括号与方括号"><a href="#小括号与方括号" class="headerlink" title="小括号与方括号"></a>小括号与方括号</h3><ul>
<li>使用英文半角<code>( )</code>和<code>[ ]</code>即可。例如如<code>$(2+3)[4+4]$</code>输出为：$(2+3)[4+4]$</li>
<li>使用<code>\left(</code>或<code>\right)</code>使符号大小与邻近的公式相适应（该语句适用于所有括号类型），如<code>$\left(\frac&#123;x&#125;&#123;y&#125;\right)$</code>输出为：$\left[\frac{x}{y}\right]$</li>
</ul>
<h3 id="大括号"><a href="#大括号" class="headerlink" title="大括号"></a>大括号</h3><ul>
<li>由于大括号<code>&#123; &#125;</code>被用于分组，因此需要使用<code>\&#123;</code>和<code>\&#125;</code>表示大括号，也可以使用<code>\lbrace</code>和<code>\rbrace</code>来表示。如<code>$\&#123;a+b\&#125;:a-b$</code>或<code>$\lbrace a+b\rbrace:a-b$</code> 输出为：${a+b}:{a-b}$</li>
</ul>
<h3 id="尖括号"><a href="#尖括号" class="headerlink" title="尖括号"></a>尖括号</h3><ul>
<li>区分于小于号和大于号，使用<code>\langle</code>和<code>\rangle</code>表示左尖括号和右尖括号。如<code>$\langle x \rangle$</code>输出为：$\langle x \rangle$</li>
</ul>
<h3 id="上取整"><a href="#上取整" class="headerlink" title="上取整"></a>上取整</h3><ul>
<li>使用<code>\lceil</code>和<code>\rceil</code>表示上取整符号。如<code>$\lceil x \rceil$</code>输出为： $\lceil x \rceil$</li>
</ul>
<h3 id="下取整"><a href="#下取整" class="headerlink" title="下取整"></a>下取整</h3><ul>
<li>使用<code>\lfloor</code>和<code>\rfloor</code>表示下取整符号。如<code>$\lfloor x \rfloor$</code>输出为：$\lfloor x \rfloor$</li>
</ul>
<h2 id="求和与积分"><a href="#求和与积分" class="headerlink" title="求和与积分"></a>求和与积分</h2><h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><ul>
<li><code>\sum</code>用来表示求和符号，其下标表示求和下限，上标表示上限。如:<code>$\sum_&#123;r=1&#125;^n$</code>输出为：$\sum_{r=1}^n$</li>
<li><code>$$\sum_&#123;r=1&#125;^n$$</code>行间公式输出为：<br>$$\sum_{r=1}^n$$</li>
</ul>
<h3 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h3><ul>
<li><code>\int</code>用来表示积分符号，同样地，其上下标表示积分的上下限。如<code>$\int_&#123;r=1&#125;^\infty$</code>输出为：$\int_{r=1}^\infty$</li>
<li>多重积分同样使用<code>int</code>，通过<code>i</code>的数量表示积分导数。例如：</li>
</ul>
<p><code>$\iint$</code>输出为：$\iint$</p>
<p><code>$\iiint$</code>输出为：$\iiint$</p>
<h3 id="连乘"><a href="#连乘" class="headerlink" title="连乘"></a>连乘</h3><ul>
<li><code>$\prod &#123;a+b&#125;$</code>输出为：$\prod {a+b}$</li>
<li><code>$\prod_&#123;i=1&#125;^&#123;K&#125;$</code>输出为：$\prod_{i=1}^{K}$</li>
<li><code>$\prod_&#123;i=1&#125;^&#123;K&#125;$</code>输出为：$$\prod_{i=1}^{K}$$</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>与此类似的符号还有，</p>
<ul>
<li><code>$\prod$</code>输出为：$\prod$</li>
<li><code>$\bigcup$</code>输出为：$\bigcup$</li>
<li><code>$\bigcap$</code>输出为：$\bigcap$</li>
<li><code>$arg\,\max_&#123;c_k&#125;$</code>输出为：$arg,\max_{c_k}$</li>
<li><code>$arg\,\min_&#123;c_k&#125;$</code>输出为：$arg,\min_{c_k}$</li>
<li><code>$\mathop &#123;argmin&#125;_&#123;c_k&#125;$</code>输出为：$\mathop {argmin}_{c_k}$</li>
<li><code>$\mathop &#123;argmax&#125;_&#123;c_k&#125;$</code>输出为：$\mathop {argmax}_{c_k}$`</li>
<li><code>$\max_&#123;c_k&#125;$</code>输出为：$\max_{c_k}$</li>
<li><code>$\min_&#123;c_k&#125;$</code>输出为：$\min_{c_k}$</li>
</ul>
<h2 id="分式与根式"><a href="#分式与根式" class="headerlink" title="分式与根式"></a>分式与根式</h2><h3 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h3><ul>
<li>使用<code>\frac ab</code>，<code>\frac</code>作用于其后的两个组<code>a</code>、<code>b</code> ，结果为。如果分子或分母不是单个字符，请使用<code>&#123; &#125;</code>来分组，比如<code>$\frac &#123;a+c+1&#125;&#123;b+c+2&#125;$</code>输出为：$\frac {a+c+1}{b+c+2}$</li>
<li>使用<code>\over</code>来分隔一个组的前后两部分，如<code>&#123;a+1\over b+1&#125;</code>输出为：${a+1\over b+1}$</li>
</ul>
<h3 id="连分数"><a href="#连分数" class="headerlink" title="连分数"></a>连分数</h3><ul>
<li>书写连分数表达式时，使用<code>\cfrac</code>代替<code>\frac</code>或者<code>\over</code>两者效果对比如下：</li>
</ul>
<p>使用<code>\frac</code>：</p>
<p><code>$$x=a_0 + \frac &#123;1^2&#125;&#123;a_1 + \frac &#123;2^2&#125;&#123;a_2 + \frac &#123;3^2&#125;&#123;a_3 + \frac &#123;4^2&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125;$$</code><br>输出为：<br>$$x=a_0 + \frac {1^2}{a_1 + \frac {2^2}{a_2 + \frac {3^2}{a_3 + \frac {4^2}{a_4 + …}}}}$$</p>
<p>使用<code>\cfrac</code>：</p>
<p><code>$$x=a_0 + \cfrac &#123;1^2&#125;&#123;a_1 + \cfrac &#123;2^2&#125;&#123;a_2 + \cfrac &#123;3^2&#125;&#123;a_3 + \cfrac &#123;4^2&#125;&#123;a_4 + ...&#125;&#125;&#125;&#125;$$</code><br>输出为：<br>$$x=a_0 + \cfrac {1^2}{a_1 + \cfrac {2^2}{a_2 + \cfrac {3^2}{a_3 + \cfrac {4^2}{a_4 + …}}}}$$</p>
<h3 id="根式"><a href="#根式" class="headerlink" title="根式"></a>根式</h3><p>根式使用\sqrt 来表示。</p>
<ul>
<li>如开4次方：<code>$\sqrt[4]&#123;\frac xy&#125;$</code>输出为 ：$\sqrt[4]{\frac xy}$</li>
<li>开平方：<code>$\sqrt &#123;a+b&#125;$</code>输出为：$\sqrt {a+b}$</li>
</ul>
<h2 id="多行表达式"><a href="#多行表达式" class="headerlink" title="多行表达式"></a>多行表达式</h2><h3 id="分类表达式"><a href="#分类表达式" class="headerlink" title="分类表达式"></a>分类表达式</h3><ul>
<li>定义函数的时候经常需要分情况给出表达式，使用<code>\begin&#123;cases&#125;…\end&#123;cases&#125;</code> 。其中：<ul>
<li>使用<code>\\</code>来分类</li>
<li>使用<code>&amp;</code>指示需要对齐的位置</li>
<li>使用<code>\</code>+<code>空格</code>表示空格<br>例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">f(n)</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">\cfrac n2, &amp;if\ n\ is\ even\\</span><br><span class="line">3n + 1, &amp;if\  n\ is\ odd</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
输出为：<br>$$<br>f(n)<br>\begin{cases}<br>\cfrac n2, &amp;if\ n\ is\ even\<br>3n + 1, &amp;if\  n\ is\ odd<br>\end{cases}<br>$$</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">L(Y,f(X)) &#x3D;</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">0, &amp; \text&#123;Y &#x3D; f(X)&#125;  \\</span><br><span class="line">1, &amp; \text&#123;Y $\neq$ f(X)&#125;</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>输出为：<br>$$<br>L(Y,f(X)) =<br>\begin{cases}<br>0, &amp; \text{Y = f(X)}  \<br>1, &amp; \text{Y $\neq$ f(X)}<br>\end{cases}<br>$$</p>
<ul>
<li>如果想分类之间的垂直间隔变大，可以使用<code>\\[2ex]</code>代替<code>\\</code>来分隔不同的情况。(<code>3ex</code>、<code>4ex</code>也可以用，<code>1ex</code>相当于原始距离）。如下所示：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">L(Y,f(X)) &#x3D;</span><br><span class="line">\begin&#123;cases&#125;</span><br><span class="line">0, &amp; \text&#123;Y &#x3D; f(X)&#125; \\[5ex]</span><br><span class="line">1, &amp; \text&#123;Y $\neq$ f(X)&#125;</span><br><span class="line">\end&#123;cases&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
输出为：<br>$$<br>L(Y,f(X)) =<br>\begin{cases}<br>0, &amp; \text{Y = f(X)} \[5ex]<br>1, &amp; \text{Y $\neq$ f(X)}<br>\end{cases}<br>$$</li>
</ul>
<h3 id="多行表达式-1"><a href="#多行表达式-1" class="headerlink" title="多行表达式"></a>多行表达式</h3><p>有时候需要将一行公式分多行进行显示，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\begin&#123;equation&#125;\begin&#123;split&#125; </span><br><span class="line">a&amp;&#x3D;b+c-d \\ </span><br><span class="line">&amp;\quad +e-f\\ </span><br><span class="line">&amp;&#x3D;g+h\\ </span><br><span class="line">&amp; &#x3D;i </span><br><span class="line">\end&#123;split&#125;\end&#123;equation&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>输出为：<br>$$<br>\begin{equation}\begin{split}<br>a&amp;=b+c-d \<br>&amp;\quad +e-f\<br>&amp;=g+h\<br>&amp; =i<br>\end{split}\end{equation}<br>$$<br>其中<code>begin&#123;equation&#125;</code>表示开始方程，<code>end&#123;equation&#125;</code>表示方程结束；<code>begin&#123;split&#125;</code>表示开始多行公式，<code>end&#123;split&#125;</code>表示结束；公式中用<code>\\</code>表示回车到下一行，<code>&amp;</code>表示对齐的位置。</p>
<h3 id="方程组"><a href="#方程组" class="headerlink" title="方程组"></a>方程组</h3><p>使用<code>\begin&#123;array&#125;...\end&#123;array&#125;</code>与<code>\lef \&#123;</code>与<code>\right</code>。配合表示方程组，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\left \&#123; </span><br><span class="line">\begin&#123;array&#125;&#123;c&#125;</span><br><span class="line">a_1x+b_1y+c_1z&#x3D;d_1 \\ </span><br><span class="line">a_2x+b_2y+c_2z&#x3D;d_2 \\ </span><br><span class="line">a_3x+b_3y+c_3z&#x3D;d_3</span><br><span class="line">\end&#123;array&#125;</span><br><span class="line">\right.</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>输出为：<br>$$<br>\left {<br>\begin{array}{c}<br>a_1x+b_1y+c_1z=d_1 \<br>a_2x+b_2y+c_2z=d_2 \<br>a_3x+b_3y+c_3z=d_3<br>\end{array}<br>\right.<br>$$<br>注意：通常<code>MathJax</code>通过内部策略自己管理公式内部的空间，因此<code>a…b</code>与<code>a…….b</code>（<code>.</code>表示空格）都会显示为<code>ab</code> 。可以通过在<code>ab</code>间加入<code>\</code>，增加些许间隙，<code>\;</code>增加较宽的间隙，<code>\quad</code>与<code>\qquad</code>会增加更大的间隙。</p>
<h2 id="特殊函数与符号"><a href="#特殊函数与符号" class="headerlink" title="特殊函数与符号"></a>特殊函数与符号</h2><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><ul>
<li><code>$\sin x$</code>输出为：$\sin x$</li>
<li><code>$\arctanx$</code>输出为：$\arctan x$</li>
</ul>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul>
<li>小于<code>$\lt$</code>：$\lt$</li>
<li>大<code>$\gt$</code>：$\gt$</li>
<li>小于等于<code>$\le$</code>：$\le$</li>
<li>大于等于<code>$\ge$</code>：$\ge$</li>
<li>不等于<code>$\ne$</code>：$\ne$</li>
<li>可以在这些运算符前面加上<code>\not</code>，如<code>$\not\lt$</code>：输出为$\not\lt$</li>
</ul>
<h3 id="集合关系与运算"><a href="#集合关系与运算" class="headerlink" title="集合关系与运算"></a>集合关系与运算</h3><ul>
<li>并集<code>$\cup$</code>：$\cup$</li>
<li>交集<code>$\cap$</code>：$\cap$</li>
<li>差集<code>$\setminus$</code>：$\setminus$</li>
<li>子集<code>$\subset$</code>：$\subset$</li>
<li>子集<code>$\subseteq$</code>：$\subseteq$</li>
<li>非子集<code>$\subsetneq$</code>：$\subsetneq$</li>
<li>父集<code>$\supset$</code>：$\supset$</li>
<li>属于<code>$\in$</code>：$\in$</li>
<li>不属于<code>$\notin$</code>：$\notin$</li>
<li>空集<code>$\emptyset$</code>：$\emptyset$</li>
<li>空<code>$\varnothing$</code>：$\varnothing$</li>
</ul>
<h3 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h3><ul>
<li><code>$\binom&#123;n+1&#125;&#123;2k&#125;$</code>：$\binom{n+1}{2k}$</li>
<li><code>$&#123;n+1 \choose 2k&#125;$</code>：${n+1 \choose 2k}$</li>
</ul>
<p>博客内图片宽度830px<br><a href="https://www.jianshu.com/p/25f0139637b7">https://www.jianshu.com/p/25f0139637b7</a></p>
]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github Blog</tag>
        <tag>Mathjax</tag>
        <tag>KaTeX</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Profile 相关配置</title>
    <url>/2021/03/23/Github/Github%20Profile%20%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>　　在Github中，有一个比较特殊的仓库，这个仓库的名字和你主页上显示的名字相同，这个仓库的README.md内容就会显示在你的主页顶部。这样，就可以作为一个简单的个人介绍页面，向访问你主页的人展示一些信息。这篇文章对Github Profile立面一些炫酷的效果进行详细的说明。</p>
<h4 id="1-GitHub-Streak-Stats"><a href="#1-GitHub-Streak-Stats" class="headerlink" title="1 GitHub Streak Stats"></a>1 GitHub Streak Stats</h4><blockquote>
<p><a href="https://github.com/DenverCoder1/github-readme-streak-stats">Streak Stats</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/DenverCoder1/github-readme-streak-stats/blob/main/docs/themes/README.md">Streak Stats theme</a></p>
</blockquote>
<p>　　这个图片会动态的显示你Github总的贡献数量和最近一次最长的连续贡献数。主要参数是设置用户名和主题外观。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github-readme-streak-stats.herokuapp.com&#x2F;?user&#x3D;Arthur-Delacroix&amp;theme&#x3D;vue&amp;hide_border&#x3D;true</span><br></pre></td></tr></table></figure>

<p><img src="https://github-readme-streak-stats.herokuapp.com/?user=Arthur-Delacroix&theme=vue&hide_border=true" alt="GitHub Streak"></p>
<h4 id="2-Stats-Card"><a href="#2-Stats-Card" class="headerlink" title="2 Stats Card"></a>2 Stats Card</h4><blockquote>
<p><a href="https://github.com/anuraghazra/github-readme-stats">Stats Card</a></p>
</blockquote>
<p>　　这个动态图片分为2种，一种是显示总的Star数量、总提交数等。另一种是显示当前所有仓库用到的语言种类以及其占比。其他的还有指定仓库的状态卡片、周动态统计等卡片。其中除了一般的主题颜色、边框粗细等参数，在Stats Card中还可以隐藏具体的某一项，例如可以隐藏当前Star数量。具体的参数以及其作用，可以查看Stats Card Github主页。<br>　　Stats Card示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github-readme-stats.anuraghazra1.vercel.app&#x2F;api?username&#x3D;Arthur-Delacroix&amp;theme&#x3D;vue&amp;hide_border&#x3D;true&amp;hide_title&#x3D;true&amp;count_private&#x3D;true</span><br></pre></td></tr></table></figure>

<p><img src="https://github-readme-stats.anuraghazra1.vercel.app/api?username=Arthur-Delacroix&theme=vue&hide_border=true&hide_title=true&count_private=true"></p>
<p>　　Top Languages Card示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github-readme-stats.vercel.app&#x2F;api&#x2F;top-langs&#x2F;?username&#x3D;Arthur-Delacroix&amp;layout&#x3D;compact&amp;theme&#x3D;vue&amp;card_width&#x3D;445&amp;hide_border&#x3D;true</span><br></pre></td></tr></table></figure>

<p><img src="https://github-readme-stats.vercel.app/api/top-langs/?username=Arthur-Delacroix&layout=compact&theme=vue&card_width=445&hide_border=true"></p>
<h4 id="Trophy"><a href="#Trophy" class="headerlink" title="Trophy"></a>Trophy</h4><blockquote>
<p><a href="https://github.com/ryo-ma/github-profile-trophy">Trophy</a></p>
</blockquote>
<p>　　Trophy是一个生成奖杯图片的工具，它会根据你的各项数值进行SSS到C的评级，具体评级标准可以在其Github主页上查看。以下是Trophy的实例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github-profile-trophy.vercel.app&#x2F;?username&#x3D;Arthur-Delacroix&amp;theme&#x3D;flat&amp;column&#x3D;3&amp;margin-h&#x3D;15&amp;margin-w&#x3D;15&amp;&amp;no-bg&#x3D;true&amp;no-frame&#x3D;true</span><br></pre></td></tr></table></figure>

<p><img src="https://github-profile-trophy.vercel.app/?username=Arthur-Delacroix&theme=flat&column=3&margin-h=15&margin-w=15&&no-bg=true&no-frame=true"></p>
]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github Blog</tag>
        <tag>Profile</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Unity3D .gitignore 配置</title>
    <url>/2021/03/30/Github/Github%20Unity3D%20.gitignore%20%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>　　在创建Unity3D后，VS和Unity会生成很多不需要同步的文件和文件夹，包括在Windows与Mac系统中，有时候也会自动生成一些多余的文件和文件夹。就要使用.gitignore文件中的规则来过滤这些不必要的文件和文件夹，经过整理和修改，这里给出一个较为完善的.gitignore配置文件，具体内容如下，在每次创建新的仓库时，可以使用这个.gitignore规则进行过滤。在Mac系统中，以英文句号开头的文件为隐藏文件，如果要显示隐藏文件，可以按下快捷键<code>Command + Shift + .</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Unity3D generated file and folders</span><br><span class="line">[Ll]ibrary&#x2F;</span><br><span class="line">[Tt]emp&#x2F;</span><br><span class="line">[Oo]bj&#x2F;</span><br><span class="line">[Bb]uild&#x2F;</span><br><span class="line">[Bb]uilds&#x2F;</span><br><span class="line">[Ll]ogs&#x2F;</span><br><span class="line">[Uu]serSettings&#x2F;</span><br><span class="line">[Mm]emoryCaptures&#x2F;</span><br><span class="line">&#x2F;ignore.conf</span><br><span class="line">*.private</span><br><span class="line">*.private.meta</span><br><span class="line">^*.private.[0-9]+$</span><br><span class="line">^*.private.[0-9]+.meta$</span><br><span class="line">.collabignore</span><br><span class="line">**&#x2F;Assets&#x2F;AddressableAssetsData&#x2F;*&#x2F;*.bin*</span><br><span class="line">**&#x2F;assets&#x2F;addressableassetsdata&#x2F;*&#x2F;*.bin*</span><br><span class="line">**&#x2F;Assets&#x2F;StreamingAssets&#x2F;aa.meta</span><br><span class="line">**&#x2F;assets&#x2F;streamingassets&#x2F;*&#x2F;aa&#x2F;*</span><br><span class="line"></span><br><span class="line"># Unity3D generated PlasticSCM flies</span><br><span class="line">&#x2F;Assets&#x2F;Plugins&#x2F;PlasticSCM*</span><br><span class="line">&#x2F;assets&#x2F;plugins&#x2F;PlasticSCM*</span><br><span class="line"></span><br><span class="line"># Asset store tools plugin</span><br><span class="line">[Aa]ssets&#x2F;AssetStoreTools*</span><br><span class="line">**&#x2F;assets&#x2F;assetstoretools</span><br><span class="line"></span><br><span class="line"># Visual Studio cache directory</span><br><span class="line">.vs&#x2F;</span><br><span class="line"></span><br><span class="line"># Gradle cache directory</span><br><span class="line">.gradle&#x2F;</span><br><span class="line"></span><br><span class="line"># Autogenerated VS&#x2F;MD&#x2F;Consulo solution and project files</span><br><span class="line">ExportedObj&#x2F;</span><br><span class="line">.consulo&#x2F;</span><br><span class="line">*.csproj</span><br><span class="line">*.unityproj</span><br><span class="line">*.sln</span><br><span class="line">*.suo</span><br><span class="line">*.tmp</span><br><span class="line">*.user</span><br><span class="line">*.userprefs</span><br><span class="line">*.pidb</span><br><span class="line">*.booproj</span><br><span class="line">*.svd</span><br><span class="line">*.pdb</span><br><span class="line">*.mdb</span><br><span class="line">*.opendb</span><br><span class="line">*.VC.db</span><br><span class="line"></span><br><span class="line"># Unity3D generated meta files</span><br><span class="line">*.pidb.meta</span><br><span class="line">*.pdb.meta</span><br><span class="line">*.mdb.meta</span><br><span class="line"></span><br><span class="line"># Unity3D generated file on crash reports</span><br><span class="line">sysinfo.txt</span><br><span class="line"></span><br><span class="line"># Builds</span><br><span class="line">*.apk</span><br><span class="line">*.unitypackage</span><br><span class="line"></span><br><span class="line"># Crashlytics generated file</span><br><span class="line">crashlytics-build.properties</span><br><span class="line"></span><br><span class="line"># Mac files</span><br><span class="line">.DS_Store*</span><br><span class="line"></span><br><span class="line"># Windows files</span><br><span class="line">Thumbs.db</span><br><span class="line">Desktop.ini</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Unity3D</tag>
      </tags>
  </entry>
  <entry>
    <title>Github badge</title>
    <url>/2021/03/19/Github/Github%20badge/</url>
    <content><![CDATA[<p>　　在Github中仓库中，有很多大神的README.md看上去十分炫酷，在标题下方会有很多各种颜色的小图标，这些图标显示了这个仓库的一些基本信息，比如被Fork的次数、Pull requests的次数、使用的开原协议等。这些小图标在Github中被称为Shields。一开始我也只是简单的查看这些大神的README.md中的源代码，来照着在自己的仓库中添加一些类似的Shields。不过有很多参数并没有搞清楚，在这“Github Shields 相关设置”这个系列文章中，集中整理一下，给自己做个备忘。</p>
<blockquote>
<p><a href="https://github.com/badges/shields">Github Shields 仓库连接</a></p>
</blockquote>
<blockquote>
<p><a href="https://shields.io/">制作badge页面</a></p>
</blockquote>
<p>　　首先是比较简单的，打开这个网页之后，在顶部直接输入自己仓库名字完整的URL，这样会帮你自动生成若干个badge。这些badge是根据你的仓库动态生成的。当然，你也可以自己自定义想要生成的内容。接下来我们慢慢研究badge中一些简单的参数。</p>
<h3 id="1-自定义静态内容"><a href="#1-自定义静态内容" class="headerlink" title="1. 自定义静态内容"></a>1. 自定义静态内容</h3><p>　　自定义静态内容的badge由4部分组成：默认连接 + Label + Message + Color。</p>
<ul>
<li>默认连接为 <code>https://img.shields.io/badge/</code></li>
<li>Label为badge左侧的文字内容。</li>
<li>Message为badge左侧的文字内容。</li>
<li>Color为badge右侧文字的底色。</li>
</ul>
<p>　　其中Label、Message、Color三个参数的顺序不可改变，三个参数之间使用英文“-”相连接。以下为一个自定义静态内容的badge示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;Lrft-Right-orange</span><br></pre></td></tr></table></figure>
<p> <img src="https://img.shields.io/badge/Lrft-Right-orange"></p>
<p>　　这里要注意输入的一些特殊字符的问题，列表如下：</p>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>输入内容</th>
<th>显示内容</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>破折号“–”</td>
<td>–</td>
<td>-</td>
<td><img src="https://img.shields.io/badge/Lr--ft-Right-orange"></td>
</tr>
<tr>
<td>英文半角空格</td>
<td>%20或“_”</td>
<td>一个半角空格</td>
<td><img src="https://img.shields.io/badge/Lr%20ft-Rig_ht-orange"></td>
</tr>
<tr>
<td>下划线“_”</td>
<td>__(两个英文半角下划线)</td>
<td>_</td>
<td><img src="https://img.shields.io/badge/Lr__ft-Right-orange"></td>
</tr>
</tbody></table>
<hr>
<h3 id="2-文字背景色"><a href="#2-文字背景色" class="headerlink" title="2 文字背景色"></a>2 文字背景色</h3><p>　　你也可以自定义左右两边的颜色值，这里使用的是RGB16位色值。示例代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;Left-Right-green.svg?colorA&#x3D;ff00ff&amp;colorB&#x3D;daa357</span><br></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/badge/Left-Right-green.svg?colorA=ff00ff&colorB=daa357"></p>
<p>　　这里的<code>colorA=ff00ff</code>表示左半边的背景色值，<code>colorB=daa357</code>表示右半边背景色值。参数之间使用英文<code>&amp;</code>符号连接。<br>　　除了使用16位RGB值改变背景色之外，还可以使用Shields一些自带的默认样式，列表如下，其实还有很多其他颜色名称，这里就不一一列举了，都可以使用RGB来代替。</p>
<table>
<thead>
<tr>
<th>颜色名称</th>
<th>示例</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>brightgreen</td>
<td><img src="https://img.shields.io/badge/left-right-brightgreen"></td>
<td><code>https://img.shields.io/badge/left-right-brightgreen</code></td>
</tr>
<tr>
<td>green</td>
<td><img src="https://img.shields.io/badge/left-right-green"></td>
<td><code>ttps://img.shields.io/badge/left-right-green</code></td>
</tr>
<tr>
<td>yellowgreen</td>
<td><img src="https://img.shields.io/badge/left-right-yellowgreen"></td>
<td><code>https://img.shields.io/badge/left-right-yellowgreen</code></td>
</tr>
<tr>
<td>yellow</td>
<td><img src="https://img.shields.io/badge/left-right-yellow"></td>
<td><code>https://img.shields.io/badge/left-right-yellow</code></td>
</tr>
<tr>
<td>orange</td>
<td><img src="https://img.shields.io/badge/left-right-orange"></td>
<td><code>ttps://img.shields.io/badge/left-right-orange</code></td>
</tr>
<tr>
<td>red</td>
<td><img src="https://img.shields.io/badge/left-right-red"></td>
<td><code>https://img.shields.io/badge/left-right-red</code></td>
</tr>
<tr>
<td>lightgrey</td>
<td><img src="https://img.shields.io/badge/left-right-lightgrey"></td>
<td><code>ttps://img.shields.io/badge/left-right-lightgrey</code></td>
</tr>
<tr>
<td>blue</td>
<td><img src="https://img.shields.io/badge/left-right-blue"></td>
<td><code>https://img.shields.io/badge/left-right-blue</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="3-自定义样式"><a href="#3-自定义样式" class="headerlink" title="3 自定义样式"></a>3 自定义样式</h3><p>　　Shields还提供了很多外观样式，具体代码和样式如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>示例</th>
<th>代码</th>
</tr>
</thead>
<tbody><tr>
<td>plastic</td>
<td><img src="https://img.shields.io/badge/Left-Right-green.svg?style=plastic"></td>
<td><code>https://img.shields.io/badge/Left-Right-green.svg?style=plastic</code></td>
</tr>
<tr>
<td>flat</td>
<td><img src="https://img.shields.io/badge/Left-Right-green.svg?style=flat"></td>
<td><code>https://img.shields.io/badge/Left-Right-green.svg?style=flat</code></td>
</tr>
<tr>
<td>flat-square</td>
<td><img src="https://img.shields.io/badge/Left-Right-green.svg?style=flat-square"></td>
<td><code>https://img.shields.io/badge/Left-Right-green.svg?style=flat-square</code></td>
</tr>
<tr>
<td>for-the-badge</td>
<td><img src="https://img.shields.io/badge/Left-Right-green.svg?style=for-the-badge"></td>
<td><code>https://img.shields.io/badge/Left-Right-green.svg?style=for-the-badge</code></td>
</tr>
<tr>
<td>social</td>
<td><img src="https://img.shields.io/badge/Left-Right-green.svg?style=social"></td>
<td><code>https://img.shields.io/badge/Left-Right-green.svg?style=social</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="4-小图标"><a href="#4-小图标" class="headerlink" title="4 小图标"></a>4 小图标</h3><blockquote>
<p><a href="https://simpleicons.org/">小图标参考页面</a>　　</p>
</blockquote>
<p>　　在badge的左侧，还可以加入一些小图标，示例代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;Left-Right-green.svg?logo&#x3D;unity</span><br></pre></td></tr></table></figure>

<p><img src="https://img.shields.io/badge/Left-Right-green.svg?logo=Unity"> </p>
<p>　　这里还需要注意一点，有些Logo的名字是带空格的，比如Adobe Lightroom Classic，要显示这个Logo，不能直接使用英文半角空格，而是要使用<code>%20</code>作为转译符号。示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;Left-Right-green.svg?logo&#x3D;Adobe%20Lightroom%20Classic</span><br></pre></td></tr></table></figure>

<p><img src="https://img.shields.io/badge/Left-Right-green.svg?logo=Adobe%20Lightroom%20Classic"></p>
<p>　　或者还可以使用半角英文减号“-”代替空格，也是一样的效果，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;Left-Right-green.svg?logo&#x3D;visual-studio-code</span><br></pre></td></tr></table></figure>

<p><img src="https://img.shields.io/badge/Left-Right-green.svg?logo=visual-studio-code"></p>
<p>　　如果对Logo的颜色不满意，还可以更改Logo的颜色，颜色值使用16位RGB颜色。示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;Left-Right-green.svg?logo&#x3D;unreal-engine&amp;logoColor&#x3D;violet</span><br></pre></td></tr></table></figure>

<p><img src="https://img.shields.io/badge/Left-Right-green.svg?logo=unreal-engine&logoColor=violet"></p>
<p>　　感觉Logo跟文字部分过于紧凑，还可以调整水平位置Logo所占宽度。不过这个宽度增加之后，Logo只会出现在剧中位置。示例代码如下：
　　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;Left-Right-green.svg?logo&#x3D;bilibili&amp;logoWidth&#x3D;40</span><br></pre></td></tr></table></figure>

<p><img src="https://img.shields.io/badge/Left-Right-green.svg?logo=bilibili&logoWidth=40"></p>
<hr>
<h3 id="5-加入emoji"><a href="#5-加入emoji" class="headerlink" title="5 加入emoji"></a>5 加入emoji</h3><blockquote>
<p><a href="https://apps.timwhitlock.info/emoji/tables/unicode#">emoji UTF‑8查询 1</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/sanderhahn/emoticons/blob/master/emoticons.md">emoji UTF‑8查询 2</a></p>
</blockquote>
<p>　　emoji同样可以嵌入到徽章内，不过是以UTF‑8编码格式书写的。每2组数值之前，要加英文百分号<code>%</code>，代码示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;Left_emoji%20%F0%9F%98%9C-%E2%9C%A8%20Right_emoji-brightgreen.svg</span><br></pre></td></tr></table></figure>

<p><img src="https://img.shields.io/badge/Left_emoji%20%F0%9F%98%9C-%E2%9C%A8%20Right_emoji-brightgreen.svg"></p>
<p>　　当然，也可以直接在网页上复制emoji，不过那样感觉就会很奇怪，在一堆代码里面出现了一个emoji的表情，感觉好像很不符合程序员的风格。</p>
<hr>
<h3 id="6-超级缝合怪！"><a href="#6-超级缝合怪！" class="headerlink" title="6 超级缝合怪！"></a>6 超级缝合怪！</h3><p>　　一个badge有多个参数，这些参数之间使用<code>&amp;</code>符号进行连接，没有先后顺序。所以依照这个特性，我们可以创建一个内容丰富、结构复杂的badge！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;Left%E2%AD%90-Right%F0%9F%92%9D-brightgreen.svg?style&#x3D;for-the-badge&amp;colorA&#x3D;ff00ff&amp;colorB&#x3D;daa357&amp;logo&#x3D;Blender&amp;logoWidth&#x3D;20&amp;logoColor&#x3D;black</span><br></pre></td></tr></table></figure>
<p><img src="https://img.shields.io/badge/Left%E2%AD%90-Right%F0%9F%92%9D-brightgreen.svg?style=for-the-badge&colorA=ff00ff&colorB=daa357&logo=Blender&logoWidth=20&logoColor=black"></p>
]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github Blog</tag>
        <tag>badge</tag>
      </tags>
  </entry>
  <entry>
    <title>0-0 关于Hex Map系列文章</title>
    <url>/2020/09/25/HexMap/0-0%20%E5%85%B3%E4%BA%8EHex%20Map%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>　　偶然间在Unity论坛上发现了Jasper Flick大神的文章，顺藤摸瓜，发现Jasper Flick大神还有一个网站，专门写各种各样的教程和技术文章，每一篇都非常有价值。在征得大神同意后，决定挖个深坑，把六边形地图系统的文章翻译出来，同时可以精进自己的技术和英语水平。</p>
<p>　　虽然网上已经有很多人翻译了Hex Map这个系列教程，但是翻译的内容感觉并不走心，基本和机翻差不多，许多重点的地方并没有讲清楚，关键的地方也是一带而过。代码也是截图贴上去，没有任何注释。我在做这次翻译的时候，会尽力将所有代码进行比较详细的注释，对一些自己有疑问的点进行更加深入的说明，并尽量附上相关资料链接。希望能和看到这篇译文的人共同探讨、共同进步。</p>
<p>　　Hex Map教程译文，只会发布在我的Github Pages的个人博客上，任何转载都是没有经过我和Jasper Flick大神授权的，请大家悉知。</p>
<p>　　以下是大神授权我翻译Hex Map系列教程文章的对话，出自Unity论坛：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/Jasper%20Flick.check.jpg" alt="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/Jasper%20Flick.check.jpg"></p>
<hr>
<p>　　以下是一些相关的链接：</p>
<ul>
<li><p><a href="https://catlikecoding.com/">Jasper Flick大神的网站</a></p>
</li>
<li><p><a href="https://catlikecoding.com/unity/tutorials/hex-map/">Hex Map英文系列教程</a></p>
</li>
<li><p><a href="https://www.redblobgames.com/grids/hexagons/">相关文章</a> </p>
</li>
</ul>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>1-1 关于Hexmap</title>
    <url>/2020/09/26/HexMap/1-1%20%E5%85%B3%E4%BA%8EHexmap/</url>
    <content><![CDATA[<p>　　地图系统是一个回合制策略游戏的基础，一个灵活、稳固、拓展性强的地图系统会给游戏带来更多的可能。</p>
<p>　　在传统日式回合制策略RPG游戏中，大多使用了正方形元素来构建地图系统。正方形元素有绘制简单、三角面数较少、计算相对简单等优势，但是也具有一些先天性的劣势，下图为一个正方形地图单元，以及围绕其周围的8个地图单元。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-1-1.png"></p>
<p>　　通过观察发现，水平和垂直相邻的地图单元，两者中点的距离为正方形单元边长，也就是绿色箭头表示的距离。</p>
<p>　　而斜向位置的相邻地图单元，两者中点的距离为正方形单元边长的 $\sqrt 2$ 倍，也就是红色箭头表示的距离。</p>
<p>　　由于相邻的地图单元之间有两种不同的距离，这种差异化的距离在实际游戏中会比较难处理。所以，有些游戏中，只会选择在地图单元的水平和垂直方向移动，从而避免距离差异化带来的问题。但是，这样在一定程度上减少了游戏的多样性与可玩性。</p>
<p>　　为了解决距离差异化问题，并且同时保持游戏玩法的灵活与多样性，使用了正六边形地图单元来代替正方形地图单元。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-1-2.png"></p>
<p>　　与正方形单元相比，正六边形单元有6个相邻单元。并且，两个单元中点之间的距离是相等的，不存在距离之间的差异化。这样就既消除了距离差异的问题，同时还保持了游戏的多样性和可玩性。</p>
<p>　　在正式开始编码之前，还需要对正六边形单元做一些简单的设定。这里设定每个正六边形单元的边长为10。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-1-3.png"></p>
<p>　　由<a href="https://baike.baidu.com/item/%E6%AD%A3%E5%85%AD%E8%BE%B9%E5%BD%A2/810780">正六边形的几何特点</a>可知，如果正六边形的边长为10，其外接圆的半径也为10（蓝色实线线表示），其内切圆半径是边长的 $\frac {\sqrt 3} 2$（<a href="https://www.zybang.com/question/23f1ea8b73c2d03cb2c400389bc90cef.html">证明过程</a>），也就是 $5 \sqrt3$（红色虚线表示）。</p>
<p>　　基础的设定完成后，接下来就可以在Unity中创建脚本开始编码了。首先创建HexMetrics.cs脚本，声明2个常量，<code>outerRadius</code>和<code>innerRadius</code>，表示正六边形的外接圆和内切圆半径。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexMetrics</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//正六边形的边长 同时也是正六边形外接圆的半径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> outerRadius = <span class="number">10f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正六边形的内切圆半径，长度为外接圆的 二分之根号三倍</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> innerRadius = outerRadius * <span class="number">0.866025404f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　脚本创建完成后，让我们来继续观察一下正六边形单元。在正六边形排列的形式有两种，一类是边朝上，一类是角朝上。为了方便之后的计算，我们选择角朝上的排列类型。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-1-4.png"></p>
<p>　　在<code>HexMetrics</code>类中添加如下代码，通过正六边形的中点、外接圆半径、内切圆半径定义正六边形的六个顶点</p>
<figure class="highlight csharp"><figcaption><span>exMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexMetrics</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//正六边形的边长 同时也是正六边形外接圆的半径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> outerRadius = <span class="number">10f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正六边形的内切圆半径，长度为外接圆的 二分之根号三倍</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> innerRadius = outerRadius * <span class="number">0.866025404f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正六边形的六个顶点位置，其姿态为角朝上，从最上面一个顶点开始计算位置</span></span><br><span class="line">    <span class="comment">//根据正六边形中点的位置，顺时针依次定义6个顶点的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Vector3[] corners =</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> Vector3(<span class="number">0f</span>, <span class="number">0f</span>, outerRadius),</span><br><span class="line">        <span class="keyword">new</span> Vector3(innerRadius, <span class="number">0f</span>, <span class="number">0.5f</span> * outerRadius),</span><br><span class="line">        <span class="keyword">new</span> Vector3(innerRadius, <span class="number">0f</span>, <span class="number">-0.5f</span> * outerRadius),</span><br><span class="line">        <span class="keyword">new</span> Vector3(<span class="number">0f</span>, <span class="number">0f</span>, -outerRadius),</span><br><span class="line">        <span class="keyword">new</span> Vector3(-innerRadius, <span class="number">0f</span>, <span class="number">-0.5f</span> * outerRadius),</span><br><span class="line">        <span class="keyword">new</span> Vector3(-innerRadius, <span class="number">0f</span>, <span class="number">0.5f</span> * outerRadius)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这样，基本的地图单元就创建完成了，下一步，要创建一个二维数组，来存放实例化到场景中的地图单元，并且记录每个地图单元在该数组中的位置。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/4ca99fba905d26cc215b4b68bbb2ded305e4eb2b">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>1-10 简单的地图编辑器</title>
    <url>/2020/10/05/HexMap/1-10%20%E7%AE%80%E5%8D%95%E7%9A%84%E5%9C%B0%E5%9B%BE%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<p>　　在上一章中，我们实现了为被点击的地图单元添加指定的颜色。现在我们将这个功能拓展一下，制作一个简单的地图编辑器。在HexGrid.cs脚本中找到<code>TouchCell</code>方法，这个方法主要用来判断鼠标的点击位置并改变被点击地图单元的颜色。这里我们要对<code>TouchCell</code>方法进行一些修改，添加一个参数，使其可以接受任何颜色的信息，并将其访问修饰符改为public。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ColorCell</span>(<span class="params">Vector3 _position, Color _color</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _position = transform.InverseTransformPoint(_position);</span><br><span class="line">    HexCoordinates _coordinates = HexCoordinates.FromPosition(_position);</span><br><span class="line">    <span class="keyword">int</span> _index = _coordinates.X + _coordinates.Z * width + _coordinates.Z / <span class="number">2</span>;</span><br><span class="line">    HexCell _cell = cells[_index];</span><br><span class="line">    _cell.color = _color;</span><br><span class="line">    hexMesh.Triangulate(cells);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　接下来，创建HexMapEditor脚本，将HexGrid.cs脚本Update方法中的内容和HandleInput方法移动到这里。然后创建一个存储颜色的数组用来保存多个备选颜色，创建一个私有的颜色变量用来保存已选中的颜色值。最后添加一个公共方法来选择颜色。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//备选颜色数组</span></span><br><span class="line">    <span class="keyword">public</span> Color[] colors;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//HexGrid实例，用来调用其中的ColorCell方法</span></span><br><span class="line">    <span class="keyword">public</span> HexGrid hexGrid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已选中的颜色</span></span><br><span class="line">    <span class="keyword">private</span> Color activeColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里使用指定的camera代替 Camera.main方式，避免遍历场景中的Object</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Camera mainCamera;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//为activeColor赋初始值</span></span><br><span class="line">        SelectColor(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            HandleInput();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 鼠标左键单击会调用此方法，以鼠标为发射点，经过主摄像机练成射线</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 检测射线穿过Collider的位置</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 此方法移动到了HexMapEditor中</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleInput</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//射线起点为鼠标位置，经过主摄像机</span></span><br><span class="line">        Ray _inputRay = mainCamera.ScreenPointToRay(Input.mousePosition);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//检测射线是否碰撞到了collider</span></span><br><span class="line">        RaycastHit _hit;</span><br><span class="line">        <span class="keyword">if</span> (Physics.Raycast(_inputRay, <span class="keyword">out</span> _hit))</span><br><span class="line">        &#123;</span><br><span class="line">            hexGrid.ColorCell(_hit.point, activeColor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 为选中颜色activeColor 赋值</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;_index&quot;&gt;</span>备选颜色数组colors 中的颜色值索引<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectColor</span>(<span class="params"><span class="keyword">int</span> _index</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        activeColor = colors[_index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　新建一个canvas，重命名为<code>Hex Map Editor</code>不需要对其进行修改，保持默认即可。然后将HexMapEditor脚本挂载到canvas上，为<code>Colors</code>数组添加几个不同的颜色。最后将挂载Hex Grid.cs脚本的物体Hex Grid拖入到HexMapEditor中变量<code>Hex Grid</code>栏内。效果如下：<br>　　<br><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-10-1.png"></p>
<p>　　这里注意，在创建cancas的时候，可以调整Canvas Scaler的UI Scale Mode属性为Scale With Screen Size，这样输入屏幕的长度和宽度，就能更好的匹配UI的大小了。</p>
<p>　　在canvas下创建一个Panel，重命名为<code>Color Panel</code>，挂载Toggle Group组件，效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-10-2.png"></p>
<p>　　接着，在Color Panel下创建若干个单选按钮(Components/ UI/toggle)，其数量为HexMapEditor中<code>colors</code>数组的长度。效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-10-3.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-10-4.png"></p>
<p>　　完成以上步骤后，选中Color Panel下面的所有子物体，其中Toggle组件中有<code>Group</code>一栏，将Color Panel的Toggle Group组件拖入其中。这样，就能把这些Toggle组件关联到一起了，当一个被打开的时候，另外的Toggle组件会自动关闭。效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-10-5.png"></p>
<p>　　关于Toggle组件中事件调用的时机问题：</p>
<p>　　当我们每次选中或取消选中一个Toggle按钮时，Toggle组件中挂载的事件都会被调用。也就是说，当我们在Toggle按钮组中切换颜色的时候，<code>SelectColor()</code>方法会被调用两次。不过不用担心，因为每次Toggle组件被选中的事件调用总在最后，所以结果一定是正确的。或者我们可以通过判断当前组件是否被选中（<code>Toggle组件Is On</code>属性），来决定是否执行<code>SelectColor()</code>方法。</p>
<p>　　在每个Toggle组件中，有<code>On Value Changed</code>事件，将这个这件绑定到<code>HexMapEditor.SelectColor</code>方法上，并设置其参数，即Toggle组件表示的颜色与<code>HexMapEditor.Color</code>数组的颜色索引相同。效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-10-6.png"></p>
<p>　　最后，让我们将Color Panel覆盖到正六边形地图之上。这时候点击一个Toggle按钮，会发现每一次鼠标点击，不仅改变了Toggle按钮的状态，还同时改变了其后面地图单元的颜色。这说明鼠标在一次点击的时候不仅UI相应了鼠标点击，同时地图系统也响应了鼠标点击。我们可以使用事件系统来将两个事件分开处理，也就是当鼠标悬停在UI上时，六边形地图不会响应鼠标的点击事件。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.EventSystems;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//通过IsPointerOverGameObject区分点击在UI或cell上</span></span><br><span class="line">        <span class="comment">//IsPointerOverGameObject点击在UI上时候为true。其他为false</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">0</span>) &amp;&amp; !EventSystem.current.IsPointerOverGameObject())</span><br><span class="line">        &#123;</span><br><span class="line">            HandleInput();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，我们就完成了一个很简单的地图编辑器，在一组单选按钮组中选择一个颜色后，点击任意的地图单元，这个地图单元就会变成相应的颜色。虽然在改变颜色的过程中，我们是通过重新构建整个六边形地图做到的，但是目前市局效果和逻辑是正确的。<br>　　在接下来的章节中，我们会先将注意力放在视觉效果部分，首先要让地图单元之间的颜色过渡更加自然，然后添加地形的高低起伏。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/1c74505102f46c26e21321d230a123a27a3d991c">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>1-2 构建地图单元容器</title>
    <url>/2020/09/27/HexMap/1-2%20%E6%9E%84%E5%BB%BA%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>　　在1-1中，我们用代码创建了一个正六边形地图单元的基本结构，接下来，为了构建正六边形地图系统，首先需要构建一个正六边形地图单元实例。首先创建<code>HexCell</code>组件。这里不在此脚本中填写任何代码。</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来在场景中创建一个Plane，重命名为Hex Cell，挂载<code>HexCell</code>组件，并且把这个Plane创建为Prefab。如下图：</p>
<p><img src="https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/hex-cell-plane.png"></p>
<p>　　然后创建一个空物体，命名为Hex Grid，用来容纳地图单元。创建<code>HexGrid</code>脚本，并声明三个变量，分别表示在该容器中，地图单元的行数、列数和地图单元预置，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexGrid</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//表示每一行有多少个地图单元</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> width = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示每一列有多少个地图单元</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> height = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放地图单元格的预置</span></span><br><span class="line">    <span class="keyword">public</span> HexCell cellPrefab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/hex-grid.png"></p>
<p>　　地图单元的容器创建完成后，将Width和Height的值都设置为6，将之前创建好的HexCell预置拖入Hex Cell框内。</p>
<p>　　现在，需要完成创建地图单元的代码，这里使用一个嵌套的for循环来创建地图单元，Width为每一行中有多少个地图单元，Height为行数。最后，将创建好的地图单元实例，存储在一个二维数组中，便于后期的查找和修改。<code>HexGrid</code>脚本添加代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//存放实例化的地图单元</span></span><br><span class="line">HexCell[] cells;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//根据长度和宽度，初始化数组大小</span></span><br><span class="line">    cells = <span class="keyword">new</span> HexCell[height * width];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从左下角开始，依次往右，每一行为 width 个单元后，上移一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">0</span>, i = <span class="number">0</span>; z &lt; height; z++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; width; x++) </span><br><span class="line">        &#123;</span><br><span class="line">            CreateCell(x, z, i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 创建一个地图单元</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x&quot;&gt;</span>地图单元是 横行中的第几个<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;z&quot;&gt;</span>地图单元是 粽列中的第几个<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;i&quot;&gt;</span>地图单元在<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//声明一个Vector3，用来</span></span><br><span class="line">    Vector3 position;</span><br><span class="line">    position.x = x * <span class="number">10f</span>;</span><br><span class="line">    position.y = <span class="number">0f</span>;</span><br><span class="line">    position.z = z * <span class="number">10f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在数组cells的i位置实例化地图单元</span></span><br><span class="line">    <span class="comment">//cell用来给这个被实例化的单元设置父级和位置</span></span><br><span class="line">    HexCell cell;</span><br><span class="line">    cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab);</span><br><span class="line">    cell = cells[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置被实例化地图单元的父级和位置</span></span><br><span class="line">    cell.transform.SetParent(transform, <span class="literal">false</span>);</span><br><span class="line">    cell.transform.localPosition = position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这里要注意一点，在Unity中，一个默认Panel为10x10单位。所以在<code>CreateCell</code>方法中，<code>position.x = x * 10f</code>和<code>position.z = z * 10f</code>中的10f便是Panel的边长，要每次移动Panel边长的距离，让各个地图元素相邻。生成效果如下：</p>
<p><img src="https://catlikecoding.com/unity/tutorials/hex-map/part-1/grid-construction/square-grid-of-planes.png"></p>
<p>　　至此，已经成功的生成了由正方形单元组成的地图网格。但是由于每个地图单元是紧紧相邻的，在Game窗口中很难快速定位每一个地图单元的位置，如果是正六边形的地图单元，这种情况还可能更加混乱。下一步，为了方便以后的调试和更加直观的查看，我们将为每一个地图单元加上自身的坐标。</p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>1-3 创建地图单元坐标UI</title>
    <url>/2020/09/28/HexMap/1-3%20%E5%88%9B%E5%BB%BA%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E5%9D%90%E6%A0%87UI/</url>
    <content><![CDATA[<p>　　在之前的步骤中，我们已经生成了一个6x6的矩形地图网格，为了方便之后的调试与观察，这里需要显示每个地图单元在地图网格内的坐标。</p>
<p>　　在场景中创建一个Canvas，并且按照以下步骤对Canvas作出修改：</p>
<ol>
<li>将Canvas设置为“Hex Grid”的子物体</li>
<li>重命名为Hex Grid Canvas</li>
<li>删除Graphic Raycaster组件</li>
<li>将Canvas组件的Render Mode属性设置为<code>World Space</code></li>
<li>在x轴方向旋转90度</li>
<li>设置Canvas Scaler组件的Dynamic Pixels Per Unit值为10</li>
<li>删除场景中的“EventSystem”物体</li>
</ol>
<p>下图为Hex Grid Canvas设置完成后的效果：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-3-1.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-3-2.png"></p>
<p>　　对Canvas做好属性设置之后，创建一个Text子物体，具体设置步骤如下：</p>
<ol>
<li>Text重命名为Hex Cell Label</li>
<li>Width为5，Height为15</li>
<li>Text组件的Font Size值为4</li>
<li>Text组件的Alignment为水平居中、垂直居中</li>
<li>删除Text组件中默认的初始文字内容</li>
<li>将Hex Cell label创建为Prefab</li>
</ol>
<p>下图为Hex Cell label设置完成后的效果：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-3-3.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-3-4.png"></p>
<p>　　接下来，需要在创建地图单元的时候，同时创建Hex Cell Label，并且把自身的坐标位置显示出来。根据这个思路修改脚本，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexGrid</span> : <span class="title">MonoBehaviour</span> </span><br><span class="line">&#123;</span><br><span class="line">  …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存放显示地图单元坐标的Text Prefab</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Text cellLabelPrefab;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Text Prefab的父级Canvas</span></span><br><span class="line">    <span class="keyword">private</span> Canvas gridCanvas;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>	&#123;</span><br><span class="line">        <span class="comment">//获取Hex Grid子物体下d Canvas组件</span></span><br><span class="line">        gridCanvas = GetComponentInChildren&lt;Canvas&gt;();</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　添加代码完成后，将Hex Grid Canvas设置为Hex Grid的子物体，这样才能使<code>gridCanvas = GetComponentInChildren&lt;Canvas&gt;();</code>正常执行。最后将之前创建的Hex Cell Label预置拖入<code>Hex Grid</code>脚本的<code>cellLabelPrefab</code>变量中。效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-3-5.png"></p>
<p>　　创建了Hex Grid Canvas和Hex Cell Label的联系之后，接着要在创建地图单元的时候，同时实例化Hex Cell Label预置，位置与实例化的Hex Cell位置相对应，同时显示出实例化Hex Cell在数组中的位置，也就是坐标，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该变量用来存储被实例化的cellLabelPrefab预置</span></span><br><span class="line">    Text label = Instantiate&lt;Text&gt;(cellLabelPrefab);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置该label的父级，也就是canvas</span></span><br><span class="line">    label.rectTransform.SetParent(gridCanvas.transform, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置label的位置，与被实例化的cell位置相同</span></span><br><span class="line">    label.rectTransform.anchoredPosition = <span class="keyword">new</span> Vector2(position.x, position.z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置label的文字，就是cell在数组中的位置</span></span><br><span class="line">    label.text = x.ToString() + <span class="string">&quot;\n&quot;</span> + z.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　代码完成后，运行效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-3-6.png"></p>
<p>　　下一章里，我们要重新排列地图单元的位置，使其符合正六边形地图单元的排列方式。</p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>1-4 正六边形地图单元的排列方式</title>
    <url>/2020/09/29/HexMap/1-4%20%E6%AD%A3%E5%85%AD%E8%BE%B9%E5%BD%A2%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E7%9A%84%E6%8E%92%E5%88%97%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>　　上一章中，我们将每个地图单元的坐标显示了出来，这样能更加方便的在Game窗口中查看每个地图单元的坐标信息，方便之后的调试和修改。但是，现在所有的地图单元，是按照正方形地图系统的模式排列的，而整六边形地图系统中，地图单元的排列如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-4-1.png"></p>
<p>　　通过观察上图发现，水平方向上，两个正六边形地图单元的距离为2倍的内切圆半径。垂直方向上，两个正六边形地图单元的距离为1.5倍的外接圆半径。根据观察结果修改代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  …</span><br><span class="line">  <span class="comment">//两个正六边形Cell中点的水平间距</span></span><br><span class="line">    position.x = x * (HexMetrics.innerRadius * <span class="number">2f</span>);</span><br><span class="line">    position.y = <span class="number">0f</span>;</span><br><span class="line">  <span class="comment">//两个正六边形Cell中点的垂直间距</span></span><br><span class="line">    position.z = z * (HexMetrics.outerRadius * <span class="number">1.5f</span>);</span><br><span class="line">    </span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　将正方形地图单元的间距修改为正六边形地图单元的间距后，运行效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-4-2.png"></p>
<p>　　通过观察正六边形元素的排列，我们还发现，上下两行的地图元素，并不像正方形元素那样上下紧邻并对齐的，而是会错开一段距离，而且这段距离会随着行数的增加而增加。第0行偏移量为0，第1行偏移量为1倍的内切圆半径，第2行偏移量为2倍的内切圆半径。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//增加了Offset，每一行偏移量为行数*内切圆半径</span></span><br><span class="line"><span class="comment">//position.x = x * (HexMetrics.innerRadius * 2f) + z * (HexMetrics.innerRadius * 2f) * 0.5f;</span></span><br><span class="line"><span class="comment">//由上一个等式提取公因式得出：</span></span><br><span class="line">position.x = (x + z * <span class="number">0.5f</span>) * (HexMetrics.innerRadius * <span class="number">2f</span>);</span><br></pre></td></tr></table></figure>

<p>　　运行结果如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-4-3.png"></p>
<p>　　通过观察运行结果可以发现，地图形状为一个菱形，而不是矩形。为了之后调试和使用，这里要将排列方式变为矩形。可以通过去掉偶数行的偏移量来达到目的。也就是每个偶数行的地图单元，都不产生偏移，而每个奇数行的地图单元向右偏移内切圆半径的距离。修改代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//上一步中，生成的Cell会排列成菱形</span></span><br><span class="line"><span class="comment">//要排列成正方形，需要在偶数行去掉偏移量</span></span><br><span class="line"><span class="comment">//这里注意，Z/2只是取商，舍掉余数</span></span><br><span class="line"><span class="comment">//所以在偶数行正好抵消了偏移量，而在奇数行，z * 0.5f - z / 2 * (HexMetrics.innerRadius * 2f)正好是一个内切圆半径长度</span></span><br><span class="line">position.x = (x + z * <span class="number">0.5f</span> - z / <span class="number">2</span>) * (HexMetrics.innerRadius * <span class="number">2f</span>);</span><br></pre></td></tr></table></figure>

<p>　　修改后运行结果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-4-4.png"></p>
<p>　　现在，我们就完成了正六边形单元的排列。接下来的一章中，要修改地图单元的外形，将正方形外观修改成正六边形外观，使其在视觉效果上变为正六边形地图单元的外观。</p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>1-5 绘制正六边形地图单元</title>
    <url>/2020/09/30/HexMap/1-5%20%E7%BB%98%E5%88%B6%E6%AD%A3%E5%85%AD%E8%BE%B9%E5%BD%A2%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83/</url>
    <content><![CDATA[<p>　　在上一章中，我们已经排列好了每个地图单元的位置，但是每个地图单元的外观还是正方形的；这一章中，会将正方形的外观更换成正六边形的外观。</p>
<p>　　要将正方形地图元素外观替换为正六边形地图元素外观，这里首先删除Hex Cell预置上，除了<code>Hex Cell</code>脚本以外的所有组件，如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-5-1.png"></p>
<p>　　接下来，创建HexMesh脚本，内容如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依赖MeshFilter和MeshRenderer组件</span></span><br><span class="line">[<span class="meta">RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMesh</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//存储计算生成后的mesh</span></span><br><span class="line">    <span class="keyword">private</span> Mesh hexMesh;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储所有正六边形的顶点位置信息</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Vector3&gt; vertices;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//索引，每个三角面片顶点的渲染顺序</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="keyword">int</span>&gt; triangles;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//初始化MeshFilter组件的，实例化hexMesh，并给其命名</span></span><br><span class="line">        GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="keyword">new</span> Mesh();</span><br><span class="line">        hexMesh.name = <span class="string">&quot;Hex Mesh&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化vertices和triangles组件</span></span><br><span class="line">        vertices = <span class="keyword">new</span> List&lt;Vector3&gt;();</span><br><span class="line">        triangles = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　脚本创建完成后，在Hex Grid物体下创建一个子物体，命名为Hex Mesh，并挂载<code>HexMesh</code>脚本。因为<code>HexMesh</code>脚本中有<code>[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]</code>语句，所以在Hex Mesh物体上会自动创建MeshFilter组件和MeshRenderer组件，但是MeshRenderer组件中没有默认的材质球，这里为其添加Unity自带的默认材质球，完成效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-5-2.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-5-3.png"></p>
<p>　　接下来，回到<code>HexGrid</code>脚本中，在其Awake方法中，与取得Canvas组件相类似，可以取得HexMesh组件。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储Hex Mesh物体上的hexMesh脚本组件</span></span><br><span class="line"><span class="keyword">private</span> HexMesh hexMesh;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取Hex Mesh物体上的hexMesh脚本组件实例</span></span><br><span class="line">    hexMesh = GetComponentInChildren&lt;HexMesh&gt;();</span><br><span class="line"></span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　获取到HexMesh组件实例后，就可以调用其中的方法来构建正六边形的三角面片了，但是这里要注意，生成三角面片的方法调用，必须在<code>HexMesh</code>脚本初始化完成之后，所以这里在<code>HexGrid</code>的Start方法中调用构建三角面的方法，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>exGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用绘制mesh的方法</span></span><br><span class="line">    hexMesh.Triangulate(cells);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　其实<code>HexMesh.Triangulate</code>方法在程序的任何阶段都可以被调用。在之后的一些步骤中，运行时对地图作出调整，我们还会调用这个方法，所以，在这个方法中，首先要清空旧的mesh、vertices、triangles这些变量的内容；接着读取存储所有HexCell实例的数组，依次录入其顶点Vector3信息和顶点顺序索引；然后将所有HexCell的这些信息全都保存在hexMesh的vertices和triangles数组中；最后，调用RecalculateNormals方法重新计算法线，使最后生成的三角面的视觉效果正确。<code>HexMesh</code>脚本修改代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 根据数组长度创建cell的Mesh</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cells&quot;&gt;</span>存储所有Hex Cell实例的数组<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexCell[] cells</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//清空原有的数据</span></span><br><span class="line">    hexMesh.Clear();</span><br><span class="line">    vertices.Clear();</span><br><span class="line">    triangles.Clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//依次读取数组中的Hex Cell实例，录入每个Hex Cell的顶点信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cells.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Triangulate(cells[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将所有的顶点位置信息，顶点位置信息的索引存储到链表中</span></span><br><span class="line">    hexMesh.vertices = vertices.ToArray();</span><br><span class="line">    hexMesh.triangles = triangles.ToArray();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新计算法线方向，使得三角面片可以正确的显示出来</span></span><br><span class="line">    hexMesh.RecalculateNormals();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 通过单个Hex Cell实例，计算其6个顶点位置，并创建三角形面片</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cell&quot;&gt;</span>单个Hex Cell的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　由于正六边形是由多个三角面片构成的，所以需要创建<code>AddTriangle</code>方法，这个方法入参为3个顶点的Vector3信息。将3个入参信息添加到vertices链表中，并且与其对应的索引值添加到triangles链表中，以备<code>Triangulate</code>方法利用两个链表统一生成三角面片，修改代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 添加单个三角面片的顶点位置信息和索引</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;v1&quot;&gt;</span>顺时针 第一个顶点的Vector3<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;v2&quot;&gt;</span>顺时针 第二个顶点的Vector3<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;v3&quot;&gt;</span>顺时针 第三个顶点的Vector3<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddTriangle</span>(<span class="params">Vector3 v1, Vector3 v2, Vector3 v3</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取当前vertices链表中已经录入的数量</span></span><br><span class="line">    <span class="keyword">int</span> vertexIndex = vertices.Count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在vertices链表中添加新增的顶点位置信息</span></span><br><span class="line">    vertices.Add(v1);</span><br><span class="line">    vertices.Add(v2);</span><br><span class="line">    vertices.Add(v3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在triangles链表中添加新增顶点的索引</span></span><br><span class="line">    triangles.Add(vertexIndex);</span><br><span class="line">    triangles.Add(vertexIndex + <span class="number">1</span>);</span><br><span class="line">    triangles.Add(vertexIndex + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　现在，生成每个地图单元中三角面片的方法基本完成了，在正式生成之前，我们<code>需要</code>先完善<code>Triangulate(HexCell cell)</code>方法，首先测试生成每个正六边形地图元素的第一个三角面片，即从顶部第一个顶点开始计算的两个顶点和中点共同构成的三角面。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 通过单个Hex Cell实例，计算其6个顶点位置，并创建三角形面片</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cell&quot;&gt;</span>单个Hex Cell的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取单个cell的中点位置</span></span><br><span class="line">    Vector3 center = cell.transform.localPosition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据中点位置计算出其余两个顶点的信息，将其传入添加单个三角面片信息的方法中</span></span><br><span class="line">    AddTriangle(</span><br><span class="line">        center,</span><br><span class="line">        center + HexMetrics.corners[<span class="number">0</span>],</span><br><span class="line">        center + HexMetrics.corners[<span class="number">1</span>]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，就为每个正六边形地图元素，生成了第一个三角面片。效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-5-4.png"></p>
<p>　　通过观察上图可以得出，只要修改<code>private void Triangulate(HexCell cell)</code>方法内调用<code>AddTriangle</code>方法的部分，循环6次，即可生成全部的三角面片，修改代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据中点位置计算出其余的顶点位置信息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    AddTriangle(</span><br><span class="line">        center,</span><br><span class="line">        center + HexMetrics.corners[i],</span><br><span class="line">        center + HexMetrics.corners[i + <span class="number">1</span>]</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　在完成以上代码后，如果直接运行，Unity会弹出一个索引越界的错误，导致这个错误的原因是，当for循环中的i为6时，center + HexMetrics.corners[i + 1]中括号里的值为7，而HexMetrics.corners数组中只存储了6个顶点信息HexMetrics.corners[7]其实就是第一个顶点，即正六边形最上方的顶点，所以这里需要在corners数组的末尾添加一条数据，使HexMetrics.corners[7]指向第一个顶点的位置。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//正六边形的六个顶点位置，其姿态为角朝上，从最上面一个顶点开始计算位置</span></span><br><span class="line"><span class="comment">//根据正六边形中点的位置，顺时针依次定义6个顶点的位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Vector3[] corners =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> Vector3(<span class="number">0f</span>, <span class="number">0f</span>, outerRadius),</span><br><span class="line">    <span class="keyword">new</span> Vector3(innerRadius, <span class="number">0f</span>, <span class="number">0.5f</span> * outerRadius),</span><br><span class="line">    <span class="keyword">new</span> Vector3(innerRadius, <span class="number">0f</span>, <span class="number">-0.5f</span> * outerRadius),</span><br><span class="line">    <span class="keyword">new</span> Vector3(<span class="number">0f</span>, <span class="number">0f</span>, -outerRadius),</span><br><span class="line">    <span class="keyword">new</span> Vector3(-innerRadius, <span class="number">0f</span>, <span class="number">-0.5f</span> * outerRadius),</span><br><span class="line">    <span class="keyword">new</span> Vector3(-innerRadius, <span class="number">0f</span>, <span class="number">0.5f</span> * outerRadius),</span><br><span class="line">    <span class="comment">//正六边形其实只有6个顶点，但是当构建三角面片的时候，最后一个三角面片的顶点其实为：最后一个、第一个、中点，即corners[7]</span></span><br><span class="line">    <span class="comment">//为了减少在循环中的判断，这里添加一条数据，防止索引越界即可</span></span><br><span class="line">    <span class="keyword">new</span> Vector3(<span class="number">0f</span>, <span class="number">0f</span>, outerRadius)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>　　在corners数组中添加完数据后，运行效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-5-5.png"></p>
<p>　　最后还有一点需要讨论，为什么我们不合并重叠的顶点？</p>
<p>　　其实完全可以合并，并且还能将“面数”进行优化，比如只使用4个三角形面片就可以拼接成一个正六边形，而不是6个，但是在之后的步骤中，还会对正六边形地图元素作出一些其他的改动，如果现在优化顶点和面数，可能会导致之后的步骤变得更加复杂和难以处理。</p>
<p>　　这一章我们已经生成了正确的正六边形地图元素，下一章将会重新排列这些地图元素的坐标，为之后的计算便捷做准备。</p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>1-6 修改正六边形地图单元的坐标</title>
    <url>/2020/10/01/HexMap/1-6%20%E4%BF%AE%E6%94%B9%E6%AD%A3%E5%85%AD%E8%BE%B9%E5%BD%A2%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E7%9A%84%E5%9D%90%E6%A0%87/</url>
    <content><![CDATA[<p>　　地图系统是一个回合制策略游戏的基础，一个灵活、稳固、拓展性强的地图系统会给游戏带来更多的可能。</p>
<p>　　上一章中，我们正确的生成了所有的正六边形地图单元，现在让我们来重新观察一下这些地图单元的坐标，如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-6-1.png"></p>
<p>　　通过观察上图我们可以发现，在水平的Z轴方向上，每个地图单元的排列都很正常，但是在垂直的X轴方向上，地图单元排列成了锯齿状。导致这个问题的原因是之前我们取消偶数行偏移造成的。相比于正方形的地图元素排列，正六边形的地图元素排列在处理坐标时并没有那么容易。为了方便之后的一些操作，首先创建一个<code>HexCoordinates</code>结构体，我们可以用它来转换现有的坐标系。转换后的X与Z坐标，只公开get属性，确保其不被修改。使用<code>System.Serializable</code>标记这个结构体，使其可以序列化，以便Unity在runtime模式下也可以识别它。</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> HexCoordinates</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//存储重新计算后的X坐标值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> X &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储重新计算后的Z坐标值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Z &#123; <span class="keyword">get</span>; <span class="keyword">private</span> <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 重载默认的构造函数</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x&quot;&gt;</span>为转换后的X坐标赋初始值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;z&quot;&gt;</span>为转换后的Z坐标赋初始值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HexCoordinates</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        X = x;</span><br><span class="line">        Z = z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，创建一个计算坐标偏移的静态方法，我们稍后会完成这个方法，现在只返回传入的参数值即可。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 进行X与Z的坐标转换，将X方向锯齿状的排列，改为斜向的排列</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x&quot;&gt;</span>原始cell的x轴坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;z&quot;&gt;</span>原始cell的z轴坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>目前返回传入的参数值<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HexCoordinates <span class="title">FromOffsetCoordinates</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HexCoordinates(x, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　然后，为了方便之后的观察和调试方便，我们需要重载<code>ToString()</code>方法。如果使用原始的<code>ToString()</code>方法，只会返回struct的名称，这里我们需要返回X和Z的坐标值，修改代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 重载默认的ToString方法，使其返回的是X和Z的坐标值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>X和Z的坐标值<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + X.ToString() + <span class="string">&quot;, &quot;</span> + Z.ToString() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最后，我们还需要声明<code>ToStringOnSeparateLines()</code>方法，用来将X和Z的值输出到之前的UI元素上，这个方法与重载的<code>ToString()</code>方法很类似，只是添加了<code>\n</code>进行换行。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将转换后的X和Z的坐标值添加换行符，以便显示在UGUI的每个cell上</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>添加换行符后的X和Z，符合Text组件的富文本格式<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">ToStringOnSeparateLines</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> X.ToString() + <span class="string">&quot;\n&quot;</span> + Z.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　完成了这些步骤后，让我们回到<code>FromOffsetCoordinates(int x, int z)</code>方法中。</p>
<p>　　这里有个很重要的一点需要注意，在之前的所有步骤中，每个地图单元和其坐标显示，是完全一一对应的，我们在修改地图单元排列方式的同时，其坐标值也会跟着改变。但是在接下来的步骤中，我们会脱离开这种相互影响的关系，只专注于修改坐标。即通过<code>FromOffsetCoordinates(int x, int z)</code>方法将地图单元网格和坐标值两者排列分开。也可以理解为在保持所有地图单元网格排列为矩形不变的情况下，只重新排列每个网格对应的坐标值，这样我们就将坐标与网格分开看待了。在之后的一些步骤中，做到只修改网格或坐标其中之一，而不影响另一个的排列方式的效果。</p>
<p>　　所以，这里我们就要取消坐标值的偶数行的偏移，让X轴的坐标依然是斜向排列的。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 进行X与Z的坐标转换，将X方向锯齿状的排列，改为斜向的排列</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 这个方法将mesh和坐标值分开处理了</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 这里的入参只是处理X和Z的坐标，与mesh的排列和位置无关</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x&quot;&gt;</span>原始cell的x轴坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;z&quot;&gt;</span>原始cell的z轴坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>目前返回传入的参数值<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HexCoordinates <span class="title">FromOffsetCoordinates</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HexCoordinates(x - z / <span class="number">2</span>, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　完成这个方法后，我们回到<code>HexGrid.CreateCell(int x, int z, int i)</code>方法中。这个方法是负责排列每个地图元素、计算每个地图元素的坐标值、将坐标值传递到Text组件上并显示出来。所以要在此方法中调用<code>struct HexCoordinates</code>修改坐标的<code>FromOffsetCoordinates</code>方法，和为Text输出富文本格式坐标值的<code>ToStringOnSeparateLines</code>方法。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置被实例化地图单元的父级和位置</span></span><br><span class="line">    cell.transform.SetParent(transform, <span class="literal">false</span>);</span><br><span class="line">    cell.transform.localPosition = position;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在不改变cell排列的情况下，重新计算每个cell的坐标位置</span></span><br><span class="line">    cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z);</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置label的文字，就是cell在数组中的位置</span></span><br><span class="line">    <span class="comment">//label.text = x.ToString() + &quot;\n&quot; + z.ToString();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将转换后的坐标值复制给UGUI的Text组件，将它显示出来</span></span><br><span class="line">    label.text = cell.coordinates.ToStringOnSeparateLines();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最后，在HexCell组件中创建一个HexCoordinates的实例，这样，在HexGrid实例化地图元素的时候，会自动调用每个地图元素HexCell组件上的HexCoordinates实例进行坐标的转换。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell .cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在实例化每个cell的时候会调用该实例</span></span><br><span class="line">    <span class="comment">//针对每个cell，重新计算它的坐标值</span></span><br><span class="line">    <span class="keyword">public</span> HexCoordinates coordinates;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　经过以上步骤的操作，我们的坐标转换就完成了。最终在不改变地图单元mesh排列的情况下，达到了下图的坐标排列效果：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-6-2.png"></p>
<p>　　将修改坐标前后的效果对比一下，更加方便理解和找出其中的规律：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-5-5.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-6-3.png"></p>
<p>　　经过观察转换后的效果，我们发现这样一个问题：如果一个人物站在某个正六边形地图单元上，那他可以朝6个方向移动，分别为右上、右、右下、左下、左、左上。目前我们在这里只有X和Z维度，Z可以描述左右移动和偏移量，X可以描述右上和左下移动和偏移量。这里缺少了描述左上和右下移动和偏移量的坐标。所以，我们需要在这个平面中再添加一个维度，用来描述这两个对称方向的移动和偏移量。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-6-4.png"></p>
<p>　　通过观察上图可以发现，其实只需要将X轴镜像翻转一下，便可以得到Y轴。并且在坐标系的任意一个位置，X+Y+Z的值适中为0。也就是说，一个轴上的坐标值增大，另一个轴上就会减少，这样就产生了6个移动方向。这些坐标通常称为立方体坐标，因为它是三维的,其拓扑结构类似于立方体。</p>
<p>　　通过以上观察和总结，添加Y维度的坐标就变得很容易了。只需要利用X+Y+Z坐标始终为0这个特性即可。我们可以在<code>HexCoordinates</code>中创建一个方法用来计算Y的坐标值，然后在<code>ToString</code>和<code>ToStringOnSeparateLines</code>方法中调用它。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算Y的坐标值并存储下来</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Y</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> -X - Z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 进行X与Z的坐标转换，将X方向锯齿状的排列，改为斜向的排列</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 这个方法将mesh和坐标值分开处理了</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 这里的入参只是处理X和Z的坐标，与mesh的排列和位置无关</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x&quot;&gt;</span>原始cell的x轴坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;z&quot;&gt;</span>原始cell的z轴坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>目前返回传入的参数值<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HexCoordinates <span class="title">FromOffsetCoordinates</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HexCoordinates(x - z / <span class="number">2</span>, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 重载默认的ToString方法，使其返回的是转换后的X和Z的坐标值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>X和Z的坐标值<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">string</span> <span class="title">ToString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//return &quot;(&quot; + X.ToString() + &quot;, &quot; + Z.ToString() + &quot;)&quot;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入了Y坐标值的表示</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + X.ToString() + <span class="string">&quot;, &quot;</span> + Y.ToString() + <span class="string">&quot;, &quot;</span> + Z.ToString() + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将转换后的X和Z的坐标值添加换行符，以便显示在UGUI的每个cell上</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>添加换行符后的X和Z，符合Text组件的富文本格式<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">ToStringOnSeparateLines</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//return X.ToString() + &quot;\n&quot; + Z.ToString();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入了Y坐标值的输出</span></span><br><span class="line">    <span class="keyword">return</span> X.ToString() + <span class="string">&quot;\n&quot;</span> + Y.ToString() + <span class="string">&quot;\n&quot;</span> + Z.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　完成以上代码后，回到Unity，点击Play按钮查看效果如下图。这样我们在不改变mesh排列的情况下，重新排列了每个地图单元的坐标。并且添加了Y维度的坐标轴，完善了整个地图的坐标系统。</p>
<p>　　下一章，我们会使用脚本将计算好的坐标显示在Inspector上，这样将更加便于我们调试和观察坐标的变化。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-6-5.png"></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>1-7 将坐标值显示在Inspector上</title>
    <url>/2020/10/02/HexMap/1-7%20%E5%B0%86%E5%9D%90%E6%A0%87%E5%80%BC%E6%98%BE%E7%A4%BA%E5%9C%A8Inspector%E4%B8%8A/</url>
    <content><![CDATA[<p>　　在上一章中，我们重新排列了每个地图单元的坐标值，并且添加了Y维度的坐标轴。随着项目不断复杂。在Unity runtime下，选中一个地图单元后，在Inspector门面板只能看到<code>coordinates</code>这个变量的名称，而不是显示这个地图单元的坐标值。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-7-1.png"></p>
<p>　　虽然我们选中一个地图单元后，可以通过观察Scene窗口中它的坐标值，来确定这个地图单元的位置。但是在Inspector中增加坐标值显示，会更加方便美观。接下来我们实现这个功能。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//用来显示在Inspector上cell坐标</span></span><br><span class="line">[<span class="meta">SerializeField</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x, z;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储重新计算后的X坐标值</span></span><br><span class="line"><span class="comment">//public int X &#123; get; private set; &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> X</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储重新计算后的Z坐标值</span></span><br><span class="line"><span class="comment">//public int Z &#123; get; private set; &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Z</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 重载默认的构造函数</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x&quot;&gt;</span>为转换后的X坐标赋初始值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;z&quot;&gt;</span>为转换后的Z坐标赋初始值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HexCoordinates</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//X = x;</span></span><br><span class="line">    <span class="comment">//Z = z;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.z = z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　如下图所示，我们利用<code>[SerializeField]</code>将X和Y的坐标值显示在了Inspector面板上。但是这两个坐标值是可编辑状态，这并不是我们希望达到的效果。因为坐标值应该是固定不变的，而且这样竖向排列也不美观。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-7-2.png"></p>
<p>　　为了解决这个问题，我们为HexCoordinates创建一个自定义特性来改变它的显示方式。</p>
<p>　　在项目中创建Editor文件夹，并且在该文件夹内创建<code>HexCoordinatesDrawer.cs</code>脚本。这是一个只用于编辑器的脚本，扩展自<code>UnityEditor.PropertyDrawer</code>，并且需要<code>UnityEditor.CustomPropertyDrawer</code>特性来让其正确关联起来。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinatesDrawer.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEditor;</span><br><span class="line"></span><br><span class="line">[<span class="meta">CustomPropertyDrawer(typeof(HexCoordinates))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCoordinatesDrawer</span> : <span class="title">PropertyDrawer</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　<code>HexCoordinatesDrawer</code>继承了<code>PropertyDrawer</code>，<code>PropertyDrawers</code>通过<code>OnGUI()</code>方法显示其内容，该方法提供了要在其中绘制的屏幕矩形、序列化的属性数据以及它所属的字段的标签。这里添加OnGUI()方法，在此方法中重新绘制X和Z的坐标。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinatesDrawer.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnGUI</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Rect position, SerializedProperty property, GUIContent label</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，只需要提取出X和Z的坐标，使用HexCoordinates中重载的ToString()方法在指定的位置重新绘制GUI即可。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinatesDrawer.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//将X和Z的坐标从HexCoordinates中提取出来</span></span><br><span class="line">HexCoordinates coordinates = <span class="keyword">new</span> HexCoordinates(</span><br><span class="line">    property.FindPropertyRelative(<span class="string">&quot;x&quot;</span>).intValue,</span><br><span class="line">    property.FindPropertyRelative(<span class="string">&quot;z&quot;</span>).intValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用HexCoordinates中重载的ToString方法，显示坐标</span></span><br><span class="line">GUI.Label(position, coordinates.ToString());</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-7-3.png"></p>
<p>　　现在，坐标可以正确的显示出来了。但是这里只显示了数字，丢失了类型名。这里使用EditorGUI.PrefoxLabel()方法来或能重新绘制类型名。这个方法还有一个往外的好处，它可以返回一个经过吊证的矩形，该矩形与右侧的做标数值显示区域大小刚好匹配。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinatesDrawer.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//绘制坐标的类型名称</span></span><br><span class="line">position = EditorGUI.PrefixLabel(position, label);</span><br><span class="line"><span class="comment">//利用HexCoordinates中重载的ToString方法，显示坐标</span></span><br><span class="line">GUI.Label(position, coordinates.ToString());</span><br></pre></td></tr></table></figure>

<p>　　最终效果如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-7-4.png"></p>
<p>　　现在，我们在Unity中进行调试的时候，选中了某一个地图单元，Inspector面板中变回显示这个单元格的X Y Z坐标了。下一步，我们将添加一些简单的交互，当出表点击地图单元的时候，嚷被点击的地图单元改变颜色。</p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>1-8 获取鼠标点击位置</title>
    <url>/2020/10/03/HexMap/1-8%20%E8%8E%B7%E5%8F%96%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>　　在之前的章节中，我们完成了一个正六边形地图系统的基本框架。但是目前这个地图系统是无法与玩家产生任何交互的。在一般策略游戏中，地图系统最基本的交互方式，就是响应玩家的鼠标点击事件。即玩家鼠标左键单击一个地图单元，这个地图单元便会改变颜色，或者播放一段预置的动画，来响应玩家的操作。我们可以通过鼠标向场景中发射一条射线的方式，来检测鼠标是否点击在了某个地图单元上。</p>
<p>　　目前，我们先把交互代码放在<code>HexGrid.cs</code>脚本里，随着项目在之后的章节中不断完善，将会把与玩家交互的代码移动到其他的脚本中。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//之后鼠标点击交互相关代码会移动到其他脚本中</span></span><br><span class="line">    <span class="comment">//检测鼠标左键是否点击</span></span><br><span class="line">    <span class="keyword">if</span> (Input.GetMouseButton(<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        HandleInput();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 鼠标左键单击会调用此方法，以鼠标为发射点，经过主摄像机练成射线</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 检测射线穿过Collider的位置</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleInput</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//射线起点为鼠标位置，经过主摄像机</span></span><br><span class="line">    Ray inputRay = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测射线是否碰撞到了collider</span></span><br><span class="line">    RaycastHit hit;</span><br><span class="line">    <span class="keyword">if</span> (Physics.Raycast(inputRay, <span class="keyword">out</span> hit))</span><br><span class="line">    &#123;</span><br><span class="line">        TouchCell(hit.point);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将射线的触碰点转换到自身的坐标系中</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;position&quot;&gt;</span>触碰到的collider的位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TouchCell</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将触碰点的坐标系，转换到自身的坐标系</span></span><br><span class="line">    position = transform.InverseTransformPoint(position);</span><br><span class="line">    Debug.Log(<span class="string">&quot;touched at &quot;</span> + position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　现在，我们完成了鼠标左键单击后发射一条射线的功能，这条射线如果穿过了一个带有Collider组件的模型，那么将会返回一个Vector3的位置信息。但是，现在的地图单元是没有Collider组件的，我们在HexMesh.cs脚本中为它添加MeshCollider组件。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了检测射线碰撞Collider</span></span><br><span class="line"><span class="keyword">private</span> MeshCollider meshCollider;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化MeshFilter组件的，实例化hexMesh，并给其命名</span></span><br><span class="line">    GetComponent&lt;MeshFilter&gt;().mesh = hexMesh = <span class="keyword">new</span> Mesh();</span><br><span class="line">    hexMesh.name = <span class="string">&quot;Hex Mesh&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为HexMesh物体添加MeshCollider组件</span></span><br><span class="line">    meshCollider = gameObject.AddComponent&lt;MeshCollider&gt;();</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　为Hex Mesh这个物体添加了<code>MeshCollider</code>组件后，我们需要将创建的Mesh数据赋值给<code>MeshCollider</code>组件，这样它就可以根据Mesh信息成成碰撞网格了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexCell[] cells</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    meshCollider.sharedMesh = hexMesh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，射线穿过Hex Mesh这个物体时，通过<code>MeshCollider</code>组件就可以返回射线的碰撞信息了。</p>
<p>　　可能会有小伙伴问，为什么不使用更简单高效的<code>Box Collider</code>？这是因为<code>Box Collider</code>不能很准确的吻合正六边形地图单元的轮廓，尤其是在3个地图单元相邻的情况下，<code>Box Collider</code>可能会重叠到一起，最终导致我们无法判断鼠标到底点击在了哪个地图单元上。而且随着项目的不断深入，我们的地形单元并不会一直保持在同意水平面上。所以使用<code>MeshCollider</code>会更加方便计算和判断。</p>
<p>　　以上代码完成后，我们在Unity的Scene窗口中点击任意一个地图单元，Console窗口中就会输出鼠标点击的坐标信息了。但是这个信息并没有体现出我们具体点击的是哪一个地图单元，所以需要将鼠标的点击的坐标信息，转换成六边形的坐标信息。这个步骤需要在HexCoordinates.cs中进行。</p>
<p>　　我们需要在首先要在HexGrid.TouchCell方法内，添加对HexCoordinates.cs中发发的调用，这个方法命名为FromPosition，专门用来将射线触碰MeshCollider的坐标，转换成正六边形地图的坐标。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TouchCell</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将触碰点的坐标系，转换到自身的坐标系</span></span><br><span class="line">    position = transform.InverseTransformPoint(position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用转换坐标的方法，定位具体点击到哪个cell上了</span></span><br><span class="line">    HexCoordinates coordinates = HexCoordinates.FromPosition(position);</span><br><span class="line"></span><br><span class="line">    Debug.Log(<span class="string">&quot;touched at &quot;</span> + coordinates.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　现在，我们来思考FromPosition这个方法要处理的事情。要将原有的射线触碰Collider信息转换成正六边形地图信息，可以将X、Y、Z几个轴向分开处理。这里首先处理X轴坐标，只需要将转换前的坐标除以地图单元的宽度即可，而且当Z值为0的时候，X和Y是护卫相反数的。在这里我们先假设Z值为0，所以很容易就能得出X和Y的值。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HexCoordinates <span class="title">FromPosition</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当Z为0的时候，X和Y互为相反数</span></span><br><span class="line">    <span class="comment">//X的值可以通过 实际X的值除以2倍内切圆半径来得到</span></span><br><span class="line">    <span class="keyword">float</span> x = position.x / (HexMetrics.innerRadius * <span class="number">2f</span>);</span><br><span class="line">    <span class="keyword">float</span> y = -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，Z不为0的时候，我们需要对X和Y进行偏移，才能得出正确的结果。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> offset = position.z / (HexMetrics.outerRadius * <span class="number">3f</span>);</span><br><span class="line">x -= offset;</span><br><span class="line">y -= offset;</span><br></pre></td></tr></table></figure>

<p>　　当计算出X和Y的值后，我们可以利用X+Y+Z=0这个特性，求出Z的坐标。然后将这些坐标进行四舍五入，就可以得到转换后的正六边形地图坐标了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//对得出的坐标进行四舍五入，得到转换后的Hexmap坐标</span></span><br><span class="line"><span class="keyword">int</span> iX = Mathf.RoundToInt(x);</span><br><span class="line"><span class="keyword">int</span> iY = Mathf.RoundToInt(y);</span><br><span class="line"><span class="keyword">int</span> iZ = Mathf.RoundToInt(-x - y);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HexCoordinates(iX, iZ);</span><br></pre></td></tr></table></figure>

<p>　　以上这些步骤虽然看起来没什么问题，但是仔细想一下就会发现，这样计算的最终坐标，很可能相加并不为0.让我们来加一段验证这个想法的代码：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//对得出的坐标进行四舍五入，得到转换后的Hexmap坐标</span></span><br><span class="line"><span class="keyword">int</span> iX = Mathf.RoundToInt(x);</span><br><span class="line"><span class="keyword">int</span> iY = Mathf.RoundToInt(y);</span><br><span class="line"><span class="keyword">int</span> iZ = Mathf.RoundToInt(-x - y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证X+Y+Z是否为0</span></span><br><span class="line"><span class="keyword">if</span> (iX + iY + iZ != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Debug.LogWarning(<span class="string">&quot;rounding error!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> HexCoordinates(iX, iZ);</span><br></pre></td></tr></table></figure>

<p>　　我们再次运行程序的时候发现，这个报错信息确实会弹出。而且是发生在鼠标点击的位置接近正六边形边界的时候。所以应该是在四舍五的过程中出现了问题，因为离地图单元的中心越远，四舍五入时舍去的值就越多，所以我们做一个合理的假设：舍去值更大的坐标是错误的。</p>
<p>　　知道了产生错误的原因，解决起来就比较简单了。解决方法就是废弃具有最大舍去增量的坐标值，然后用其它的两个坐标去重新构建它。这里我们只需要去重建X和Z，不需要关注Y，因为Y本来就是由X和Z求得的。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCoordinates.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (iX + iY + iZ != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">float</span> dX = Mathf.Abs(x - iX);</span><br><span class="line">    <span class="keyword">float</span> dY = Mathf.Abs(y - iY);</span><br><span class="line">    <span class="keyword">float</span> dZ = Mathf.Abs(-x - y - iZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断哪个舍去的值最多</span></span><br><span class="line">    <span class="comment">//利用X+Y+Z=0的特性，使用两个舍去较小的值得，求出社区较大的那个</span></span><br><span class="line">    <span class="keyword">if</span> (dX &gt; dY &amp;&amp; dX &gt; dZ)</span><br><span class="line">    &#123;</span><br><span class="line">        iX = -iY - iZ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dZ &gt; dY)</span><br><span class="line">    &#123;</span><br><span class="line">        iZ = -iX - iY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　通过判断，我们重新计算四舍五入中，舍去的值最多的那个坐标。这样我们就得到了最终正确结果。</p>
<p>　　在下一章中，我们利用本章判断鼠标点击在哪个地图单元上的功能，给被点击的地图单元改变颜色，让地图系统拥有最基本的交互。</p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>1-9 改变选中地图单元的颜色</title>
    <url>/2020/10/04/HexMap/1-9%20%E6%94%B9%E5%8F%98%E9%80%89%E4%B8%AD%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E7%9A%84%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<p>　　在上一章中，我们通过坐标转换，可以知道鼠标点击在了哪一个地图单元上。接下来，我们在这个基础上改变被鼠标点击的地图单元的颜色。</p>
<p>　　在<code>HexGrid.cs</code>中声明两个变量，分别为默认颜色和点击后变化的颜色，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//cell的默认颜色</span></span><br><span class="line"><span class="keyword">public</span> Color defaultColor = Color.white;</span><br><span class="line"><span class="comment">//cell被点击后的颜色</span></span><br><span class="line"><span class="keyword">public</span> Color touchedColor = Color.magenta;</span><br></pre></td></tr></table></figure>

<p>　　回到Unity中，选中Hex Grid物体，在Inspector面板中就能看到下图的效果，当然，我们也可以自定义初始颜色和点击后的颜色，如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-9-1.png"></p>
<p>　　回到<code>HexCell.cs</code>中，在这里我们声明一个变量，用来存储每个地图单元自己的颜色。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在实例化每个cell的时候会调用该实例</span></span><br><span class="line">    <span class="comment">//针对每个cell，重新计算它的坐标值</span></span><br><span class="line">    <span class="keyword">public</span> HexCoordinates coordinates;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储cell自身的颜色</span></span><br><span class="line">    <span class="keyword">public</span> Color color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　为每个地图单元赋初始颜色值，可以在HexGrid.CreateCell方法中实现。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//在不改变cell排列的情况下，重新计算每个cell的坐标位置</span></span><br><span class="line">    cell.coordinates = HexCoordinates.FromOffsetCoordinates(x, z);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为每个cell赋颜色初始值</span></span><br><span class="line">    cell.color = defaultColor;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　当然，我们还需要将颜色的信息赋值给地图单元的Mesh组件，这样才能将颜色显示出来。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储cell每个顶点的颜色信息</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Color&gt; colors;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//初始化vertices、triangles链表 用于存储顶点和面片信息</span></span><br><span class="line">    vertices = <span class="keyword">new</span> List&lt;Vector3&gt;();</span><br><span class="line">    triangles = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化colors链表，用于存储顶点颜色信息</span></span><br><span class="line">    colors = <span class="keyword">new</span> List&lt;Color&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexCell[] cells</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    triangles.Clear();</span><br><span class="line">    colors.Clear();</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将所有的顶点位置信息，顶点位置信息的索引存储到链表中</span></span><br><span class="line">    hexMesh.vertices = vertices.ToArray();</span><br><span class="line">    hexMesh.triangles = triangles.ToArray();</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//将所有顶点的颜色信息存储在colors链表中</span></span><br><span class="line">    hexMesh.colors = colors.ToArray();</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接着，在进行每个三角面片构建的时候，我们将颜色的信息赋值给每一个顶点，这样在构建出地图单元的时候，就带有了我们定义的初始颜色了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexCell[] cells</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//根据中点位置计算出其余的顶点位置信息，并按照顺序构建三角面片</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//构建三角面片</span></span><br><span class="line">        AddTriangle(</span><br><span class="line">            center,</span><br><span class="line">            center + HexMetrics.corners[i],</span><br><span class="line">            center + HexMetrics.corners[i + <span class="number">1</span>]</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为三角面片的顶点赋颜色值</span></span><br><span class="line">        AddTriangleColor(cell.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 为每个三角面片的3个顶点赋颜色值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;color&quot;&gt;</span>三角面片顶点的颜色信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddTriangleColor</span>(<span class="params">Color color</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    colors.Add(color);</span><br><span class="line">    colors.Add(color);</span><br><span class="line">    colors.Add(color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们回到HexGrid.TouchCell方法中。这个方法的流程可以理解为：先将Unity内普通的坐标，转换成六边形地图中的坐标，即从Unity的Vector3(8.7, 0, 13.9)坐标转换为六边形地图的(0, -1, 1)坐标。</p>
<p>　　接着，我们还需要知道被点击的地图单元在数组<code>HexGrid.cell[]</code>中具体的位置，也就是被惦记的地图单元在数组<code>HexGrid.cell[]</code>中的下标。才可以为该地图单元赋值新的颜色。</p>
<p>　　如果要改变其颜色，依照现有的方法，我们还需要重新构建整个六边形地图的Mesh，因为这个Mesh是整体存储在一个变量中的。但是我们真的有必要因为某个地图单元的颜色改变而重新构建整个正六边形地图的Mesh吗？答案很显然，重新构建整个Mesh是不合理的。</p>
<p>　　但是现在还不是优化这个步骤的时候，因为随着项目的功能不断增加，代码会变得越来越复杂，Mesh的外观也会变得复杂。所以现在做的任何优化在之后的代码中都会变得没有意义。虽然重新构建整个正六边形地图的Mesh虽然很无脑，但是却十分有效，目前我们先这样为地图单元更改颜色。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TouchCell</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用转换坐标的方法，定位具体点击到哪个cell上了</span></span><br><span class="line">    HexCoordinates coordinates = HexCoordinates.FromPosition(position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算出cell位于cells[]数组中的位置</span></span><br><span class="line">    <span class="keyword">int</span> index = coordinates.X + coordinates.Z * width + coordinates.Z / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取这个cell的实例</span></span><br><span class="line">    HexCell cell = cells[index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为这个cell赋值颜色</span></span><br><span class="line">    cell.color = touchedColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新构建整个map的mesh</span></span><br><span class="line">    hexMesh.Triangulate(cells);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　代码完成之后，我们点击某一个地图单元，但是并没有任何的改变，被点击的地图单元也没有改变颜色。这是因为Unity中默认的着色器没有使用顶点颜色。我们需要自己创建一个自定义着色器（Assets/Create/Shader/Standard Surface Shader），并修改其中的代码。其实我们只需要对Unity新建的着色器进行2处很小的改动：1 在输入部分添加颜色信息。2 输出时让反射率与颜色值相乘。而且我们不必关心透明通道，只需要集中在rgb通道即可。代码如下： s</p>
<figure class="highlight csharp"><figcaption><span>HexCell.shader</span></figcaption><table><tr><td class="code"><pre><span class="line">Shader <span class="string">&quot;Custom/HexCell&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="keyword">struct</span> Input</span><br><span class="line">        &#123;</span><br><span class="line">            float2 uv_MainTex;</span><br><span class="line">            <span class="comment">//添加颜色输入</span></span><br><span class="line">            float4 color:COLOR;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">surf</span> (<span class="params">Input IN, inout SurfaceOutputStandard o</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            …</span><br><span class="line">            <span class="comment">//o.Albedo = c.rgb;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//输出部分，反射率与输入的颜色值相乘</span></span><br><span class="line">            o.Albedo = c.rgb * IN.color;</span><br><span class="line">            </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，新建一个材质球，使用我们修改后的shader，并将这个材质球替换掉场景中Hex Mesh物体组件上的材质球。最后效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-9-2.png"></p>
<p>　　这里要注意，某些情况下，点击地图单元后，可能会产生一些奇怪的阴影效果！这是因为在某些Unity版本中Standard Surface Shader可能会有阴影问题。如果发生了阴影抖动或者带状阴影的问题，这说明Z轴发生了冲突。调整全局方向光的阴影偏斜角度应该可以解决这个问题。</p>
<p>　　这样我们就完成了基本的交互功能了。当我们点击一个地图单元后，这个地图单元就会变成我们预先定义好的被点击的颜色。下一章中我们在这个基础上更进一步，制作一个简单的地图编辑器功能，可以为不同的地图单元赋值不同的颜色。</p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>2-1 计算相邻的地图单元的位置</title>
    <url>/2020/10/06/HexMap/2-1%20%E8%AE%A1%E7%AE%97%E7%9B%B8%E9%82%BB%E7%9A%84%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E7%9A%84%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>　　上一章中我们完成了改变单个地图单元颜色的功能。但是通过观察可以发现，如果相邻的两个地图单元颜色不相同，他们之间的颜色过渡会显得非常的生硬。两者的对比效果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-1-5.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-1-1.png"></p>
<p>　　观察对比图可以发现，地图单元之间拥有颜色过渡后，视觉效果会更好一些。在接下来的部分，我们暂时将改变色时重新构建整个地图Mesh的问题放一边，重点放在视觉表现上面。</p>
<p>　　要想产生平滑的颜色过渡，我们首先需要知道每个地图单元与谁相邻，才可以得到相邻地图单元的颜色，进一步进行颜色的平滑过渡。在这里我们创建一个新的脚本，命名为<code>HexDirection</code>，其中声明一个枚举，用来标识一个地图单元与其相邻的其他地图单元的方位。其分别为东北（NE）、东（ E )、东南(SE)、西南(SW)、西(W)、西北(NW)。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-1-2.png"></p>
<figure class="highlight csharp"><figcaption><span>HexDirection.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//表示相邻cell方位的枚举</span></span><br><span class="line"><span class="comment">//从左上角顺时针依次开始</span></span><br><span class="line"><span class="comment">//参考图：http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-1-2.png</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> HexDirection</span><br><span class="line">&#123;</span><br><span class="line">    NE,</span><br><span class="line">    E, </span><br><span class="line">    SE, </span><br><span class="line">    SW, </span><br><span class="line">    W, </span><br><span class="line">    NW</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>关于枚举类型<br><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/enum">MSDN连接</a></br><br>可以使用<code>enum</code>关键字来定义枚举，是有名字的有序列表。这种类型的变量可以使用这些名称中的一个作为它的值，每个名称都对应一个数字，默认情况下从0开始。当你需要有限长度的可命名有序列表时，这些非常有用。<br>实际上枚举就是简单的整数。你可以对它们进行加、减操作，转换成整数再转回来。同样也可以转换成少数其他类型，但整数是其基本类型。</p>
</blockquote>
<p>　　回到HexCell.cs脚本中，在开头部分添加一个数组，用来存储相邻地图单元的实例。这里将该数组设置为Private，并使用<code>[SerializeField]</code>标记这个变量，使其能够在Inspector面板中显示出来。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来存储每个cell的 相邻cell实例</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> HexCell[] neighbors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　在这里，我们会保留相邻地图单元的引用，虽然可以通过坐标来直接获取相邻地图单元，但是在有引用关系的情况下会更加方便一些，而且保留引用关系在之后的一些操作中也很便利。</p>
<p>　　回到Unity中，选中Hex Cell的预置，我们可以看到neighbors变量已经显示在了Inspector面板上。因为每个地图单元最多可以有6个相邻地图单元。所以这里将neighbors数组的长度设置为6。效果如下：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-1-3.png"></p>
<p>　　接下来在HexCell.cs脚本中，创建一个公共方法，用来获取<code>neighbors</code>数组中的内容。因为之前声明的<code>HexDirection</code>枚举，其取值范围在0-5之间，同时<code>neighbors</code>数组长度为6，所以这里不用检查数组下标是否越界。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 用来获取neighbors中相应方位cell的实例</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 这里注意，虽然HexDirection取值为0-5，neighbors长度为6，不会越界</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 但是不是所有cell都有6个相邻的cell_neighbor，所以可能取出为空，之后会添加判断</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>相邻cell的方位 枚举<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>相应方位cell 的实例<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HexCell <span class="title">GetNeighbor</span>(<span class="params">HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> neighbors[(<span class="keyword">int</span>)direction];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　因为<code>neighbors</code>数组为private，所以还需要一个将相邻地图单元实例赋值到数组中的一个方法。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 将相邻的cell实例赋值到neighbors中对应的位置</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 这里注意neighbors的索引下标，应与HexDirection方位的int值对应</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>相邻cell的方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cell&quot;&gt;</span>相邻cell的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetNeighbor</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        neighbors[(<span class="keyword">int</span>)direction] = cell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　因为方位是相对的。例如一个地图单元A，其E方位的地图单元实例为B，那么也可以说A在B的W方位。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-1-4.png"></p>
<p>　　所以在获取自身相邻地图单元实例的时候，同时将自身加入其相邻单元格实例的<code>neighbors</code>数组中。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 将相邻的cell实例赋值到neighbors中对应的位置</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 这里注意neighbors的索引下标，应与HexDirection方位的int值对应</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>相邻cell的方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cell&quot;&gt;</span>相邻cell的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetNeighbor</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        neighbors[(<span class="keyword">int</span>)direction] = cell;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在赋值自身的neighbors实例的同时，也将自身实例赋值到相邻cell的neighbors数组中</span></span><br><span class="line">        cell.neighbors[(<span class="keyword">int</span>)direction.Opposite()] = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，让我们到HexDirection.cs脚本中完成<code>Oppositie()</code>方法。这个方法主要是将地图单元自身实例，添加到相邻地图单元<code>neighbors</code>数组中的对应位置。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexDirection.cs</span></figcaption><table><tr><td class="code"><pre><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexDirectionExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 参考图 http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-1-4.png</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 根据 相邻cell 位于 自身cell 的位置，获得 自身cell 位于 相邻cell 的位置</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 也就是得到相反位置</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HexDirection <span class="title">Opposite</span>(<span class="params"><span class="keyword">this</span> HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//return (int)direction &lt; 3 ? (direction + 3) : (direction - 3);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//已知了 相邻cell 的位置，自身cell位置与相邻cell位置相反</span></span><br><span class="line">        <span class="comment">//即 W(1) - E(4)这样的对应关系，之间正好相差3</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int</span>)direction &lt; <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (direction + <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (direction - <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>什么是扩展方法？<br><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/extension-methods">MSDN连接</a></br><br>扩展方法是一个静态类中的静态方法，但使用起来像是某些类型的实例方法。这个类型可以是任何东西:自定义类、接口、结构体、原生数据结构或者是枚举。扩展方法的第一个参数之前必须有this关键字,它定义方法将操作的类型和实例的值。<br>这个特性允许我们在任何东西上添加方法,就像是静态方法的参数可以是任何类型。在有节制适量使用的情况下这个特性非常方便。但过度使用会造成代码结构的混乱。</p>
</blockquote>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/18aca13c0edcfd279b0b54cd0fedbfaea4b91f9e">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>2-10 颜色混合区域优化</title>
    <url>/2020/10/15/HexMap/2-10%20%E9%A2%9C%E8%89%B2%E6%B7%B7%E5%90%88%E5%8C%BA%E5%9F%9F%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>　　在之前的章节中我们创建了专门进行颜色混合的区域，又将颜色混合区域进行拆分，分为了双色混合区域和三色混合区域。下图为我们目前各个颜色混合区域和地图单元的示意图。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-10-1.png"></p>
<p>　　通过观察这个示意图并结合在Unity中生成的Mash可以发现：两个相邻的地图单元之间，是由两个矩形颜色混合区域进行链接，每个矩形颜色混合区域是由2个三角面片组成。而三色混合区域，是由6个三角面片组成的。<br>　　虽然在视觉效果上并没有什么不妥，但是如果在Unity中观察生成的Mash，我们发现现在的三角面片的分布有些过于复杂了。如果我们直接使用更少的三角面片进行连接，有很多进行颜色平均的步骤都不再需要了。这样能增加代码的运行效率，提高整体流畅度。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-10-2.png"></p>
<blockquote>
<p>我们为什么不在一开始就这么做？<br>你可能会在你的一生中问许多次这个问题，但这是马后炮。这是一个代码以逻辑方式演进的例子，直到获得了新的见解，从而产生了新的方法。这样的顿悟常常发生在你认为你已经搞定的时候。</p>
</blockquote>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>2-11 优化双色混合区域</title>
    <url>/2020/10/16/HexMap/2-11%20%E4%BC%98%E5%8C%96%E5%8F%8C%E8%89%B2%E6%B7%B7%E5%90%88%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>　　在上一章中，我们分析了应该如何进对颜色混合区域进行面数的优化，现在我们来实现这一功能。<br>　　首先我们来优化矩形颜色混合区域，也就是两个相邻地图单元的双色混合区域。目前的混合区域是使用两个矩形进行颜色混合，也就是4个三角面片。在这里我们把一侧的的颜色混合区域宽度增加一倍。也就是在<code>HexMetrics.GetBridge</code>方法中，不再需要乘以0.5。</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">GetBridge</span>(<span class="params">HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里对颜色混合区域进行优化</span></span><br><span class="line">    <span class="comment">//之前的 * 0.5f 的作用是：设两个cell的颜色混合区域宽度为1</span></span><br><span class="line">    <span class="comment">//那每个cell的颜色混合区域宽度都是 自身颜色到两者颜色相加的一半</span></span><br><span class="line">    <span class="comment">//也就是两个相邻的cell各自混合了一半，所以该区域宽度要 *0.5f</span></span><br><span class="line">    <span class="comment">//在这里要将两个0.5宽度的颜色混合区域合并为一个整体，所以不在需要*0.5f了</span></span><br><span class="line">    <span class="keyword">return</span> (corners[(<span class="keyword">int</span>)direction] + corners[(<span class="keyword">int</span>)direction + <span class="number">1</span>]) * blendFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-11-1.png"></p>
<p>　　经过修改代码，现在一个矩形双色混合区域连接了两个地图单元。虽然通过·观察生成的Mesh兵没有发现什么问题，但其实在两个相邻的地图单元之间，仍然有两个矩形连接区域，只不过重叠了起来。而我们的需求是只有一个矩形双色混合区域来连接两个相邻的地图单元，所以这里要删除其中一个矩形双色混合区域。我们回到<code>HexMesh.Triangulate(HexDirection direction, HexCell cell)</code>方法中。先注释掉所有与构建颜色混合区域和为颜色混合区域顶点赋值的方法。创建一个新的方法，用来专门负责颜色混合区域的构建，这样避免了重复计算，使整个代码结构更加清晰。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3 center = cell.transform.localPosition;</span><br><span class="line">    Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction);</span><br><span class="line">    Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction);</span><br><span class="line"></span><br><span class="line">    AddTriangle(center, v1, v2);</span><br><span class="line">    AddTriangleColor(cell.color);</span><br><span class="line"></span><br><span class="line">    TriangulateConnection(direction, cell, v1, v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 构建cell其中一个三角面片的颜色混合区域</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>颜色混合区域的方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cell&quot;&gt;</span>cell自身实例，用于取得cell位置和颜色 也是三角面片的第一个顶点<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;v1&quot;&gt;</span>自身颜色三角面片 的第二个顶点<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;v2&quot;&gt;</span>自身颜色三角面片 的第三个顶点<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HexCell neighbor = cell.GetNeighbor(direction) ?? cell;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参考图 http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-8-1.png</span></span><br><span class="line">    <span class="comment">//先计算出颜色混合区域的高度，在通过v1 v2计算出v3 v4，这样就知道了矩形颜色混合区域的四个顶点了</span></span><br><span class="line">    Vector3 bridge = HexMetrics.GetBridge(direction);</span><br><span class="line">    Vector3 v3 = v1 + bridge;</span><br><span class="line">    Vector3 v4 = v2 + bridge;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行矩形颜色混合区域的三角面片构建和赋值顶点颜色</span></span><br><span class="line">    AddQuad(v1, v2, v3, v4);</span><br><span class="line">    AddQuadColor(cell.color, neighbor.color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　经过修改，我们就可以很容易的控制在单个地图单元的哪个方向生成颜色混合区域了。现在我们可以尝试只在每个地图单元的NE方向生成颜色混合区域。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (direction == HexDirection.NE)</span><br><span class="line">    &#123;</span><br><span class="line">        TriangulateConnection(direction, cell, v1, v2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-11-2.png"></p>
<p>　　根据运行结果来看，每个地图单元都生成了正确方位的双色混合区域。按照这个思路，其实每个地图单元都只需要生成NE、E和SE方向的双色混合区域就可以了，并且不会有双色混合区域的重合。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (direction &lt;= HexDirection.SE)</span><br><span class="line">    &#123;</span><br><span class="line">        TriangulateConnection(direction, cell, v1, v2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-11-3.png"></p>
<p>　　这样，每个地图单元之间都建立了双色混合区域连接。但是通过运行效果我们发现，在地图边缘处，有些地图单元会生成一些无用的双色混合区域连接。这里可以通过修改<code>TriangulateConnection</code>方法中的代码去掉这些无用的双色混合区域连接。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//HexCell neighbor = cell.GetNeighbor(direction) ?? cell;</span></span><br><span class="line"></span><br><span class="line">    HexCell neighbor = cell.GetNeighbor(direction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当一个方位没有相邻的cell时，不生成双色混合区域</span></span><br><span class="line">    <span class="keyword">if</span> (neighbor == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-11-4.png"></p>
<p>　　最后，我们完成了双色混合区域连接的优化，现在相邻地图单元之间只有两个三角面片组成了双色混合区域，相比之前所用的三角面片减少了一半。在下一章中，我们来优化三色混合区域。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/f6c7cbaba2870fa1d23907486e02e468e003f5cd">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>2-12 优化三色混合区域</title>
    <url>/2020/10/17/HexMap/2-12%20%E4%BC%98%E5%8C%96%E4%B8%89%E8%89%B2%E6%B7%B7%E5%90%88%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>　　在上一章中我们完成了双色混合区域连接的优化，现在来继续完成三色混合区域。根据上一张的思路，三色混合区域依然是在<code>HexMesh.TriangulateConnection</code>方法中处理。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取相邻方位的下一个方位 的cell</span></span><br><span class="line">    HexCell nextNeighbor = cell.GetNeighbor(direction.Next());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里三个彼此相邻的cell都存在的时候，才会创建三角形混合区域</span></span><br><span class="line">    <span class="keyword">if</span> (nextNeighbor != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里注意，最后的v2只是临时占位，并不是三角形的最后一个顶点位置</span></span><br><span class="line">        AddTriangle(v2, v4, v2);</span><br><span class="line">        AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这里注意，在<code>AddTriangle(v2, v4, v2);</code>中，最后的<code>v2</code>并不是三色混合区域中最后的一个顶点位置。我们应该通过第二个相邻地图单元的位置来计算得出这个顶点的位置。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//v2 + HexMetrics.GetBridge(direction.Next()) 为三角形的最后一个顶点位置</span></span><br><span class="line">    <span class="comment">//首先通过HexMetrics.GetBridge(direction.Next()获取 相邻的第二个cell的矩形连接区域宽度，可以理解为一个向量</span></span><br><span class="line">    <span class="comment">//v2顶点位置再加上这个向量，得出了三角形最后一个顶点的位置</span></span><br><span class="line">    AddTriangle(v2, v4, v2 + HexMetrics.GetBridge(direction.Next()));</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-12-1.png"></p>
<p>　　修改完代码之后，虽然视觉效果上基本没有问题了。但是通过分析代码，其实可以发现现在的三色混合区域是有重叠的。为了去掉重叠的三色混合区域，只需要在NE和E方向生成三色混合区域即可。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里三个彼此相邻的cell都存在的时候，才会创建三角形混合区域</span></span><br><span class="line">    <span class="comment">//if (nextNeighbor != null)</span></span><br><span class="line">    <span class="comment">//为了避免三角形混合区域的重叠，这里只需要生成NE和E方位的即可</span></span><br><span class="line">    <span class="keyword">if</span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　修改代码之后，我们就完成了所有连接区域的优化工作。而且也解决了之前边缘处颜色混合视觉效果不正确的问题。在之后的章节中，我们要给现在的地图增加高低差的功能，让地图具有更多的细节和变化。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/2357e5b9b5b38f5157ee5fcb9a99191c9347c97e">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>2-2 链接相邻的力图单元</title>
    <url>/2020/10/07/HexMap/2-2%20%E9%93%BE%E6%8E%A5%E7%9B%B8%E9%82%BB%E7%9A%84%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83/</url>
    <content><![CDATA[<p>　　在上一章节中，我们通过扩展方法，可以计算出一个地图单元自身相对于其周围地图单元的位置，并完善了相关的方法。接下来，我们要将地图内的所有地图单元互相链接起来。<br>　　在<code>HexGrid.cs</code>中使用<code>CreateCell</code>方法创建地图单元的时候，建立每个地图单元之间的位置链接关系。在这里，我们是从左至右逐行查看每个地图单元时，就可以知道已经创建了哪些地图单元，这些创建好的地图单元就是我们要进行链接的地图单元。<br>　　最简单的链接关系就是E-W链接。每一行的第一个地图单元，是没有E方向的相邻地图单元的。除此之外，其他的单元格都是有E方向的相邻单元格。而且这些地图单元都是在我们遍历它们并建立链接之前，就已经被创建好了。所以这里可以很容易的建立所有地图单元的E-W方向的链接。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-2-1.png"></p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为每个cell赋颜色初始值</span></span><br><span class="line">    cell.color = defaultColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断cell是否为每一行第一个</span></span><br><span class="line">    <span class="comment">//如果不是第一个，则cell会有W方位相邻的cell，就可以建立E-W链接</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cell.SetNeighbor(HexDirection.W, cells[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该变量用来存储被实例化的cellLabelPrefab预置</span></span><br><span class="line">    Text label = Instantiate&lt;Text&gt;(cellLabelPrefab);</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-2-2.png"></p>
<p>　　横向的链接关系建立完毕后，我们来看地图单元之间的纵向关系。由于每一行地图单元之间是呈锯齿状交错的，所以建立两行地图单元之间的链接需要不同的处理方法。在这里我们先处理偶数行的SE方向链接。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-2-3.png"></p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为每个cell赋颜色初始值</span></span><br><span class="line">    cell.color = defaultColor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断cell是否为每一行第一个</span></span><br><span class="line">    <span class="comment">//如果不是第一个，则cell会有W方位相邻的cell，就可以建立E-W链接</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cell.SetNeighbor(HexDirection.W, cells[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里判断是否为第一行，因为行之间的链接会不太一样，尤其是第一行，需要做一次额外判断</span></span><br><span class="line">    <span class="keyword">if</span> (z &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里的&amp;为位运算符 MSDN：https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators</span></span><br><span class="line">        <span class="comment">//这里使用位运算符，判断是否为偶数行</span></span><br><span class="line">        <span class="keyword">if</span> ((z &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当为偶数行的时候，创建SE方向的链接</span></span><br><span class="line">            <span class="comment">//cells[1 - width]为SE方向的实例，图片参考 http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-2-3.png</span></span><br><span class="line">            cell.SetNeighbor(HexDirection.SE, cells[<span class="number">1</span> - width]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该变量用来存储被实例化的cellLabelPrefab预置</span></span><br><span class="line">    Text label = Instantiate&lt;Text&gt;(cellLabelPrefab);</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>什么是位运算符？<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/bitwise-and-shift-operators">MSDN连接</a></br><br>大家都知道”&amp;&amp;”是布尔运算符里的”与”运算,”&amp;”就是”按位与”。它们的执行逻辑相同，但后者是对于每一位进行运算。<br>两个Bit都是1,与运算的结果就是1。例如：10101010 &amp; 00001111结果是00001010。<br>从计算机原理层面上来说，所有的数字都是用二进制表示的。二进制中的1、2、3、4写作1、10、11、100。如你所见，表示是否为偶数的最低有效位是第一位。<br>我们把二进制的与运算作为一个遮罩，忽略除了第一位之外的其他位数，如果结果是0，那就表示这是一个偶数。</p>
</blockquote>
<p>　　与SE方向的链接关系类似，这里我们可以使用相同的方法创建SW方向的链接。要注意，每一行的第一个地图单元是没有SW方向的链接的。<br>　　<br><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-2-4.png"></p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里使用位运算符，判断是否为偶数行</span></span><br><span class="line">    <span class="keyword">if</span> ((z &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当为偶数行的时候，创建SE方向的链接</span></span><br><span class="line">        <span class="comment">//cells[i - width]为SE方向的实例，也就是右下方的cell</span></span><br><span class="line">        cell.SetNeighbor(HexDirection.SE, cells[i - width]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每行的第一个cell是没有左下角(SW)方向的链接，这里要判断cell是否为第一个</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cells[i - width - 1]为SW方向的实例，也就是左下方的cell</span></span><br><span class="line">            cell.SetNeighbor(HexDirection.SW, cells[i - width - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　奇数行与偶数行有相同的逻辑，只不过SE-NW、SW-NE方向的链接，与偶数行是相互镜像的。</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里使用位运算符，判断是否为偶数行</span></span><br><span class="line">    <span class="keyword">if</span> ((z &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        …</span><br><span class="line">        <span class="comment">//这里是奇数行建立链接的部分</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//i - width 为自身SW方向的实例</span></span><br><span class="line">            cell.SetNeighbor(HexDirection.SW, cells[i - width]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断奇数行cell是否为每行最后一个，因为奇数行最后一个cell是没有SE方向的实例</span></span><br><span class="line">            <span class="keyword">if</span> (x &lt; width - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//i - width + 1 为奇数行自身SE方向的实例</span></span><br><span class="line">                cell.SetNeighbor(HexDirection.SE, cells[i - width + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　通过以上的代码，我们创建了SE-NW、SW-NE、W-E方向的链接。通过观察可以发现，除了横向的W-E链接，我们都是先创建每个地图单元的SW和SE方向的链接，也就是将自身左下、右下的地图单元实例先进行链接，同时<code>SetNeighbor</code>方法会创建SW和SE的镜像链接，也就是NE和NW链接。所以最特殊的第一行也就和其他的地图单元自动创建了方位链接关系。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-2-5.png"></p>
<p>　　通过观察和代码可以发现，在整个地图系统中，并不是每个地图单元都有全部的6个相邻地图单元，也就是说，在边缘处的地图单元，其Neighbors数组并没有填满。有些边缘处地图单元最多有5个与其相邻的地图单元，最少的则有2个。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-2-6.png"></p>
<p>　　现在，我们已经将所有的地图单元建立了相互的链接关系，这是颜色混合的前置工作之一。接下来会进行一些代码的调整，并实现单元格之间颜色过渡的效果。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/7179c3b1142fb19b7e922def8f85e8fbb74f1a6a">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>2-3 重构部分现有方法</title>
    <url>/2020/10/08/HexMap/2-3%20%E9%87%8D%E6%9E%84%E9%83%A8%E5%88%86%E7%8E%B0%E6%9C%89%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>　　在上一章中，我们创建了地图单元之间的互相链接关系。现在，我们需要利用已经创建好的链接关系，重构一些我们之前需要复杂计算的方法。<br>　　首先回到<code>HexMetrics.cs</code>脚本中，添加两个新的静态方法，用来获取地图单元的顶点位置信息。这样我们就可以将原本的<code>Vector3[] corners</code>枚举设置为私有了。</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Vector3[] corners =</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取cell的direction位置的顶点</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>顶点方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">GetFirstCorner</span>(<span class="params">HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> corners[(<span class="keyword">int</span>)direction];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取cell的direction+1位置的顶点</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>顶点方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">GetSecondtCorner</span>(<span class="params">HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> corners[(<span class="keyword">int</span>)direction + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来回到<code>HexMesh.cs</code>脚本中，在<code>private void Triangulate(HexCell cell)</code>方法中，我们可以替换掉之前使用<code>corners</code>枚举获取顶点的代码。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//private void Triangulate(HexCell cell)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取单个cell的中点位置</span></span><br><span class="line">    Vector3 center = cell.transform.localPosition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据中点位置计算出其余两个顶点的信息</span></span><br><span class="line">    AddTriangle(</span><br><span class="line">        center,</span><br><span class="line">        center + HexMetrics.GetFirstCorner(direction),</span><br><span class="line">        center + HexMetrics.GetSecondCorner(direction)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为有了HexDirection，这里不再直接使用corners枚举来获取cell的顶点位置信息，而使用HexDirection方位来获取</span></span><br><span class="line">    <span class="comment">//根据中点位置计算出其余的顶点位置信息，并按照顺序构建三角面片</span></span><br><span class="line">    <span class="comment">//for (int i = 0; i &lt; 6; i++)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    //构建三角面片</span></span><br><span class="line">    <span class="comment">//    AddTriangle(</span></span><br><span class="line">    <span class="comment">//        center,</span></span><br><span class="line">    <span class="comment">//        center + HexMetrics.corners[i],</span></span><br><span class="line">    <span class="comment">//        center + HexMetrics.corners[i + 1]</span></span><br><span class="line">    <span class="comment">//    );</span></span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最后，我们新建一个<code>Triangulate(HexCell cell)</code>方法，使用HexDirection方位来循环添加单个地图单元的6个点点位置信息。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 使用HexDirection方位，为单个cell循环添加其6个顶点信息</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 此方法之后会进行优化合并</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cell&quot;&gt;</span>单个cell的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (HexDirection d = HexDirection.NE; d &lt;= HexDirection.NW; d++)</span><br><span class="line">    &#123;</span><br><span class="line">        Triangulate(d, cell);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，前置的一些准备工作就完成了，我们将之前直接使用<code>corners</code>枚举的代码，替换为了使用HexDirection方位的代码，避免了一些复杂的计算，也保证了<code>corners</code>的安全性。<br>　　接下来的章节中，我们将开始实现两个地图单元之间颜色混合的功能了。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/b7679f24ac0bec07b992cb7429ad9c785061c601">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>2-4 混合三角面片颜色</title>
    <url>/2020/10/09/HexMap/2-4%20%E6%B7%B7%E5%90%88%E4%B8%89%E8%A7%92%E9%9D%A2%E7%89%87%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<p>　　在上一章中我们因为引入了HexDirection枚举，所以对一些方法进行了重构。接下来需要实现相邻两个地图单元的颜色混合功能。这里首先需要修改<code>HexMesh.cs</code>脚本中的<code>AddTriangleColor</code>方法。这个方法原本的参数只有一个，在构建三角面片的时候，会将这个参数的颜色信息赋值到三角面片的三个顶点信息中。为了实现颜色混合，需要再添加两个参数，让三角面片的每个顶点分别有不同的颜色值。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 为每个三角面片的3个顶点分别赋予不同的颜色值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;c1&quot;&gt;</span>第一个顶点的颜色信息(中心点的颜色)<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;c2&quot;&gt;</span>第二个顶点的颜色信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;c3&quot;&gt;</span>第三个顶点的颜色信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddTriangleColor</span>(<span class="params">Color c1, Color c2, Color c3</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    colors.Add(c1);</span><br><span class="line">    colors.Add(c2);</span><br><span class="line">    colors.Add(c3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，我们在构建三角面片的时候就可以进行颜色的混合了。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//获取与自身当前相邻的cell的颜色值</span></span><br><span class="line">    <span class="comment">//每个cell会在 Triangulate(HexCell cell) 方法中将与自身相邻的cell遍历一次</span></span><br><span class="line">    HexCell neighbor = cell.GetNeighbor(direction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为三角面片的顶点赋颜色值</span></span><br><span class="line">    AddTriangleColor(cell.color, neighbor.color, neighbor.color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　运行以上代码的时候，Unity会产生一个空引用异常。这是因为，并不是每个地图单元都有6个与之相邻的地图单元。所以，这里要进行一次判断。当一个方位上没有地图单元的时候，就用自身的颜色代替。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="comment">//获取与自身当前相邻的cell的颜色值</span></span><br><span class="line">    <span class="comment">//每个cell会在 Triangulate(HexCell cell) 方法中将与自身相邻的cell遍历一次</span></span><br><span class="line">    <span class="comment">//?? 为 可空合并运算符，即cell.GetNeighbor(direction)的值为null时，使用 cell的值</span></span><br><span class="line">    HexCell neighbor = cell.GetNeighbor(direction) ?? cell;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-4-1.png"></p>
<blockquote>
<p>“??”的含义：<br>这被称为可空合并运算符，简单来说”a??b”即”a!=null?a:b”的简写。<br><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/nullable-value-types#conversion-from-a-nullable-value-type-to-an-underlying-type">MSDN连接</a>，“从可为空的值类型转换为基础类型”部分。<br>这里有个小诡计，因为Unity在把一个东西与组件比较时会自定义,(注:Unity中判断一个对象不为空时可以直接写成if(someThings),这在C#原本语法里是没有的)而这个运算符会绕过它并直接与null比较,不过这是销毁对象时才需要考虑的问题。</p>
</blockquote>
<p>　　现在，我们虽然完成了相邻地图单元之间的颜色混合，但是视觉效果显得非常奇怪，完全不是我们想象中的样子。接下来我们需要慢慢解决这些问题。下一章中，我们将会让颜色混合更加平滑。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/ddd6faa23d19d72ca918668864dabaedf2ab35b3">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>2-5 让颜色过渡更加平滑</title>
    <url>/2020/10/10/HexMap/2-5%20%E8%AE%A9%E9%A2%9C%E8%89%B2%E8%BF%87%E6%B8%A1%E6%9B%B4%E5%8A%A0%E5%B9%B3%E6%BB%91/</url>
    <content><![CDATA[<p>　　在上一章中，我们重构了为三角面片赋值颜色的代码，为每个不同的顶点赋值了不同的颜色。实现了最基本的颜色不同切相邻的两个地图单元之间，会有颜色过渡的功能。但是视觉效果上并没有达到我们的预期。在这一章中，我们将优化现在的颜色混合视觉效果，让颜色过渡更加平滑。<br>　　首先，颜色不同切相邻的两个地图单元之间的边界颜色，应该是两个地图单元颜色的平均值。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个相邻的cell，其交界处的颜色应该是两个cell颜色的平均值</span></span><br><span class="line">    Color edgeColor = (cell.color + neighbor.color) * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为三角面片的顶点赋颜色值</span></span><br><span class="line">    <span class="comment">//AddTriangleColor(cell.color, neighbor.color, neighbor.color);</span></span><br><span class="line">    AddTriangleColor(cell.color, edgeColor, edgeColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-5-1.png"></p>
<p>　　经过修改，虽然视觉效果好了一些，但是颜色交界的地方过渡依然显得有些突兀。这是因为在颜色过渡不平滑的位置，会有三个地图单元共享一个顶点位置的颜色，我们之前的方法只是在两两混合颜色。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-5-2.png"></p>
<p>　　按照这个思路，我们在混合N方位地图单元的颜色时，还需要考虑N+1和N-1位置地图单元的颜色。</p>
<figure class="highlight csharp"><figcaption><span>HexDirection.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexDirectionExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取当前相邻cell 之前的一个cell的方位</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>当前相邻cell的方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HexDirection <span class="title">Previous</span>(<span class="params"><span class="keyword">this</span> HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//如果当前cell位置为NE，即索引为0，其之前的一个cell方位应该为NE，即索引为6</span></span><br><span class="line">        <span class="comment">//除此之外的情况，只要当前索引值减1即可</span></span><br><span class="line">        <span class="keyword">return</span> direction == HexDirection.NE ? HexDirection.NW : (direction - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 获取当前相邻cell 之后的一个cell的方位</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>当前相邻cell的方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HexDirection <span class="title">Next</span>(<span class="params"><span class="keyword">this</span> HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//与Previous方法中类似，方位索引为6时，回到0，其余情况则方位索引加1</span></span><br><span class="line">        <span class="keyword">return</span> direction == HexDirection.NW ? HexDirection.NE : (direction + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　现在，我们可以通过新增的两个方法，来获取N+1和N-1位置地图单元的颜色了。然后再分别进行颜色混合。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前相邻方位cell，索引值-1相邻cell的实例</span></span><br><span class="line">    HexCell prevNeighbor = cell.GetNeighbor(direction.Previous()) ?? cell;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取与自身当前相邻的cell的颜色值</span></span><br><span class="line">    <span class="comment">//每个cell会在 Triangulate(HexCell cell) 方法中将与自身相邻的cell遍历一次</span></span><br><span class="line">    <span class="comment">//?? 为 可空合并运算符，即cell.GetNeighbor(direction)的值为null时，使用 cell的值</span></span><br><span class="line">    HexCell neighbor = cell.GetNeighbor(direction) ?? cell;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前相邻方位cell，索引值+1相邻cell的实例</span></span><br><span class="line">    HexCell nextNeighbor = cell.GetNeighbor(direction.Next()) ?? cell;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个相邻的cell，其交界处的颜色应该是两个cell颜色的平均值</span></span><br><span class="line">    <span class="comment">//Color edgeColor = (cell.color + neighbor.color) * 0.5f;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取到相邻方位cell，以及相邻方位cell +1和-1 cell的实例，接下来进行颜色混合</span></span><br><span class="line">    <span class="comment">//三角面片3个顶点颜色分别为</span></span><br><span class="line">    <span class="comment">//自身颜色</span></span><br><span class="line">    <span class="comment">//自身颜色，自身颜色+相邻cell方位减1颜色，相邻cell颜色</span></span><br><span class="line">    <span class="comment">//自身颜色，自身颜色+相邻cell方位加1颜色，相邻cell颜色</span></span><br><span class="line">    AddTriangleColor(</span><br><span class="line">        cell.color,</span><br><span class="line">        (cell.color+prevNeighbor.color+neighbor.color)/<span class="number">3.0f</span>,</span><br><span class="line">        (cell.color+nextNeighbor.color+neighbor.color)/<span class="number">3.0f</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-5-3.png"></p>
<p>　　现在，我们就得到了新的颜色混合效果。但是通过观察发现，在地图边缘的这些地图单元，颜色混合是存在一些问题的。造成这种现象的原因是边缘的单元格缺失了N+1和N-1位置的地图单元，导致了颜色混合还是会有明显的边界。在下一章中，我们需要更换一下思路，来解决这个问题。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/315a3f87f036cfe4c7fc49763a804a79d5d1904f">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>2-6 颜色混合区域</title>
    <url>/2020/10/11/HexMap/2-6%20%E9%A2%9C%E8%89%B2%E6%B7%B7%E5%90%88%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>　　在上一章中我们重构了一部分颜色混合的代码，提升了视觉效果。但是经过观察发现，边缘处的地图单元，颜色混合还是存在一些问题的。而且我们还会发现，在多个颜色互相混合的时候。地图单元自身的颜色会因为混合而变得模糊不清。让我们很难清晰的识别出每一个地图单元。<br>　　为了解决这个问题，我们需要改变一下思路。不再依靠地图单元自身的三角面片来处理颜色渐变的问题，而是在相邻的地图单元之间创建一个颜色混合区域来专门处理这个问题。这样不仅颜色混合区域可以单独处理，代码会更加清晰，而且地图单元也可以保持自身的颜色不会受到颜色混合的影响。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-6-1.png"></p>
<p>　　这里还要注意一点，颜色混合区域和地图单元自身颜色区域的占比不同，会产生不同的视觉效果。在这里，我们先把颜色混合区域设置为地图单元外径的25%。外径便分为了两部分，25%的颜色混合区域和75%的自身颜色区域。</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line">…</span><br><span class="line">    </span><br><span class="line"><span class="comment">//cell自身颜色区域，为75%外接圆半径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> solidFactor = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cell的颜色混合区域，为25%外接圆半径</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> blendFactor = <span class="number">1f</span> - solidFactor;</span><br></pre></td></tr></table></figure>

<p>　　比例设置完成后，我们还需要添加两个静态方法，用来获取地图单元自身颜色区域的顶点信息。</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line">…</span><br><span class="line">    </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取cell自身颜色区域的direction位置的顶点</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>顶点方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">GetFirstSolidCorner</span>(<span class="params">HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> corners[(<span class="keyword">int</span>)direction] * solidFactor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取cell自身颜色区域的direction+1位置的顶点</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>顶点方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">GetSecondSolidCorner</span>(<span class="params">HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> corners[(<span class="keyword">int</span>)direction + <span class="number">1</span>] * solidFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　现在我们在回到<code>HexMesh.Triangulate</code>方法中，修改构建三角面片的代码，让它变成只构建地图单元自身颜色区域的三角面片。</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据中点位置计算出其余两个顶点的信息</span></span><br><span class="line">    AddTriangle(</span><br><span class="line">        center,</span><br><span class="line">        <span class="comment">//center + HexMetrics.GetFirstCorner(direction),</span></span><br><span class="line">        <span class="comment">//center + HexMetrics.GetSecondCorner(direction)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为将颜色混合区域、cell自身颜色区域分开了，这里首先构建cell自身颜色区域的三角面片</span></span><br><span class="line">        center + HexMetrics.GetFirstSolidCorner(direction),</span><br><span class="line">        center + HexMetrics.GetSecondSolidCorner(direction)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-6-2.png"></p>
<p>　　这样我们就完成了将颜色混合区域、地图单元自身颜色区域分开的第第一步了。接下来的一章中，我们要对颜色混合区域进行三角剖分，并创建颜色混合区域。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/6432c20dcc1aac4999c697eac3e70613764d4bf7">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>2-7 创建颜色混合区域</title>
    <url>/2020/10/12/HexMap/2-7%20%E5%88%9B%E5%BB%BA%E9%A2%9C%E8%89%B2%E6%B7%B7%E5%90%88%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>　　在上一章我们完成了地图单元自身颜色区域的构建，但是并没有在颜色上进行修正。这一章中我们要创建颜色混合区域，并让颜色混合区域和地图单元区域都显示正确的颜色。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-7-1.png"></p>
<p>　　通过观察上图可以发现，颜色混合区域是V1、V2、V3、V4这四个顶点所组成的一个四边形区域，也就是两个三角面片组成了这个颜色混合区域。在<code>HexMesh.cs</code>中添加一个三角面片的方法和一个为颜色混合区域顶点添加颜色的方法。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 为每个三角面片的3个顶点赋颜色值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;color&quot;&gt;</span>三角面片顶点的颜色信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddTriangleColor</span>(<span class="params">Color color</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    colors.Add(color);</span><br><span class="line">    colors.Add(color);</span><br><span class="line">    colors.Add(color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 创建颜色混合区域的三角面片定点信息和索引，这个区域是一个四边形，所以有4个顶点</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;v1&quot;&gt;</span>三角面片第一个顶点位置信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;v2&quot;&gt;</span>三角面片第二个顶点位置信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;v3&quot;&gt;</span>三角面片第三个顶点位置信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;v4&quot;&gt;</span>三角面片第四个顶点位置信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddQuad</span>(<span class="params">Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取当前vertices链表中已经录入的数量</span></span><br><span class="line">    <span class="keyword">int</span> vertexIndex = vertices.Count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在vertices链表中添加新增的顶点位置信息</span></span><br><span class="line">    vertices.Add(v1);</span><br><span class="line">    vertices.Add(v2);</span><br><span class="line">    vertices.Add(v3);</span><br><span class="line">    vertices.Add(v4);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在triangles链表中添加新增顶点信息的索引</span></span><br><span class="line">    <span class="comment">//两个三角面片组成了颜色混合区域，分别为：V1V3V2 和 V2V3V4</span></span><br><span class="line">    triangles.Add(vertexIndex);</span><br><span class="line">    triangles.Add(vertexIndex + <span class="number">2</span>);</span><br><span class="line">    triangles.Add(vertexIndex + <span class="number">1</span>);</span><br><span class="line">    triangles.Add(vertexIndex + <span class="number">1</span>);</span><br><span class="line">    triangles.Add(vertexIndex + <span class="number">2</span>);</span><br><span class="line">    triangles.Add(vertexIndex + <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 为四边形颜色混合区域的每个顶点赋值颜色</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;c1&quot;&gt;</span>第一个顶点的颜色信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;c2&quot;&gt;</span>第二个顶点的颜色信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;c3&quot;&gt;</span>第三个顶点的颜色信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;c4&quot;&gt;</span>第四个顶点的颜色信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddQuadColor</span>(<span class="params">Color c1, Color c2, Color c3, Color c4</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    colors.Add(c1);</span><br><span class="line">    colors.Add(c2);</span><br><span class="line">    colors.Add(c3);</span><br><span class="line">    colors.Add(c4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　因为将地图单元和颜色混合区域分开了，接下来需要修改<code>private void Triangulate(HexDirection direction, HexCell cell)</code>方法中的一部分代码，分别构建地图单元自身三角面片和颜色混合区域的面片。并为每个顶点赋值相应的颜色。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这两个Vector3变量，是新的cell自身颜色区域中，两个新的顶点信息，其每个顶点距离cell中心为75%外接圆半径</span></span><br><span class="line">    Vector3 v1 = center + HexMetrics.GetFirstSolidCorner(direction);</span><br><span class="line">    Vector3 v2 = center + HexMetrics.GetSecondSolidCorner(direction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这两个Vector3变量，是原本构成cell一个三角面片的其中两个顶点位置。现在是颜色混合区域的两个顶点位置。</span></span><br><span class="line">    Vector3 v3 = center + HexMetrics.GetFirstCorner(direction);</span><br><span class="line">    Vector3 v4 = center + HexMetrics.GetSecondCorner(direction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用声明的新变量，替换之前计算得出的结果</span></span><br><span class="line">    AddTriangle(center, v1, v2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将计算好的颜色混合区域定点位置信息，添加到添加到链表中</span></span><br><span class="line">    AddQuad(v1, v2, v3, v4);</span><br><span class="line">    </span><br><span class="line">    …  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里为cell的三角面片每个顶点赋值颜色，因为cell自身不再参与颜色混合，所以只有自身颜色</span></span><br><span class="line">    AddTriangleColor(cell.color);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为颜色混合区域的4个顶点分别赋值颜色</span></span><br><span class="line">    <span class="comment">//其中v1 v2是cell自身颜色，v3 v4是混合后的颜色</span></span><br><span class="line">    AddQuadColor(</span><br><span class="line">        cell.color,</span><br><span class="line">        cell.color,</span><br><span class="line">        (cell.color + prevNeighbor.color + neighbor.color) / <span class="number">3.0f</span>,</span><br><span class="line">        (cell.color + nextNeighbor.color + neighbor.color) / <span class="number">3.0f</span></span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-7-2.png"></p>
<p>　　创建了颜色混合区域之后，在视觉效果上有了比较大的提升，现在地图单元既能保持自己的颜色不会被干扰，同时还有专门的颜色混合区域来进行与相邻地图单元的颜色混合。但是我们仔细观察运行结果，还是会发现一些问题，例如当三个相邻切互相颜色不同的地图单元互相进行颜色混合的时候，颜色混合区域会互相干扰，产生一种类似于“溢色”的感觉。在接下来的章节中，我们会进一步拆分颜色混合区域，来解决这个问题。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/4d7f36150f602f29ac941e39efa42fb2dc5482df">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>2-8 创建双色颜色混合区域</title>
    <url>/2020/10/13/HexMap/2-8%20%E5%88%9B%E5%BB%BA%E5%8F%8C%E8%89%B2%E9%A2%9C%E8%89%B2%E6%B7%B7%E5%90%88%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>　　在上一章中，我们将地图单元自身颜色区域和颜色混合区域分开了。但是通过观察运行效果发现，当相邻的多个切颜色互不相同的地图单元进行颜色混合时，会产生类似“溢色”的错误效果。为了解决这个问题，我们现在要吧也是呢混合区域继续进行细分。将它分为双色混合区域和三色混合区域。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-8-1.png"></p>
<p>　　如上图所示，新的V1、V2、V3、V4顶点所构成的区域，就是双色混合区域。这个区域只负责混合2个相邻地图单元的颜色。首先计算出V3、V4中点的位置，然后用该位置乘以颜色混合区域所占比例的数值，就的出来了V1到V3或V2到V4的距离。</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取矩形混合区域中，内边缘顶点到外边缘顶点的距离</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>顶点方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">GetBridge</span>(<span class="params">HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//参考图片 http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-8-1.png</span></span><br><span class="line">    <span class="comment">//(corners[(int)direction] + corners[(int)direction + 1]) * 0.5f 是得出cell相邻两个顶点所连线的中点的位置</span></span><br><span class="line">    <span class="comment">//其实也就是内切圆和cell相切的一个切点，也就是线段V3V4的中点，其实也是角∠(V1 center v2)的角平分线</span></span><br><span class="line">    <span class="comment">//具体可以看图 http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/1-1-3.png 来理解</span></span><br><span class="line">    <span class="comment">//得出V3 V4中点位置后，再乘以颜色混合区域所占比例，即25%，得出V1到V3的距离</span></span><br><span class="line">    <span class="keyword">return</span> (corners[(<span class="keyword">int</span>)direction] + corners[(<span class="keyword">int</span>)direction + <span class="number">1</span>]) * <span class="number">0.5f</span> * blendFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接着再回到<code>HexMesh</code>中，先修改为颜色混合区域顶点赋值的方法，因为只需要混合两个地图单元的颜色，所以参数修改为2个。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 为四边形颜色混合区域的每个顶点赋值颜色</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 因为该区域只负责混合2个cell的颜色，所以4个顶点只需要2个颜色</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;c1&quot;&gt;</span>cell祖神颜色<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;c2&quot;&gt;</span>混合后的颜色<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddQuadColor</span>(<span class="params">Color c1, Color c2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    colors.Add(c1);</span><br><span class="line">    colors.Add(c1);</span><br><span class="line">    colors.Add(c2);</span><br><span class="line">    colors.Add(c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最后回到<code>private void Triangulate(HexDirection direction, HexCell cell)</code>方法中，修改构建颜色混合区域的代码。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//颜色混合区域变为了矩形，V3和V4的位置，其实是通过V1和V2顶点分别加上矩形区域的高来计算得出的</span></span><br><span class="line">    <span class="comment">//具体可以查看HexMetrics.GetBridge方法的说明</span></span><br><span class="line">    Vector3 bridge = HexMetrics.GetBridge(direction);</span><br><span class="line">    Vector3 v3 = v1 + bridge;</span><br><span class="line">    Vector3 v4 = v2 + bridge;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//新的矩形颜色混合区域顶点颜色赋值</span></span><br><span class="line">    AddQuadColor(cell.color, (cell.color + neighbor.color) * <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-8-2.png"></p>
<p>　　现在我们就完成了两个相邻地图单元之间的颜色混合功能。接下来的一章中，我们将实现3个彼此相邻地图单元的颜色混合区域，也就是要混合三种颜色的区域。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/c9c8c9400b6d399c5c9010c1b99f74b51afa0137">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>2-9 创建3色颜色混合区域</title>
    <url>/2020/10/14/HexMap/2-9%20%E5%88%9B%E5%BB%BA3%E8%89%B2%E9%A2%9C%E8%89%B2%E6%B7%B7%E5%90%88%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>　　在上一章中我们创建了两种颜色的混合区域，而且在运行中的视觉效果也是符合预期的。在这一章中，我们来创建三种颜色的混合区域。这里的三色混合区域，就是上一章中所空出来的三角形区域。这个三角形区域目前是由6个三角面片组成的。也就是上一章中，除了矩形颜色混合区域，其两侧未进行构建的部分。<br>　　在这里我们先构建矩形颜色混合区域左侧的三角形。其顶点位置已经都计算出来了，现在主要是分析顶点颜色的问题。第一个顶点的颜色是地图单元自身的颜色，第二个顶点的颜色是三个相邻地图三个颜色的混合值，第三个顶点的颜色是双色混合区域的颜色的平均值。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//矩形两色混合区域的中间过渡色</span></span><br><span class="line">    Color bridgeColor = (cell.color + neighbor.color) * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新的矩形颜色混合区域顶点颜色赋值</span></span><br><span class="line">    AddQuadColor(cell.color, bridgeColor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//组成cell的每个三角形区域，有1个矩形混色区域和2个三角形三色混合区域</span></span><br><span class="line">    <span class="comment">//生成其中一个三角形三色混合区域</span></span><br><span class="line">    AddTriangle(v1, center + HexMetrics.GetFirstCorner(direction), v3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为第一个三角形三色混合区域赋值颜色</span></span><br><span class="line">    <span class="comment">//自身颜色、三个相邻cell的平均色、矩形混合区域中间色</span></span><br><span class="line">    AddTriangleColor(</span><br><span class="line">        cell.color,</span><br><span class="line">        (cell.color + prevNeighbor.color + neighbor.color) / <span class="number">3f</span>,</span><br><span class="line">        bridgeColor</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-9-1.png"></p>
<p>　　使用同样的方式，我们使用相同的方式来生成矩形颜色混合区域右侧侧的三角形。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二个三角形三色混合区域</span></span><br><span class="line">    AddTriangle(v2, v4, HexMetrics.GetSecondCorner(direction));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二个三角形三色混合区域的颜色</span></span><br><span class="line">    AddTriangleColor(</span><br><span class="line">        cell.color,</span><br><span class="line">        bridgeColor,</span><br><span class="line">        (cell.color + prevNeighbor.color + neighbor.color) / <span class="number">3f</span></span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/2-9-2.png"></p>
<p>　　现在我们就得到了比之前更好的视觉效果。而且我们还可以自定义颜色混合区域的面积大小，来改变整个地图的视觉效果。但是我们发现，在地图边缘处相邻地图单元的颜色过渡依然存在一些问题。不过我们先暂时忽略这个问题，把注意力放在优化和网格合并上。</p>
<blockquote>
<p>为什么有了颜色混合区域，混合后的效果依然不好看？<br>这是线性颜色混合的极限了。事实上纯色之间的颜色混合效果都不是很好，未来的章节中将会升级到地形材质并做一些更漂亮的混合。</p>
</blockquote>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/424789c59c98b442ddb87db3c92f362cf00452af">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-1 地图单元的高度属性</title>
    <url>/2020/10/18/HexMap/3-1%20%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E7%9A%84%E9%AB%98%E5%BA%A6%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>　　在之前的章节中，我们完成了地图单元之间颜色混合的功能，并优化了显示和效率。现在的地图虽然可以显示自定义颜色，但细节还是不够丰富。在接下来的章节中，我们将为现在的地图系统添加单元格高度的功能，让整个地图系统的细节更加丰富。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-1-1.png"></p>
<p>　　为了给地地图单元增加高度功能，就要给每个地图单元增加一个高度属性，这里我们用一个<code>int</code>类型的变量来表示每个地图单元的高度。</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//表示每个cell的高度等级，0即在水平面位置上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> elevation;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，我们还要设置每一级高度，具体是多少。这个数值可以用一个常量来表示。现在我们先暂时使用Unity3D中5个标准单位来作为每一级的高度值。这样高低变化看起来会比较明显，在之后的步骤中也可以根据视觉效果来及时调整。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexMetrics</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//地图中每个高度等级之间相差的实际距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> elevationStep = <span class="number">5f</span>;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/c725150de62a039cfe89003a5c9fe91c30e17f01">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-10 三角形连接区域类型分析</title>
    <url>/2020/10/27/HexMap/3-10%20%E4%B8%89%E8%A7%92%E5%BD%A2%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%9F%9F%E7%B1%BB%E5%9E%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>　　在上一章中，我们通过判断两个地图单元的高低差，实现了只对Slope类型的连接区域进行阶梯化。接下来，就是要将三角形连接区域进行阶梯化。<br>　　相比于矩形连接区域，三角形连接区域的阶梯化会更加复杂，因为它连接了3个地图单元。这三个地图单元可能是任意高度，每两个地图单元之间的高差类型也是任意的。所以需要在<code>HexMesh.cs</code>中另外添加一个三角形连接区域的专用方法。<br>　　首先，我们先将三角形连接区域相邻的三个地图单元进行分类，分别为Left、Right和Bittom。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-10-1.png"></p>
<p>　　接下来，在新增加的方法中，我们先获取这三个地图单元的位置坐标和其颜色，方便之后进行阶梯化计算。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 构建三角形连接区域的方法</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 判断相邻3个cell高低的工作，在TriangulateConnection方法中实现了，这里只负责创建连接区域</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 注意，TriangulateConnection方法只是对入参的顺序做了调整，但是并没有告知3个cell之间相对的连接类型</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 所以要在这个方法中对连接类型进行判断，这样才能决三角形连接区域定用什么方式进行三角剖分</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;bottom&quot;&gt;</span>bottom cell的坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;bottomCell&quot;&gt;</span>bottom cell的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;left&quot;&gt;</span>left cell的坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;leftCell&quot;&gt;</span>left cell的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;right&quot;&gt;</span>right cell的坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rightCell&quot;&gt;</span>right cell的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCorner</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 bottom, HexCell bottomCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里先使用旧的方法来构建三角形连接区域，也就是没有阶梯化的那种</span></span><br><span class="line">    <span class="comment">//经过连接类型判断后，这个方法就会被代替掉</span></span><br><span class="line">    AddTriangle(bottom, left, right);</span><br><span class="line">    AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们回到<code>TriangulateConnection</code>方法中，在这个方法中，我们要判断与三角形连接区域相邻的三个地图单元，哪一个是最低的。<br>　　这里要注意一点，结合上图，我们现在只是判断哪个地图单元的高度最低，而不是对这三个地图单元的高度进行排序。因为一个三角形连接区域的三个地图单元，其坐标是固定的，当确定了哪个地图单元是最低的一个时，剩下两个的顺序其实就是固定的了。所以不存在排序问题。整理后的逻辑图如下：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-10-2.png"></p>
<p>　　根据整理后的逻辑图可以发现，判断最低的地图单元，实际上就是将图1中的3个地图单元进行顺时针或逆时针的旋转。<br>　　首先我们先检查第一个地图单元的高度，如果它小于其他两个地图单元，那么它就是最低的一个。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参考图 http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-10-1.png</span></span><br><span class="line">        <span class="comment">//这里要注意，只是要找出3个cell中高度最低的一个</span></span><br><span class="line">        <span class="comment">//因为三角形连接区域的3个cell，其坐标是固定的，找出最低的一个时，其他两个cell的入参顺序就是固定的了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//注意，教程4.1是有错误的但是最后给的代码是对的，这里注释掉的语句是教程错误的语句</span></span><br><span class="line">        <span class="keyword">if</span> (cell.Elevation &lt;= neighbor.Elevation)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//并且cell1高度小于cell3</span></span><br><span class="line">            <span class="keyword">if</span> (cell.Elevation &lt;= nextNeighbor.Elevation)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//cell1最低</span></span><br><span class="line">                <span class="comment">//TriangulateCorner(v2, cell, v4, nextNeighbor, v5, nextNeighbor);</span></span><br><span class="line">                TriangulateCorner(v2, cell, v4, neighbor, v5, nextNeighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　如果<code>cell</code>的高度大于<code>nextNeighbor</code>的高度，说明<code>nextNeighbor</code>的高度最低。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cell.Elevation &lt;= neighbor.Elevation)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//并且cell1高度小于cell3</span></span><br><span class="line">            <span class="keyword">if</span> (cell.Elevation &lt;= nextNeighbor.Elevation)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//cell1最低</span></span><br><span class="line">                <span class="comment">//TriangulateCorner(v2, cell, v4, nextNeighbor, v5, nextNeighbor);</span></span><br><span class="line">                TriangulateCorner(v2, cell, v4, neighbor, v5, nextNeighbor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="comment">//cell3 最低</span></span><br><span class="line">                <span class="comment">//TriangulateCorner(v5, nextNeighbor, v2, cell, v4, nextNeighbor);</span></span><br><span class="line">                TriangulateCorner(v5, nextNeighbor, v2, cell, v4, neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最后，如果<code>cell</code>高度大于<code>neighbor</code>，那么只需要检测<code>neighbor</code>和<code>nextNeighbor</code>之间的高度就可以了。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cell.Elevation &lt;= neighbor.Elevation)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//并且cell1高度小于cell3</span></span><br><span class="line">            <span class="keyword">if</span> (cell.Elevation &lt;= nextNeighbor.Elevation)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//cell1最低</span></span><br><span class="line">                <span class="comment">//TriangulateCorner(v2, cell, v4, nextNeighbor, v5, nextNeighbor);</span></span><br><span class="line">                TriangulateCorner(v2, cell, v4, neighbor, v5, nextNeighbor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;   </span><br><span class="line">                <span class="comment">//cell3 最低</span></span><br><span class="line">                <span class="comment">//TriangulateCorner(v5, nextNeighbor, v2, cell, v4, nextNeighbor);</span></span><br><span class="line">                TriangulateCorner(v5, nextNeighbor, v2, cell, v4, neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果cell1&gt;cell2，且cell2&lt;cell3</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (neighbor.Elevation &lt;= nextNeighbor.Elevation)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cell2最低</span></span><br><span class="line">            <span class="comment">//TriangulateCorner(v4, nextNeighbor, v5, nextNeighbor, v2, cell);</span></span><br><span class="line">                TriangulateCorner(v4, neighbor, v5, nextNeighbor, v2, cell);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//cell3最低</span></span><br><span class="line">            <span class="comment">//TriangulateCorner(v5, nextNeighbor, v2, cell, v4, nextNeighbor);</span></span><br><span class="line">            TriangulateCorner(v5, nextNeighbor, v2, cell, v4, neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，我们就找到了三角形连接区域中，高度最低的那个地图单元了。在接下来的章节中，我们会在这个基础上，使用循环来对三角形连接区域进行阶梯化，根据不同的高差类型，来构建不同的三角形连接区域外观。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/3123f3f1b2b8e4abc3a6c64357b208b570ec7874">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-11 Slope类型的三角形连接区域构建</title>
    <url>/2020/10/28/HexMap/3-11%20slope%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%B8%89%E8%A7%92%E5%BD%A2%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%9F%9F%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<p>　　在上一章中，我们对一个三角形连接区域，相邻的三个地图单元高度进行了分析，通过判断和比较，知道了三个地图单元中，哪个地图单元最高，哪个底图单元最低。<br>　　再结合之前章节中对高度差的分类，我们现在就可以对三角形连接区域进行构建了。不过因为高度差不同，所以三角形连接区域的构建也有很多种类。这里我们需要分类进行实现。<br>　　我们要构建三角形链接区域，首先需要知道我们处理的是哪种连接区域类型，在<code>HexCell.cs</code>中添加一个新的方法，来回去两个单元格之间对连接类型</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 对比自身和另一个cell的高度，返回两个cell的连接类型</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;otherCell&quot;&gt;</span>另一个cell的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>两个cell的连接类型<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HexEdgeType <span class="title">GetEdgeType</span>(<span class="params">HexCell otherCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> HexMetrics.GetEdgeType(elevation, otherCell.elevation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　在<code>HexMesh.TriangulateCorner</code>方法中，使用<code>GetEdgeType</code>确认相邻的Left和Right地图单元的连接类型。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCorner</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 bottom, HexCell bottomCell, </span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell, </span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里先获取Left和Right两个cell，相较于Bottom cell的高度类型，这样才能决定怎样做三角剖分</span></span><br><span class="line">    HexEdgeType leftEdgeType = bottomCell.GetEdgeType(leftCell);</span><br><span class="line">    HexEdgeType rightEdgeType = bottomCell.GetEdgeType(rightCell);</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　如果Left和Right两个地图单元，相较于Bottom对连接类型都是<code>Slope</code>类型。那么就说明，Left和Right两个地图单元高度是相同的，他们两者之间的连接类型是<code>Flat</code>。而且Left和Right两个地图单元与Bottom地图单元对矩形连接区域，都是阶梯状的。我们称这种连接类型为<code>Slope-Slope-Slat</code>，或者简称<code>SSF</code>。如图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-11-1.png"></p>
<p>　　为了方便观察新构建的三角形连接区域，我们将之前的构建三角形连接区域的语句注释掉，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCorner</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 bottom, HexCell bottomCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AddTriangle(bottom, left, right);</span></span><br><span class="line">    <span class="comment">//AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//AddTriangle(v2, v4, v5);</span></span><br><span class="line">    <span class="comment">//AddTriangleColor(cell.color, neighbor.color, nextNeighbor.color);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，我们创建一个新的方法<code>TriangulateCornerTerraces</code>，这个方法专门用来创建阶梯状的三角形连接区域。如果在<code>TriangulateConnection</code>方法中判断两个相邻的地图单元难道连接类型为<code>SSF</code>，那么就调用这个方法。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCorner</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 bottom, HexCell bottomCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里通过获取的Left和Right 相较于Bottom的连接类型进行判断，具体三个cell的高度关系</span></span><br><span class="line">    <span class="comment">//判断完成后，直接调用对应的方法构建三角形连接区域，而不使用之前通用的方法构建</span></span><br><span class="line">    <span class="keyword">if</span> (leftEdgeType == HexEdgeType.Slope)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rightEdgeType == HexEdgeType.Slope)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里判断为SSF类型</span></span><br><span class="line">            TriangulateCornerTerraces(bottom, bottomCell, left, leftCell, right, rightCell);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 创建阶梯状的三角形连接区域</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;begin&quot;&gt;</span>初始cell位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;beginCell&quot;&gt;</span>初始cell实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;left&quot;&gt;</span>左侧cell位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;leftCell&quot;&gt;</span>左侧cell实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;right&quot;&gt;</span>右侧cell位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rightCell&quot;&gt;</span>右侧cell实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerTerraces</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin,HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　在Unity中运行代码，会看到现在符合<code>SSF</code>类型的连接，三角形连接区域是一个洞，这表明在洞的位置，我们调用了<code>TriangulateCornerTerraces</code>方法，而不是默认构建三角形连接区域的方法，如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-11-2.png"></p>
<p>　　现在让我们用阶梯化的三角形连接区域填补上这个洞。要填补这个洞，就需要连接左右两个地图单元的矩形阶梯化连接区域。思路与创建矩形阶梯化连接区域基本相同，先从底部第一个阶梯开始构建。只不过顶点需要从左右两边的阶梯状矩形连接区域获取。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerTerraces</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin,HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//计算出与begin相邻的两个cell，每个阶梯的顶点和其对应的颜色</span></span><br><span class="line">    Vector3 v3 = HexMetrics.TerraceLerp(begin, left, <span class="number">1</span>);</span><br><span class="line">    Vector3 v4 = HexMetrics.TerraceLerp(begin, right, <span class="number">1</span>);</span><br><span class="line">    Color c3 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="number">1</span>);</span><br><span class="line">    Color c4 = HexMetrics.TerraceLerp(beginCell.color, rightCell.color, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与矩形阶梯区域不同的是，阶梯三角形连接区域最下端是一个三角形，这里先构建这个三角形</span></span><br><span class="line">    AddTriangle(begin, v3, v4);</span><br><span class="line">    AddTriangleColor(beginCell.color, c3, c4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，我们就得到了底部的第一段阶梯，如图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-11-3.png"></p>
<p>　　与阶梯化矩形连接区域步骤相同，我们直接进行最后一步的构建，将第一段阶梯的两个顶点，和末端的两个顶点相连接，组成一个梯形。这里与阶梯化矩形区域不同的是，梯形的4个端点颜色是不同的，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerTerraces</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin,HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建剩余的部分</span></span><br><span class="line">    AddQuad(v3, v4, left, right);</span><br><span class="line">    AddQuadColor(c3, c4, leftCell.color, rightCell.color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-11-4.png"></p>
<p>　　最后，与构建阶梯矩形连接区域类似，循环获取阶梯上的各个顶点和颜色值，创建各个阶梯矩形区域即可。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerTerraces</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin,HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环获取中间部分的顶点位置和颜色信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; HexMetrics.terraceSteps; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 v1 = v3;</span><br><span class="line">        Vector3 v2 = v4;</span><br><span class="line">        Color c1 = c3;</span><br><span class="line">        Color c2 = c4;</span><br><span class="line">        v3 = HexMetrics.TerraceLerp(begin, left, i);</span><br><span class="line">        v4 = HexMetrics.TerraceLerp(begin, right, i);</span><br><span class="line">        c3 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i);</span><br><span class="line">        c4 = HexMetrics.TerraceLerp(beginCell.color, rightCell.color, i);</span><br><span class="line">        AddQuad(v1, v2, v3, v4);</span><br><span class="line">        AddQuadColor(c1, c2, c3, c4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-11-5.png"></p>
<p>　　这样，我们就完成了<code>SSF</code>类型连接区域的构建。不过<code>SSF</code>类型还存在一些变体情况，我们在下一个章节进行完善。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/566fa2e2e4e1d0894b0df0cec93fdc0742b43be6">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-12 SSF类型的变体</title>
    <url>/2020/10/29/HexMap/3-12%20SSF%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8F%98%E4%BD%93/</url>
    <content><![CDATA[<p>　　在上一章中，我们完成了<code>SSF</code>类型的三角形连接区域阶梯化，不过<code>SSF</code>类型还存在两种变体，如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-12-1.png"></p>
<p>　　之前的普通<code>SSF</code>连接类型中，两个连接类型为Flat的地图单元，它们相较另一个地图单元，都会高出一个单位。变体的情况其实是正好反过来的。两个连接类型为Flat的地图单元，比另外一个地图单元，都低一个单位，这样也能组成<code>SSF</code>形式的连接。那么我们就这种情况，在<code>TriangulateCorner</code>方法中进行判断，如果符合<code>SSF</code>变体的情况，我们也试用阶梯化三角形连接区域进行构建。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCorner</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 bottom, HexCell bottomCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leftEdgeType == HexEdgeType.Slope)</span><br><span class="line">        &#123;</span><br><span class="line">            …</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//SSF变体1 即2个cell高度为0，一个cell高度为1，且高度为1的cell在左侧</span></span><br><span class="line">            <span class="keyword">if</span> (rightEdgeType == HexEdgeType.Flat)</span><br><span class="line">            &#123;</span><br><span class="line">                TriangulateCornerTerraces(left, leftCell, right, rightCell, bottom, bottomCell);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rightEdgeType == HexEdgeType.Slope)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//SSF变体2 即2个cell高度为0，一个cell高度为1，且高度为1的cell在右侧</span></span><br><span class="line">            <span class="keyword">if</span> (leftEdgeType == HexEdgeType.Flat)</span><br><span class="line">            &#123;</span><br><span class="line">                TriangulateCornerTerraces(right, rightCell, bottom, bottomCell, left, leftCell);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　仔细观察代码，当下方和右侧的两个地图单元连接关系为Flat时，我们就要对左侧的地图单元三角形连接区域进行梯形构建。相反的另一种情况也类似。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-12-2.png"></p>
<p>　　现在，两个相邻地图单元高度相差1的话，他们之间的矩形连接区域和三角形连接区域，视觉效果都完全符合预期。现在的问题还存在于两个相邻地图单元高度差大于1的情况。他们之间的三角形连接区域还是使用之前的方式。在下面的章节中，我们将会一步一步来解决这些问题。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/49185d87cfdf0e9b3d409d8932b02e7bc3baf934">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-13 Slope-Cliff类型三角形连接区域的判断</title>
    <url>/2020/10/30/HexMap/3-13%20Slope-Cliff%E7%B1%BB%E5%9E%8B%E4%B8%89%E8%A7%92%E5%BD%A2%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<p>　　在之前的章节中，我们完成了<code>SSF</code>及其变体的情况中，三角形连接区域的阶梯化构建。<code>SSF</code>及其变体，都是高度相差1的情况，在这章中我们来解决地图单元之间高度差大于1的情况。<br>　　Slope-Cliff连接类型有两种情况，第一种是：bottom地图单元高度最低，left地图单元比bottom地图单元高1个单位，right地图单元比Left地图单元高1个单位。如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-13-1.png"></p>
<p>　　第二种是：bottom地图单元高度最低，left地图单元比bottom地图单元高1个单位，right地图单元比Left地图单元高1个以上单位。如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-13-2.png"></p>
<p>　　这两种组合的抽象图如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-13-3.png"></p>
<p>　　接下来回到代码部分，构建Slope-Cliff的三角形连接区域的思路与<code>SSF</code>连接区域类似，我们在<code>HexMesh.cs</code>脚本中创建一个新的方法，来构建三角形连接区域，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 针对Slope-Cliff连接类型 创建三角形连接区域</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;begin&quot;&gt;</span>初始cell位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;beginCell&quot;&gt;</span>初始cell实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;left&quot;&gt;</span>左侧cell位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;leftCell&quot;&gt;</span>左侧cell实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;right&quot;&gt;</span>右侧cell位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rightCell&quot;&gt;</span>右侧cell实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerTerracesCliff</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们回到<code>TriangulateCorner</code>方法中，在这里添加对<code>TriangulateCornerTerracesCliff</code>的调用。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCorner</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 bottom, HexCell bottomCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftEdgeType == HexEdgeType.Slope)</span><br><span class="line">    &#123;</span><br><span class="line">        …</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//Slope-Cliff连接类型</span></span><br><span class="line">        <span class="comment">//bottom最低，left比bottom高1，right比bottom高2及以上</span></span><br><span class="line">        TriangulateCornerTerracesCliff(bottom, bottomCell, left, leftCell, right, rightCell);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，我们就完成了Slope-Cliff三角形连接区域的判断。不过因为left的地图单元和right的地图单元，高度差可能为1，也可能大于1，所以Slope-Cliff三角形连接区域需要分类两个步骤进行构建，这两部分的构建，在接下来的章节实现。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/cee3495b41878ea898a16bfa55eefa762d1ec6fd">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-14 Slope-Cliff类型三角形连接区域构建 底部区域</title>
    <url>/2020/10/31/HexMap/3-14%20Slope-Cliff%E7%B1%BB%E5%9E%8B%E4%B8%89%E8%A7%92%E5%BD%A2%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%9F%9F%E6%9E%84%E5%BB%BA%20%E5%BA%95%E9%83%A8%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>　　在上一章中，我们创建了Slope-Cliff三角形连接区域的方法。在这里要注意，Slope-Cliff类型与<code>SSF</code>类型不同，因为我们不知道的left和right地图单元之间，高度差是等于1还是大于1的，但是我们能确定的一点是left与bottom地图单元之间的高度差为1。根据下图我们发现，不论right的高度如何变化，三角形连接区域的一条边始终是需要进行阶梯化的。所以我们就将Slope-Cliff的三角形连接区域分为两部分进行构建。这里先从一定会阶梯化的底部开始。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-13-1.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-13-2.png"></p>
<p>　　对这部分进行构建，也有两种情况。第一种如下图所示，三角形的其中一条边与阶梯部分相连，被分成若干段。这条边上分段的顶点与三角形的另一个顶点相连，这样就完成了三角剖分。但是这样的构建方法会让三角形连接区域中，视觉效果比较差，例如三角形连接区域中，分段相同，但是一条边上断电稀疏，但是越靠近三角形的一个角的时候越密集。而且在之后进行上半段构建的时候，这个情况会被放大。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-14-1.png"></p>
<p>　　那么解决这个问题的方法，就是在三角形的一条边上取一个点，所有阶梯化的端点，够与这个点相连接，这样既将三角形连接区域分为了两部分，又不会出现顶点向一处汇聚，显得太过拥挤。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-14-2.png"></p>
<p>　　既然找出了一个比较合理的解决方案，那么我们就需要知道三角形上的这个点的具体位置怎么得出。这里是使用了bottom和right两个地图单元的高度差进行插值得到的。也就是最低的地图单元和最高的地图单元之间的高度差，在进行插值，计算出三角形上这个点及其对应的颜色。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerTerracesCliff</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里将Slope-Cliff类型的三角形连接区域拆分成两部分进行构建</span></span><br><span class="line">    <span class="comment">//示意图 http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-14-2.png</span></span><br><span class="line">    <span class="comment">//即三角形一个边进行阶梯化，阶梯化后的端点，都与另一条边上的一点相连</span></span><br><span class="line">    <span class="comment">//边上一点，是通过bottom与right高度差，在进行插值得到的</span></span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">1f</span> / (rightCell.Elevation - beginCell.Elevation);</span><br><span class="line">    Vector3 boundary = Vector3.Lerp(begin, right, b);</span><br><span class="line">    Color boundaryColor = Color.Lerp(beginCell.color, rightCell.color, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　计算出了三角形连接区域边上一点，那么我们来构建一个三角形，观察一下这个点是否正确。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerTerracesCliff</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//测试通过插值找到的三角形上一点是否正确</span></span><br><span class="line">    AddTriangle(begin, left, boundary);</span><br><span class="line">    AddTriangleColor(beginCell.color, leftCell.color, boundaryColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-14-3.png"></p>
<p>　　我们确定了三角形连接区域边上一点没有问题，那么接下来就要构建这个区域了。与之前构建<code>SSF</code>三角形连接区域类似，首先构建起始的一个三角面片。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerTerracesCliff</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//与构建其他阶梯状区域类似，首先构建第一个三角面片</span></span><br><span class="line">    Vector3 v2 = HexMetrics.TerraceLerp(begin, left, <span class="number">1</span>);</span><br><span class="line">    Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    AddTriangle(begin, v2, boundary);</span><br><span class="line">    AddTriangleColor(beginCell.color, c2, boundaryColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-14-4.png"></p>
<p>　　然后直接将剩余的区域直接构建为一个三角面片。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerTerracesCliff</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建剩余区域</span></span><br><span class="line">    AddTriangle(v2, left, boundary);</span><br><span class="line">    AddTriangleColor(c2, leftCell.color, boundaryColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-14-5.png"></p>
<p>　　接着我们循环构建中间部分的三角面片，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerTerracesCliff</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; HexMetrics.terraceSteps; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 v1 = v2;</span><br><span class="line">        Color c1 = c2;</span><br><span class="line">        v2 = HexMetrics.TerraceLerp(begin, left, i);</span><br><span class="line">        c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i);</span><br><span class="line">        AddTriangle(v1, v2, boundary);</span><br><span class="line">        AddTriangleColor(c1, c2, boundaryColor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建剩余区域</span></span><br><span class="line">    AddTriangle(v2, left, boundary);</span><br><span class="line">    AddTriangleColor(c2, leftCell.color, boundaryColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-14-6.png"></p>
<p>　　这样，我们在三角形连接区域的一条边上，通过插值计算出了一个点，利用这个点将三角形连接区域拆分成了两个部分。并完成了三角形连接区域底部的构建工作。在下一章中，我们将完成顶部的构建。</p>
<blockquote>
<p>为什么底部不能像<code>SSF</code>那样使用阶梯的方式构建，而使用三角形进行构建？<br>如果我们对这部分区域进行类似<code>SSF</code>那种阶梯状方式构建，而不是三角面片构建。这就需要分析计算得出的插值点。因为插值点是跟bottom与right的高度差有关，而两者的高度差并不固定，所以这可能导致每个阶梯的四边形，并不在一个平坦的平面上，也就是说一个四边形左右两侧的斜率不同，这样不仅看起来四边形会被拉伸，而且市局效果会很乱。</p>
</blockquote>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/2916e9bca3f22daf1336f8c44a9387b8346f069d">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-15 Slope-Cliff类型三角形连接区域构建 顶部区域</title>
    <url>/2020/11/01/HexMap/3-15%20Slope-Cliff%E7%B1%BB%E5%9E%8B%E4%B8%89%E8%A7%92%E5%BD%A2%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%9F%9F%E6%9E%84%E5%BB%BA%20%E9%A1%B6%E9%83%A8%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>　　在上一章中我们完成了Slope-Cliff三角形连接区域底部的构建，这一章中我们来完成顶部的构建。首先我们将之前对底部进行构建的代码单独提出来，封装成一个方法，这样在之后处理变体的情况是，可以进行复用。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerTerracesCliff</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建底部三角面片</span></span><br><span class="line">    TriangulateBoundaryTriangle(begin, beginCell, left, leftCell, boundary, boundaryColor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> Slope-Cliff连接类型种 创建底部区域</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;begin&quot;&gt;</span>初始cell位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;beginCell&quot;&gt;</span>初始cell实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;left&quot;&gt;</span>左侧cell位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;leftCell&quot;&gt;</span>左侧cell实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;right&quot;&gt;</span>右侧cell位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rightCell&quot;&gt;</span>右侧cell实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateBoundaryTriangle</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 boundary, Color boundaryColor</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3 v2 = HexMetrics.TerraceLerp(begin, left, <span class="number">1</span>);</span><br><span class="line">    Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    AddTriangle(begin, v2, boundary);</span><br><span class="line">    AddTriangleColor(beginCell.color, c2, boundaryColor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; HexMetrics.terraceSteps; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 v1 = v2;</span><br><span class="line">        Color c1 = c2;</span><br><span class="line">        v2 = HexMetrics.TerraceLerp(begin, left, i);</span><br><span class="line">        c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i);</span><br><span class="line">        AddTriangle(v1, v2, boundary);</span><br><span class="line">        AddTriangleColor(c1, c2, boundaryColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AddTriangle(v2, left, boundary);</span><br><span class="line">    AddTriangleColor(c2, leftCell.color, boundaryColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，我们判断left和right地图单元的高度关系，如果两者的高度关系为Slope，那么我们就直接使用<code>TriangulateBoundaryTriangle</code>方法构建顶部区域即可，只是入参变为了left与right之间矩形阶梯连接区域的顶点。而如果两者的高度关系为Cliff，那么我们直接用一个三角面片填补这个区域就可以了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerTerracesCliff</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果left和right的高度关系为Slope，也就是高度差1</span></span><br><span class="line">    <span class="comment">//那么就使用构建底部构建三角面片的方法，只不过入参是上下翻转的</span></span><br><span class="line">    <span class="keyword">if</span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope)</span><br><span class="line">    &#123;</span><br><span class="line">        TriangulateBoundaryTriangle(left, leftCell, right, rightCell, boundary, boundaryColor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果left和right的高度关系为Cliff，也就是高度差大于1</span></span><br><span class="line">    <span class="comment">//那么直接只用一个三角面片填补这个区域即可</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        AddTriangle(left, right, boundary);</span><br><span class="line">        AddTriangleColor(leftCell.color, rightCell.color, boundaryColor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-15-1.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-15-2.png"></p>
<p>　　接这样，我们就完成了Slope-Cliff类型的三角形连接区域的构建，在接下来的章节中，我们将处理Slope-Cliff类型的变体，也就是对称组合的三角形连接区域。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/d12649c05e1c4d5ee67e00f619b5d2e6d29091c2">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-16 Slope-Cliff类型镜像组合</title>
    <url>/2020/11/02/HexMap/3-16%20Slope-Cliff%E7%B1%BB%E5%9E%8B%E9%95%9C%E5%83%8F%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p>　　在上一章中，我们完成了Slope-Cliff类型三角形连接区域的构建，在这一章中，我们将完成Slope-Cliff类型的镜像组合中，三角形连接区域的构建。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-16-1.png"></p>
<p>　　这部分所使用到的代码，我们可以参考构建Slope-Cliff类型三角形连接区域所用到的代码。只不过构建三角形时，顺序有所不同。我们创建一个新的<code>TriangulateCornerCliffTerraces</code>方法，其内部代码与<code>TriangulateCornerTerracesCliff</code>相似，只是调整了参数顺序。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 针对Slope-Cliff连接 镜像 类型 创建三角形连接区域</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;begin&quot;&gt;</span>初始cell位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;beginCell&quot;&gt;</span>初始cell实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;left&quot;&gt;</span>左侧cell位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;leftCell&quot;&gt;</span>左侧cell实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;right&quot;&gt;</span>右侧cell位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;rightCell&quot;&gt;</span>右侧cell实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerCliffTerraces</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">1f</span> / (leftCell.Elevation - beginCell.Elevation);</span><br><span class="line">    Vector3 boundary = Vector3.Lerp(begin, left, b);</span><br><span class="line">    Color boundaryColor = Color.Lerp(beginCell.color, leftCell.color, b);</span><br><span class="line"></span><br><span class="line">    TriangulateBoundaryTriangle(right, rightCell, begin, beginCell, boundary, boundaryColor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope)</span><br><span class="line">    &#123;</span><br><span class="line">        TriangulateBoundaryTriangle(left, leftCell, right, rightCell, boundary, boundaryColor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        AddTriangle(left, right, boundary);</span><br><span class="line">        AddTriangleColor(leftCell.color, rightCell.color, boundaryColor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　完成镜像的方法后，我们只需要在``方法中判断并调用即可，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCorner</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 bottom, HexCell bottomCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (rightEdgeType == HexEdgeType.Slope)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftEdgeType == HexEdgeType.Flat)</span><br><span class="line">        &#123;</span><br><span class="line">            TriangulateCornerTerraces(right, rightCell, bottom, bottomCell, left, leftCell);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Slope-Cliff连接 镜像 类型</span></span><br><span class="line">        <span class="comment">//bottom最低，right比bottom高1，left比right高1及以上</span></span><br><span class="line">        TriangulateCornerCliffTerraces(bottom, bottomCell, left, leftCell, right, rightCell);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-16-2.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-16-3.png"></p>
<p>　　这样，我们就完成了Slope-Cliff类型及其镜像的三角形连接区域构建。在接下来的章节中，我们将完成最后一种连接类型，即最低的地图单元，和其他两个地图单元的高度差都大于1的情况。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/62a9cf7f8037a44cf4d339298275c31d7c2170da">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-17 双Cliff类型三角形连接区域构建</title>
    <url>/2020/11/03/HexMap/3-17%20%E5%8F%8CCliff%E7%B1%BB%E5%9E%8B%E4%B8%89%E8%A7%92%E5%BD%A2%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%9F%9F%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<p>　　在上一章中，我们完成了<code>SSF</code>和<code>Slope-Cliff</code>两种连接类型及其变体的三角形连接区域的构建。现在我们来完成最后一种情况，也就是最低的bottom地图单元与left和right地图单元的高度差都大于1，并且left和right地图单元的高度差为1，这种组合类型。我们将这种组合命名为<code>Cliff-Cliff-Slope</code>类型，简写为<code>CCS</code>。而且由于lefr和right两个地图单元之间高度差为1，如果right地图单元比较高，就简写为<code>CCSR</code>类型，如果left地图单元比较高，就简写为<code>CCSL</code>类型。<code>CCSR</code>类型和<code>CCSL</code>类型分别如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-17-1.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-17-2.png"></p>
<p>　　我们对这两种组合的抽象表示如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-17-3.png"></p>
<p>　　其实细心挂差可以发现，不论是<code>CCSL</code>或者<code>CCSR</code>，它们与Slope-Cliff类型及其镜像是上下翻转的。这里我们只需要继续调用<code>TriangulateCornerCliffTerraces</code>和<code>TriangulateCornerTerracesCliff</code>方法进行三角面片的构建就可以了。我们需要做的只是判断连接类型，并且确认输入参数顺序正确即可。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCorner</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 bottom, HexCell bottomCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//bottom最低，与left和right高差都大于1，并且left和right高差为1，称为 CCS类型</span></span><br><span class="line">    <span class="comment">//如果left比right高1，那么就是CCSL，反之right比left高1，那就是CCSR</span></span><br><span class="line">    <span class="keyword">if</span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//CCSR</span></span><br><span class="line">        <span class="keyword">if</span> (leftCell.Elevation &lt; rightCell.Elevation)</span><br><span class="line">        &#123;</span><br><span class="line">            TriangulateCornerCliffTerraces(right, rightCell, bottom, bottomCell, left, leftCell);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//CCSL</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TriangulateCornerTerracesCliff(left, leftCell, right, rightCell, bottom, bottomCell);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们虽然完成了<code>CCSL</code>和<code>CCSR</code>两种类型的三角形连接区域的构建，但是通过观察运行效果我们发现会产生一些奇怪的三角面片，这是因为我们之前计算插值的时候，都是从上到下进行的，现在上下翻转之后，计算的结果为负数，所以就构建出了奇怪的三角面片。解决这个问题也很简单，就是在计算插值之前，先判断结果是否为负数，如果是负数，那就乘以`-1``变为正数即可。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerTerracesCliff</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">1f</span> / (rightCell.Elevation - beginCell.Elevation);</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        b = -b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerTerracesCliff</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">1f</span> / (leftCell.Elevation - beginCell.Elevation);</span><br><span class="line">    <span class="keyword">if</span> (b &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        b = -b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，我们就完成了最后一个组合类型的三角形连接区域的构建，<code>CCSR</code>类型和<code>CCSL</code>类型完成后分别如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-17-4.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-17-5.png"></p>
<p>　最后还有一种情况，就是三个相邻的地图单元，彼此之间的高度差都大于1，那么他们的三角形连接区域其实就是默认的三角形。</p>
<p>　至此我们已经将所有类型的三角形连接区域构建方法完成了，但是在<code>TriangulateCorner</code>方法中，冗余的判断代码还是比较多的。下一章中，我们将对<code>TriangulateCorner</code>方法中，判断连接类型的代码进行一定的整理和优化，为之后的其他功能做准备。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/7c15ce9931954cb3aae0e073ae2f001ef5d55016">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-18 整理代码逻辑</title>
    <url>/2020/11/04/HexMap/3-18%20%E6%95%B4%E7%90%86%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<p>　　在之前的章节中，我们完成了各类高低差不同的地图单元之间，其三角形连接区域的构建，有些是阶梯化的，有些则是一半阶梯一半三角形的。所有的情况如下图所示</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-18-2.png"><br>　　<br>　　判断地图单元格之间的连接关系，并决定使用哪种方式构建三角形连接区域的语句都在<code>TriangulateCorner</code>方法中。这里我们来整理一下这部分代码，用<code>if else</code>语句来代替现在的<code>return</code>。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCorner</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 bottom, HexCell bottomCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftEdgeType == HexEdgeType.Slope)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (rightEdgeType == HexEdgeType.Slope)</span><br><span class="line">        &#123;</span><br><span class="line">            TriangulateCornerTerraces(bottom, bottomCell, left, leftCell, right, rightCell);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rightEdgeType == HexEdgeType.Flat)</span><br><span class="line">        &#123;</span><br><span class="line">            TriangulateCornerTerraces(left, leftCell, right, rightCell, bottom, bottomCell);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TriangulateCornerTerracesCliff(bottom, bottomCell, left, leftCell, right, rightCell);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rightEdgeType == HexEdgeType.Slope)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftEdgeType == HexEdgeType.Flat)</span><br><span class="line">        &#123;</span><br><span class="line">            TriangulateCornerTerraces(right, rightCell, bottom, bottomCell, left, leftCell);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TriangulateCornerCliffTerraces(bottom, bottomCell, left, leftCell, right, rightCell);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (leftCell.GetEdgeType(rightCell) == HexEdgeType.Slope)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftCell.Elevation &lt; rightCell.Elevation)</span><br><span class="line">        &#123;</span><br><span class="line">            TriangulateCornerCliffTerraces(right, rightCell, bottom, bottomCell, left, leftCell);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TriangulateCornerTerracesCliff(left, leftCell, right, rightCell, bottom, bottomCell);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        AddTriangle(bottom, left, right);</span><br><span class="line">        AddTriangleColor(bottomCell.color, leftCell.color, rightCell.color);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-18-1.png"></p>
<p>　　至此，我们就完成了所有地图单元之间连接类型的判断，以及构建其相邻的三角形连接区域的功能了。相比之前没有任何段落感的地形，现在的地形层次更加丰富，立体感更强。在接下来的章节中，我们要继续丰富地图的细节，使用一张随机的噪点图，对地图上的单元素进行一定的形变。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/97602cbf7949a6cf945984853ed783b2fcf70060">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-2 简单的地图单元高度编辑器</title>
    <url>/2020/10/19/HexMap/3-2%20%E7%AE%80%E5%8D%95%E7%9A%84%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E9%AB%98%E5%BA%A6%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<p>　　我们已经为地图单元增加了高度属性，并且规定了一个高度单位是多少个Unity3D中的单位。与之前为地图单元赋值颜色类似，现在我们需要先完成一个简单的UI，利用<code>Slider</code>来控制地图单元的高度。在鼠标点击地图单元的时候，为被点击的地图单元同时赋值已选中的颜色和高度。<br>　　我们先从<code>HexGrid.ColorCell</code>方法入手，将方法名改为<code>GetCell</code>，返回值为被点击地图单元的实例，并且在这个方法里不再重新构建整所有的地图单元。</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取背点击cell的实例</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;_position&quot;&gt;</span>鼠标点击hexmap的位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HexCell <span class="title">GetCell</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    position = transform.InverseTransformPoint(position);</span><br><span class="line">    HexCoordinates coordinates = HexCoordinates.FromPosition(position);</span><br><span class="line">    <span class="keyword">int</span> index = coordinates.X + coordinates.Z * width + coordinates.Z / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回被点击cell的实例</span></span><br><span class="line">    <span class="keyword">return</span> cells[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　因为<code>GetCell</code>已经不再重新构建整个地图了，所以我们将这部分单独创建一个方法，也方便今后进行调用。</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 重新构建整个地图</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Refresh</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hexMesh.Triangulate(cells);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接着我们回到<code>HexMapEditor.cs</code>中，在这里我们创建<code>EditCell</code>方法，这个方法中为被点击的地图单元赋值颜色和高度，并刷新整个地图，而在<code>HandleInput</code>方法中，只要调用它就可以了。</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleInput</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (Physics.Raycast(_inputRay, <span class="keyword">out</span> _hit))</span><br><span class="line">    &#123;</span><br><span class="line">        EditCell(hexGrid.GetCell(_hit.point));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 为被点击cell赋值颜色和高度，并刷新整个地图</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cell&quot;&gt;</span>被点击cell的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EditCell</span>(<span class="params">HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cell.color = activeColor;</span><br><span class="line">    hexGrid.Refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　现在的<code>EditCell</code>方法中只有赋值颜色的部分，这里需要添加赋值高度的部分。和赋值颜色的思路一样，我们首先添加一个变量用于获取当前UI选中的高度，然后再将这个高度赋值给被点击地图单元的实例。</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//已选中的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> activeElevation;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EditCell</span>(<span class="params">HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        cell.color = activeColor;</span><br><span class="line">        cell.elevation = activeElevation;</span><br><span class="line">        hexGrid.Refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　和UI选取颜色一样，需要有一个方法被UI调用，来设置选中的高度。这里使用Slider组件来实现这个功能，由于Slider组件所产生的是<code>float</code>类型的数据，所以我们需要接收<code>float</code>类型的值，并将这个值转换成<code>int</code>类型。</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取UI选定的高度</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;elevation&quot;&gt;</span>从UI的Slider接收的值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetElevation</span>(<span class="params"><span class="keyword">float</span> elevation</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    activeElevation = (<span class="keyword">int</span>)elevation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们回到Unity3D编辑器中，选中<code>Hex Map Editor</code>，添加一个Slider组件(GameObject / Create / Slider)。并调整其大小、位置和方向如下图所示。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-2-1.png"></p>
<p>　　接着将Slider组件的取值范围设置为取整数值(Whole Numbers)，并设置其取值范围为0-6。最后将OnValueChanged事件与<code>HexMapEditor.SetElevation</code>方法相关连。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-2-2.png"></p>
<p>　　这样，我们就初步完成了一个通过UI来为被点击的地图单元赋值高度的功能了。不过现在只是将高度值赋值到了被点击的地图单元实例中，并没有在构建三角面片的时候对地图单元的mesh作出改变。在接下来的一章中，我们来实现这个功能。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/87d316e43db1ebe000d6bd3bded38e534a0df5f0">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-3 设置地图单元Mesh的高度</title>
    <url>/2020/10/20/HexMap/3-3%20%E8%AE%BE%E7%BD%AE%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83Mesh%E7%9A%84%E9%AB%98%E5%BA%A6/</url>
    <content><![CDATA[<p>　　在上一章中我们为地图单元添加了高度属性，并完成了简单的UI，来为被点击的地图单元赋值高度信息。但是在构建地图Mesh的时候，并没有将这个高度值应用到被点击的地图单元上。这里我们就来实现这个功能，首先将<code>HexCell </code>中的<code>elevation</code>字段转换为属性。</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> elevation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Elevation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> elevation;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        elevation = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　然后在赋值高度的同时，修改地图单元Mesh的垂直坐标。</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Elevation</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        elevation = <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在获取高度等级的时候，同时为cell的Mesh赋值相应的高度值</span></span><br><span class="line">        Vector3 position = transform.localPosition;</span><br><span class="line">        position.y = <span class="keyword">value</span> * HexMetrics.elevationStep;</span><br><span class="line">        transform.localPosition = position;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　因为将<code>elevation</code>字段转换为了属性，回到<code>HexMapEditor.EditCell</code>里将赋值语句的错误修改掉，</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EditCell</span>(<span class="params">HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cell.color = activeColor;</span><br><span class="line">    cell.Elevation = activeElevation;</span><br><span class="line">    hexGrid.Refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-3-1.png"></p>
<blockquote>
<p>MeshCollider是否能吻合新的高度地图?<br>旧版本的Unity需要在设置相同的Mesh信息之前先把MeshCollider设为null，它只是假设Mesh的数据不会改改变,所以只有不同的Mesh（或者null）能触发碰撞器的刷新，现在已经没这个必要了。所以我们现在的方法：在三角构建之后重新分配MeshCollider的Mesh信息，这是可行的。</p>
</blockquote>
<p>　　现在通过UI设置高度之后，点击一个地图单元，我们就可以看到被点击的地图单元升高了对应的高度。但是这里还有两个问题：<br>　　第一：跟随地图单元的坐标并没有随着地图单元的高度高边而改变，当地图单元高度变化的时候，其对应的坐标依然还是在水平高度上。<br>　　第二：地图单元之间的连接错误。颜色混合区域连接着两个相邻的地图单元，当两个地图单元的垂直高度不相同的时候，颜色混合区域应该依然连接着两个地图单元，因为高度不同只是被拉伸了而已。<br>　　在接下来的章节中，我们将会解决这些问题。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/9d32f7a5dfb884a2ff1c1ed30155d8de854e2455">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-4 修复地图单元坐标</title>
    <url>/2020/10/21/HexMap/3-4%20%E4%BF%AE%E5%A4%8D%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E5%9D%90%E6%A0%87/</url>
    <content><![CDATA[<p>　　在上一章中我们实现了通过UI设置地图单元的高度，点击任意一个地图单元后，该地图单元的高度会根据UI的值发生改变。但是跟随地图单元的坐标文字却没有随着改变，在这一章中我们来解决这个问题。<br>　　要让地图单元的坐标发生改变，就要让每个地图单元获取到自身UI的<code>RectTransform</code>实例，以便接下来改变其高度。</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自身坐标UI的RectTransform组件实例</span></span><br><span class="line">    <span class="keyword">public</span> RectTransform uiRect;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　回到<code>HexGrid.cs</code>中，在<code>CreateCell</code>方法的最后，让每个地图单元获取其UI的RectTransform组件实例</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取cell对应UI的rectTransform组件实例</span></span><br><span class="line">    cell.uiRect = label.rectTransform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　现在，我们就可以在<code>HexCell.Elevation.set</code>方法中进行对应UI高度的设置了。这里要注意，我们之前在设置地图单元做标canvas的时候，在x方向旋转了90度。所以这里应该是在z轴负方向进行高度设置，而不是y轴。</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Elevation</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置cell对应UI的高度</span></span><br><span class="line">        Vector3 uiPosition = uiRect.localPosition;</span><br><span class="line">        uiPosition.z = elevation * (-HexMetrics.elevationStep);</span><br><span class="line">        uiRect.localPosition = uiPosition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，我们在UI上设置好高度后，点击任意地图单元，其对应的地图坐标会随着被点击的地图单元高度变化而变化。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-4-1.png"></p>
<p>　　现在地图单元的UI显示已经修复了。在下一章中，我们来修复两个相邻且高度不同的地图单元之间连接区域断开的问题。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/ceaedbd85012c17d79abfeb1e802ff59293a5ef2">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-5 修复相邻地图单元连接区域</title>
    <url>/2020/10/22/HexMap/3-5%20%E4%BF%AE%E5%A4%8D%E7%9B%B8%E9%82%BB%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>　　在上一章中，我们修复了地图单元与其对应UI高度不同的问题。在这一章中，我们来修复两个相邻且高度不同的地图单元，它们之间的连接处断裂的问题。<br>　　先回到<code>HexMesh.TriangulateConnection</code>方法中，在这个方法里我们计算了连接区域的每个顶点。与改变UI高度的思路相似，这里只需要将计算后的两个顶点加上高度即可。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里为连接相邻cell的v3 v4顶点加上其所在cell的高度</span></span><br><span class="line">    v3.y = v4.y = neighbor.Elevation * HexMetrics.elevationStep;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　现在我们已经修复了矩形颜色混合区域断裂的问题了。三角形颜色混合区域的思路相同，但是略微复杂一些。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//声明一个新的vector3变量来存储高度改变后的顶点位置</span></span><br><span class="line">        <span class="comment">//v5的本质其实就是v2 + HexMetrics.GetBridge(direction.Next()加上高度值</span></span><br><span class="line">        Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next());</span><br><span class="line">        v5.y = nextNeighbor.Elevation * HexMetrics.elevationStep;</span><br><span class="line"></span><br><span class="line">        AddTriangle(v2, v4, v5);</span><br><span class="line">        </span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-5-1.png"></p>
<p>　　这样，我们就完成了所有连接区域的修复了。现在通过UI设置高度之后，点击任意的地图单元，其对应的坐标、周围的连接区域都完全正常了。但是连接区域部分只是简单的进行了拉伸，当两个相邻的地图单元高度差很大的时候，会显得比较突兀，而且整个地图的细节不够。在接下来的章节中，我们来丰富连接区域的细节，让连接区域更加有层次感。</p>
<p>[Github代码](</p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-6 阶梯状的连接区域</title>
    <url>/2020/10/23/HexMap/3-6%20%E9%98%B6%E6%A2%AF%E7%8A%B6%E7%9A%84%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>　　在之前的章节中我们修复了地图单元对应UI高度和连接区域断裂的问题。同时我们也发现一个问题，在两个相邻且有高差的地图单元之间，连接区域只是被简单的拉伸了。如果高差很大的话，这个现象就更加明显。在接下来的章节中，我们来丰富连接区域的细节。<br>　　增加连接区域的具体方式，我们可以参考《无尽传奇》这个游戏。将一个倾斜的连接区域插入两段阶梯，如下图所示。这样一个完整的斜面就被分为了三个小斜面。每个斜面之间用平面相连接。这就需要我们把这个阶梯斜面分为五个部分来看。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-6-1.png"></p>
<p>　　我们回到<code>HexMetrics.cs</code>中，在这里定义每个连接面中需要插入阶梯的数量，并由此计算出整个连接区域会被拆分成几个部分。</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexMetrics</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//每个连接部分阶梯的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">int</span> terracesPerSlope = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//横向步长个数</span></span><br><span class="line">    <span class="comment">//根据阶梯数量，计算出连接区域会被拆分成几个横向步长</span></span><br><span class="line">    <span class="comment">//参考图 http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-6-1.png</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">int</span> terraceSteps = terracesPerSlope * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来我们需要计算被拆分出来连接区域中每个部分的顶点的位置。通过观察上图我们发现，如果设左下角的顶点为阶梯的起始点，也就是第0步，那么在Y坐标有变化的顶点，都是奇数步上的顶点。按照这个规律就可以得到一个梯田状的连接区域了。在<code>HexMetrics.cs</code>中添加一个特殊的插值方法来实现这个功能。</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 通过插值计算出阶梯状连接区域，每个顶点的坐标位置</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;a&quot;&gt;</span>起始顶点的位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;b&quot;&gt;</span>结束顶点的位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;step&quot;&gt;</span>第几个步长<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>根据步长插值计算得出的顶点的位置<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">TerraceLerp</span>(<span class="params">Vector3 a, Vector3 b, <span class="keyword">int</span> step</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　通过观察上图我们还发现，每个顶点的插值分为两部分，一个是垂直方向的，一个是水平方向的。这里先通过步长计算出每个顶点的水平坐标。</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//横向每个步长占整体长度的比例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> horizontalTerraceStepSize = <span class="number">1f</span> / terraceSteps;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">TerraceLerp</span>(<span class="params">Vector3 a, Vector3 b, <span class="keyword">int</span> step</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//单个步长的比例 与 步长的个数，计算出现在顶点所在的比例</span></span><br><span class="line">    <span class="keyword">float</span> h = step * horizontalTerraceStepSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//水平位置的X和Z，分别乘以 现在顶点所在的比例，得出该步长顶点的实际坐标</span></span><br><span class="line">    a.x += (b.x - a.x) * h;</span><br><span class="line">    a.z += (b.z - a.z) * h;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<blockquote>
<p>两个值之间的插值是怎么计算的？<br>两个值<code>$ a $</code>和<code>$ b $</code>之间的插值，需要第三个插入值<code>$ t $</code>。当<code>$ t $</code>为0时，结果就是<code>$ a $</code>。当<code>$ t $</code>为1时，结果就是<code>$ b $</code>。当<code>$ t $</code>为0到1之间的某个值时，结果为<code>$ a $</code>和<code>$ b $</code>之间的某个值。所以插值公式为<code>$ (1-t)a+tb $</code>。这个公式可以变成<code>$ (1-t)a+tb=a-ta+tb=a+t(b-a) $</code>。其中<code>$ t $</code>的值相当于向量<code>$ b-a $</code>从<code>$ a $</code>到<code>$ b $</code>移动的距离。这样简化之后，所需要的乘法计算步骤更少。</p>
</blockquote>
<p>　　接下来我们要设置步长中每个顶点的的Y坐标。因为只有在奇数步长的时候，Y坐标才会改变，所以这里使用<code>$ \frac&#123;step+1&#125;&#123;2&#125; $</code>来计算。这里只取商的整数部分，相当于把序列<code>1, 2, 3, 4</code>变成了<code>1, 1, 2, 2</code>。</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//纵向每个步长占整体长度的比例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> verticalTerraceStepSize = <span class="number">1f</span> / (terracesPerSlope + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">TerraceLerp</span>(<span class="params">Vector3 a, Vector3 b, <span class="keyword">int</span> step</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参考图 http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-6-1.png</span></span><br><span class="line">    <span class="comment">//根据参考图可以知道，实时位置点位步长0，那么只有在奇数步长时候才会改变Y坐标</span></span><br><span class="line">    <span class="comment">//(step + 1) / 2取商的整数部分，其实就是将步长1 2 3 4，变成了1 1 2 2这种形式</span></span><br><span class="line">    <span class="comment">//也就是只在奇数步长的时候对Y值进行改变</span></span><br><span class="line">    <span class="keyword">float</span> v = ((step + <span class="number">1</span>) / <span class="number">2</span>) * HexMetrics.verticalTerraceStepSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算出Y的插值之后，计算出实际Y的坐标值</span></span><br><span class="line">    a.y += (b.y - a.y) * v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　每个步长顶点的坐标计算完成后，我们还需要计算每个步长顶点的颜色值。这里相较于计算坐标更加简单。每个顶点的颜色值，只需要根据水平位置的插值来计算就可以了。</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 通过插值计算出集体装连接区域，每个顶点的颜色值</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 计算颜色值不需要考虑垂直方向坐标变化的问题，只需要根据水平插值便可以得出计算结果</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;a&quot;&gt;</span>起始顶点的位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;b&quot;&gt;</span>结束顶点的位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;step&quot;&gt;</span>第几个步长<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Color <span class="title">TerraceLerp</span>(<span class="params">Color a, Color b, <span class="keyword">int</span> step</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//单个步长的比例 与 步长的个数，计算出现在顶点所在的比例</span></span><br><span class="line">    <span class="keyword">float</span> h = step * horizontalTerraceStepSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过Color.Lerp方法，计算出现在顶点的颜色值</span></span><br><span class="line">    <span class="keyword">return</span> Color.Lerp(a, b, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，我们就完成了计算阶梯连接区域中，每个步长顶点的位置、颜色的功能了。在下面的章节中，我们将调用这些方法来实现矩形连接区域的三角构建。</p>
<p>[Github代码](</p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-7 矩形连接区域阶梯化</title>
    <url>/2020/10/24/HexMap/3-7%20%E7%9F%A9%E5%BD%A2%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%9F%9F%E9%98%B6%E6%A2%AF%E5%8C%96/</url>
    <content><![CDATA[<p>　　在上一章中，我们创建了计算阶梯连接区域中各个顶点位置和颜色的方法。在这一章中，我们要使用这些方法对矩形连接区域进行三角剖分。计算出矩形连接区域阶梯化后各个顶点的位置和颜色。<br>　　首先，我们回到<code>HexMesh.TriangulateConnection</code>方法中，我们注释掉关于构建矩形连接区域，并为其顶点赋值颜色的代码。取代这部分代码的是一个新阶梯化连接区域的方法。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行矩形颜色混合区域的三角面片构建和赋值顶点颜色</span></span><br><span class="line">    <span class="comment">//AddQuad(v1, v2, v3, v4);</span></span><br><span class="line">    <span class="comment">//AddQuadColor(cell.color, neighbor.color);</span></span><br><span class="line">    <span class="comment">//以上方法注释掉，使用新的 TriangulateEdgeTerraces  进行替换</span></span><br><span class="line">    TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor);</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 阶梯化连接区域</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;beginLeft&quot;&gt;</span>cell到neighbor连接区域的第一个起点<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;beginRight&quot;&gt;</span>cell到neighbor连接区域的第二个起点<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;beginCell&quot;&gt;</span>cell自身实例，用于获取颜色<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;endLeft&quot;&gt;</span>连接区域 连接到的neighbor的第一个终点<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;endRight&quot;&gt;</span>连接区域 连接到的neighbor的第二个终点<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;endCell&quot;&gt;</span>连接到的neighbor实例，用于获取颜色<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateEdgeTerraces</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 beginLeft, Vector3 beginRight, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 endLeft, Vector3 endRight, HexCell endCell</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AddQuad(beginLeft, beginRight, endLeft, endRight);</span><br><span class="line">    AddQuadColor(beginCell.color, endCell.color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　根据上一章中使用插值进行阶梯化的思路，这里先构建阶梯的第一个面。</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateEdgeTerraces</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 beginLeft, Vector3 beginRight, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 endLeft, Vector3 endRight, HexCell endCell</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里先生成阶梯的第一个矩形面片。通过给定插值来计算出矩形面片的另外两个顶点</span></span><br><span class="line">    Vector3 v3 = HexMetrics.TerraceLerp(beginLeft, endLeft, <span class="number">1</span>);</span><br><span class="line">    Vector3 v4 = HexMetrics.TerraceLerp(beginRight, endRight, <span class="number">1</span>);</span><br><span class="line">    Color c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    AddQuad(beginLeft, beginRight, v3, v4);</span><br><span class="line">    AddQuadColor(beginCell.color, c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-7-1.png"></p>
<p>　　生成第一个阶梯面片后，我们直接跳过中间步骤，将剩余部分用一个矩形面片连接起来。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateEdgeTerraces</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 beginLeft, Vector3 beginRight, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 endLeft, Vector3 endRight, HexCell endCell</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里先生成阶梯的第一个矩形面片。通过给定插值来计算出矩形面片的另外两个顶点</span></span><br><span class="line">    Vector3 v3 = HexMetrics.TerraceLerp(beginLeft, endLeft, <span class="number">1</span>);</span><br><span class="line">    Vector3 v4 = HexMetrics.TerraceLerp(beginRight, endRight, <span class="number">1</span>);</span><br><span class="line">    Color c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    AddQuad(beginLeft, beginRight, v3, v4);</span><br><span class="line">    AddQuadColor(beginCell.color, c2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接阶梯的剩余区域</span></span><br><span class="line">    AddQuad(v3, v4, endLeft, endRight);</span><br><span class="line">    AddQuadColor(c2, endCell.color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-7-2.png"></p>
<p>　　通过观察3-6章的示意图可以发现，除了阶梯的第一个矩形面片和最后的连接区域，其余部分可以通过一个循环来生成。思路就是将通过插值计算得出的两个顶点，作为下一个矩形面片的起始点，利用插值再计算出新矩形面片的两个终点。计算颜色也是这个思路。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateEdgeTerraces</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 beginLeft, Vector3 beginRight, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 endLeft, Vector3 endRight, HexCell endCell</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    AddQuad(beginLeft, beginRight, v3, v4);</span><br><span class="line">    AddQuadColor(beginCell.color, c2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阶梯的其他矩形面片，可以通过循环来生成</span></span><br><span class="line">    <span class="comment">//旧的矩形面片终点V3 V4，就是新面片的起点 V1 V2</span></span><br><span class="line">    <span class="comment">//然后再利用插值计算新面片的终点即可</span></span><br><span class="line">    <span class="comment">//颜色计算同理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; HexMetrics.terraceSteps; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 v1 = v3;</span><br><span class="line">        Vector3 v2 = v4;</span><br><span class="line">        Color c1 = c2;</span><br><span class="line">        v3 = HexMetrics.TerraceLerp(beginLeft, endLeft, i);</span><br><span class="line">        v4 = HexMetrics.TerraceLerp(beginRight, endRight, i);</span><br><span class="line">        c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, i);</span><br><span class="line">        AddQuad(v1, v2, v3, v4);</span><br><span class="line">        AddQuadColor(c1, c2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接阶梯的剩余区域</span></span><br><span class="line">    AddQuad(v3, v4, endLeft, endRight);</span><br><span class="line">    AddQuadColor(c2, endCell.color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-7-3.png"></p>
<p>　　这样，我们就将之前的矩形连接区域转换成了阶梯状连接区域。并且可以自定义阶梯的段数。但是我们发现一个问题，就是在两个高度相同的地图单元之间，也进行了不必要的阶梯化，这样就产生了多于的三角面。在下一章中，我们会将高度进行分类，从而解决这个问题。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-7-4.png"></p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/2e1449870afd8f2429786841b32f7a9ff45be47a">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-8 设置连接类型</title>
    <url>/2020/10/25/HexMap/3-8%20%E8%AE%BE%E7%BD%AE%E8%BF%9E%E6%8E%A5%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>　　在上一章中完成了矩形连接区域的阶梯化，但是我们发现如果两个相邻的地图单元高度相同，那么他们之间的矩形连接区域可以不用阶梯化，从而避免产生多于的三角面片。相反的，如果两个相邻的地图单元高度相差较大的时候，3段阶梯又会被拉伸，感觉并不美观。<br>　　根据这个现象，我们将不同高度的连接分为三个类型：Flat(平坦)、Slop(倾斜)、Cliff(陡峭)，并为其创建一个新的枚举类型。</p>
<figure class="highlight csharp"><figcaption><span>HexEdgeType.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个cell之间的高度差分类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> HexEdgeType</span><br><span class="line">&#123;</span><br><span class="line">    Flat,<span class="comment">//高度差为0</span></span><br><span class="line">    Slope,<span class="comment">//高度差为1</span></span><br><span class="line">    Cliff<span class="comment">//高度差大于1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　为了确认相邻地图单元的连接类型，在<code>HexMetrice.cs</code>中添加一个方法，通过计算两个相邻地图单元的高度差，来判断他们的连接类型。</p>
<figure class="highlight csharp"><figcaption><span>HexMetrice.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 判断两个相邻的cell之间的高度差</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;elevation1&quot;&gt;</span>cell自身<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;elevation2&quot;&gt;</span>相邻的cell<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>两个相邻cell的连接类型<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HexEdgeType <span class="title">GetEdgeType</span>(<span class="params"><span class="keyword">int</span> elevation1, <span class="keyword">int</span> elevation2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　如果两个相邻地图单元的高度相同，那么他们之间的连接类型就为Flat(平坦)。</p>
<figure class="highlight csharp"><figcaption><span>HexMetrice.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HexEdgeType <span class="title">GetEdgeType</span>(<span class="params"><span class="keyword">int</span> elevation1, <span class="keyword">int</span> elevation2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//两个相邻cell高度相同，为Flat</span></span><br><span class="line">    <span class="keyword">if</span> (elevation1 == elevation2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> HexEdgeType.Flat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　如果两个相邻地图单元的高度差值为1，那么就是Slop(倾斜)。除此之外，均为Cliff(陡峭)。</p>
<figure class="highlight csharp"><figcaption><span>HexMetrice.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HexEdgeType <span class="title">GetEdgeType</span>(<span class="params"><span class="keyword">int</span> elevation1, <span class="keyword">int</span> elevation2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//两个相邻cell高度差1，为Slope</span></span><br><span class="line">    <span class="keyword">int</span> delta = elevation2 - elevation1;</span><br><span class="line">    <span class="keyword">if</span> (delta == <span class="number">1</span> || delta == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> HexEdgeType.Slope;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//剩下的情况，均为Cliff</span></span><br><span class="line">    <span class="keyword">return</span> HexEdgeType.Cliff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来回到<code>HexCell.cs</code>中，创建一个方法，用来获取指定方位相邻地图单元的连接类型。</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 获取指定方位相邻cell 的连接类型(HexEdgeType)</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>指定的相邻方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HexEdgeType <span class="title">GetEdgeType</span>(<span class="params">HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> HexMetrics.GetEdgeType(</span><br><span class="line">        elevation, neighbors[(<span class="keyword">int</span>)direction].elevation</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　现在，我们对各种不同高差的连接类型进·完成了分类，并创建了一个获取相邻地图单元连接类型的方法。在接下来的一章中，我们将使用这些代码，只对Slop(倾斜)类型的连接进行阶梯化。</p>
<blockquote>
<p>是否需要在所有方向上都要检查存不存在相邻单元格？<br>你可能最终会在恰好位于地图边界上的方向获取边缘类型。在那种情况下是没有相邻地图单元的，同时我们也会得到一个空引用异常。当然可以在方法内就检查这个，然后如果发生这种情况抛出某种异常。但是那种情况下，异常就已经发生了，所以这是多此一举，除非你想抛出一个自定义的异常类型。<br>需要明确的是，我们只会在我们知道不是处理地图边界的时候才会使用这个方法，如果在某些地方出错了，我们肯定会得到一个空引用异常。</p>
</blockquote>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/97cf71f0d9338ad4cfcaf871c35207dc51eb6cd4">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>3-9 阶梯化Slope类型连接区域</title>
    <url>/2020/10/26/HexMap/3-9%20%E9%98%B6%E6%A2%AF%E5%8C%96slope%E7%B1%BB%E5%9E%8B%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>　　在上一章中，我们为不同高度的连接区域划分了类型，并创建了一个方法来判断两个相邻地图单元之间的连接区域是哪种类型。这一章中，我们来实现只阶梯化Slope类型的连接区域，其他的连接区域依然是由两个三角面片构成的矩形。<br>　　首先回到<code>HexMesh.TriangulateConnection</code>方法中，在这个方法中进行了阶梯化连接区域的操作，我们在阶梯化之前加入一个判断，当连接类型为Slope的时候才执行阶梯化操作。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//在这里新加入判断，当两个相邻cell的连接类型为Slope的时候，才会创建阶梯化连接</span></span><br><span class="line">    <span class="keyword">if</span> (cell.GetEdgeType(direction) == HexEdgeType.Slope)</span><br><span class="line">    &#123;</span><br><span class="line">        TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接着，我们需要启用之前的代码，也就是判断如果连接类型不为Slope，那么连接区域就是矩形的。</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//在这里新加入判断，当两个相邻cell的连接类型为Slope的时候，才会创建阶梯化连接</span></span><br><span class="line">    <span class="keyword">if</span> (cell.GetEdgeType(direction) == HexEdgeType.Slope)</span><br><span class="line">    &#123;</span><br><span class="line">        TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当连接类型不为Slope的时候，连接区域是矩形的</span></span><br><span class="line">        AddQuad(v1, v2, v3, v4);</span><br><span class="line">        AddQuadColor(cell.color, neighbor.color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/3-9-1.png"></p>
<p>　　这样，我们就完成了相邻地图单元连接区域的分类，并且会按照不同的分类，自动进行判断这个连接区域是否要进行阶梯化处理。在节省面数的同时，也让整个地图的层侧干更加的明显了。<br>　　不过当我们在Unity中运行时发现，如果连接类型为Slope的时候，矩形连接区域是正常的，但是三角形连接区域却没有完全贴合阶梯的边缘，导致有“破面”的情况发生。造成这个问题的原因是，我们只对矩形连接区域进行了阶梯化，而忽略了三角形连接区域。在接下来的章节中，我们将修复这个问题。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/995883a232455af345dbdc123f22698966bcd077">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>4-1 导入噪点图</title>
    <url>/2020/11/05/HexMap/4-1%20%E5%AF%BC%E5%85%A5%E5%99%AA%E7%82%B9%E5%9B%BE/</url>
    <content><![CDATA[<p>　　到目前为止，我们可以通过程序化生成一个正六边形有高低差的地图，并且在不同的高低差之间有更多的细节。但是现在的地图仍然是一个很规则精确的蜂窝状网格。在接下来的章节中，我们会使用一张噪点图，为现在的地图增加一些不规则感，让地图看起来更加自然。<br>　　要添加一些不规则的感，就需要一些随机性，但又不是真正的全随机。所以我们需要的是在编辑地图时未选中的位置保持不变，不然每改动一点地图就全变了。所以需要是一种可重现的伪随机，即噪声。<br>　　柏林噪声(Perlin noise)就是一个很好的选择，它在每个点的位置都可以重现。当多种不同频率的柏林噪声叠加时，能产生大范围来看变化很大，小范围内又接近一致的噪声纹理，生成相对平滑的形变，靠近的点更倾向于黏在一起而不是向相反的方向扭曲。</p>
<blockquote>
<p><a href="https://zh.wikipedia.org/wiki/Perlin%E5%99%AA%E5%A3%B0">柏林噪声 wiki</a></p>
</blockquote>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/206271895">柏林噪声 知乎相关文章</a></p>
</blockquote>
<p>　　柏林噪声可以程序化生成，也能使用一张预先生成的噪声纹理图。使用噪声纹理图的好处是它比直接计算多频率叠加的噪声更容易，也更快，缺点是纹理图需要占用内存并且噪声的区域大小相对有限。所以噪声纹理图需要平铺显示并且需要覆盖比较大的区域，使得产生的循环不那么频繁和紧密，从而产生伪随机和单调感。<br>　　使用噪点图的原理其实与一张尺寸较小的纹理贴图，贴在一个尺寸较大的物体上一样，如果贴图是循环铺满整个物体表面，那么横向和纵向都会产生很多的重复，视觉效果就会打折扣，而且显得很单调。<br>　　这里准备使用噪声纹理贴图，如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-1-1.png"></p>
<p>　　这张纹理图包含多重频率叠加的平铺柏林噪声，并且是一张灰度图，其平均值接近0.5，极限值是0和1。<br>　　不过这不是我们最终要用的图，这张图的每个像素点上只有一个值，如果我们需要的是3D形变，我们至少得需要三个伪随机采样。所以除此之外还需要两张额外的不同噪声纹理图。<br>　　我们可以就用三张不同的纹理图，或者也可以用RGB通道来存储这些值，我们可以在一张彩色纹理图上，使用RGBA通道来存储四种不同样式的噪声，如下图，要使用它的话，直接在图片上单机鼠标右键保存至本地，然后导入Unity3D即可。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-1-2.png"></p>
<p>　　将这张彩色噪点图导入Unity3D工程中后，我们要对这张图进行一些设置，以便在之后的步骤中顺利使用它。以下是对这张彩色噪点图的设置项：</p>
<ol>
<li>首先由于我们要用代码对彩色噪点图进行采样,所以它必须是可读写的。勾选Read/Write Enable。这样就能把纹理贴图的数据存储到内存中并用C#代码进行访问。</li>
<li>取消勾选sRGB(Color Texture)选项</li>
<li>图片格式设置成Automatic并且压缩方式设置成null，我们不想因为压缩纹理而破坏噪声图的样式。</li>
<li>Generate Mip Maps也取消勾选,并不需要这个功能。<br>　　设置完成后如下图所示：</li>
</ol>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-1-3.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-1-4.png"></p>
<blockquote>
<p>如果勾选sRGB会有什么影响?<br>如果我们在着色器的某些地方使用噪声纹理图，它可能会有些不同。当使用线性渲染模式时，纹理采样数据会自动从伽马空间转换到线性空间。这会对噪声纹理的采样数据产生一个错误的结果，而这是需要避免的。（注：Unity的默认渲染模式是线性模式）</p>
</blockquote>
<blockquote>
<p>这篇教程所有的代码与设置，均使用Unity 2019.4.X版本，可能在之后的版本中，图中的设置选项位置有所不同。</p>
</blockquote>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/df84a9ab6129dac7e6e1f659a8bbe2bddb8e5031">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>4-10 连接六边形边缘与连接区域边缘</title>
    <url>/2020/11/14/HexMap/4-10%20%E8%BF%9E%E6%8E%A5%E5%85%AD%E8%BE%B9%E5%BD%A2%E8%BE%B9%E7%BC%98%E4%B8%8E%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%9F%9F%E8%BE%B9%E7%BC%98/</url>
    <content><![CDATA[<p>　　在上一章中，我们对每个六边形完成了细分，从之前的6个三角面片，增加到了18个三角面片。细节更加丰富。但是六边形边缘和其相邻的连接区域，还存在着破面与重面的问题，在这一章中，我们来修复这些问题。<br>　　对矩形连接区域的细分也会用到新增的顶点信息，所以要将这些信息传递到<code>TriangulateConnection</code>方法中，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为对六边形的每个边进行了细分，所以要把新的顶点也传入构建矩形连接区域的方法中</span></span><br><span class="line">    <span class="comment">//这样矩形区域使用新增的顶点后边缘之间才能吻合</span></span><br><span class="line">    <span class="keyword">if</span> (direction &lt;= HexDirection.SE)</span><br><span class="line">    &#123;</span><br><span class="line">        TriangulateConnection(direction, cell, v1, e1, e2, v2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接着，我们要修改<code>TriangulateConnection</code>方法的参数列表，增加新的顶点参数，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//六边形增加了新的顶点，这里要修改参数列表，接收新的顶点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">     HexDirection direction, HexCell cell,</span></span></span><br><span class="line"><span class="function"><span class="params">     Vector3 v1, Vector3 e1, Vector3 e2, Vector3 v2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们还需要计算与这个矩形连接区域相邻的另一个地图单元上的新增顶点信息。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">     HexDirection direction, HexCell cell,</span></span></span><br><span class="line"><span class="function"><span class="params">     Vector3 v1, Vector3 e1, Vector3 e2, Vector3 v2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    Vector3 v3 = v1 + bridge;</span><br><span class="line">    Vector3 v4 = v2 + bridge;</span><br><span class="line">    v3.y = v4.y = neighbor.Position.y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里要计算与矩形连接区域相邻的，另一侧cell新增的两个顶点位置信息</span></span><br><span class="line">    Vector3 e3 = Vector3.Lerp(v3, v4, <span class="number">1f</span> / <span class="number">3f</span>);</span><br><span class="line">    Vector3 e4 = Vector3.Lerp(v3, v4, <span class="number">2f</span> / <span class="number">3f</span>);</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最后，我们使用新的顶点信息构建矩形连接区域，这里我们先忽略阶梯化的问题，先解决在同一平面下不产生破面与重叠。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">     HexDirection direction, HexCell cell,</span></span></span><br><span class="line"><span class="function"><span class="params">     Vector3 v1, Vector3 e1, Vector3 e2, Vector3 v2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cell.GetEdgeType(direction) == HexEdgeType.Slope)</span><br><span class="line">    &#123;</span><br><span class="line">        TriangulateEdgeTerraces(v1, v2, cell, v3, v4, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里使用新增的顶点进行连接区域的构建</span></span><br><span class="line">        AddQuad(v1, e1, v3, e3);</span><br><span class="line">        AddQuadColor(cell.color, neighbor.color);</span><br><span class="line">        AddQuad(e1, e2, e3, e4);</span><br><span class="line">        AddQuadColor(cell.color, neighbor.color);</span><br><span class="line">        AddQuad(e2, v2, e4, v4);</span><br><span class="line">        AddQuadColor(cell.color, neighbor.color);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-10-1.png"></p>
<p>　　至此我们就完成了地图单元与矩形连接区域产生破面与重面的问题。不过现在只是两个地图单元在相同高度的情况，阶梯化之后仍然存在问题。我们先将阶梯化的问题暂缓，现在我们为<code>TriangulateConnection</code>方法增加了参数，在方法内还要计算相邻地图单元一条边上的两个顶点，这样看来不太符合面向对象的思想。接下来我们会将这些计算过程进行封装，对现有的一些方法进行简化。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/d8ca0fe04a8a8a00ce33cedd5792d8cf96843b70">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>4-11 封装顶点计算方法</title>
    <url>/2020/11/15/HexMap/4-11%20%E5%B0%81%E8%A3%85%E9%A1%B6%E7%82%B9%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>　　在上一章中，我们完成了地图单元与矩形连接区域的的连接。在我们新增代码的时候发现，计算六边形一条边上新增顶点的这部分代码，是可以单独抽象出来，组成一个新的方法，方便在之后计算顶点时调用。<br>　　我们创建一个新的脚本<code>EdgeVertices.cs</code>，其中是一个结构体，包含了4个顺时针排列在六边形一条边上的顶点。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>EdgeVertices.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> EdgeVertices</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//4个顺时针排列在六边形一条边上的顶点</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 v1, v2, v3, v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接着再为这个结构体添加一个构造函数，用来计算每个顶点的位置信息。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>EdgeVertices.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> EdgeVertices</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过六边形一条边上，边缘的两个顶点，计算出中间的两个点的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeVertices</span>(<span class="params">Vector3 corner1, Vector3 corner2</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        v1 = corner1;</span><br><span class="line">        v2 = Vector3.Lerp(corner1, corner2, <span class="number">1f</span> / <span class="number">3f</span>);</span><br><span class="line">        v3 = Vector3.Lerp(corner1, corner2, <span class="number">2f</span> / <span class="number">3f</span>);</span><br><span class="line">        v4 = corner2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　回到<code>HexMesh.cs</code>脚本中，我们创建一个方法，通过4个顶点位置，对六边形内每个三角面片进行细分。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMesh</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对cell的六边形其中一个三角面片进行细分，细分为3个三角面片</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;center&quot;&gt;</span>cell中心点位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;edge&quot;&gt;</span>一条边上细分后的4个顶点信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;color&quot;&gt;</span>cell的颜色<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateEdgeFan</span>(<span class="params">Vector3 center, EdgeVertices edge, Color color</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AddTriangle(center, edge.v1, edge.v2);</span><br><span class="line">        AddTriangleColor(color);</span><br><span class="line">        AddTriangle(center, edge.v2, edge.v3);</span><br><span class="line">        AddTriangleColor(color);</span><br><span class="line">        AddTriangle(center, edge.v3, edge.v4);</span><br><span class="line">        AddTriangleColor(color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　再创建一个方法，用来创建两个地图单元之间，经过细分后的连接区域。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMesh</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 创建2个cell之间细分后的的连接区域</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e1&quot;&gt;</span>第一个cell一条边上的4个顶点<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;c1&quot;&gt;</span>第一个cell的颜色<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e2&quot;&gt;</span>第二个cell一条边上的4个顶点<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;c2&quot;&gt;</span>第二个cell的颜色<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateEdgeStrip</span>(<span class="params">EdgeVertices e1, Color c1, EdgeVertices e2, Color c2</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AddQuad(e1.v1, e1.v2, e2.v1, e2.v2);</span><br><span class="line">        AddQuadColor(c1, c2);</span><br><span class="line">        AddQuad(e1.v2, e1.v3, e2.v2, e2.v3);</span><br><span class="line">        AddQuadColor(c1, c2);</span><br><span class="line">        AddQuad(e1.v3, e1.v4, e2.v3, e2.v4);</span><br><span class="line">        AddQuadColor(c1, c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　完成以上步骤后，我们就可以简化<code>Triangulate</code>方法了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3 center = cell.Position;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过六边形一条边上的两个端点信息，计算出细分的中间两个点的信息</span></span><br><span class="line">    EdgeVertices e = <span class="keyword">new</span> EdgeVertices(</span><br><span class="line">        center + HexMetrics.GetFirstSolidCorner(direction),</span><br><span class="line">        center + HexMetrics.GetSecondSolidCorner(direction)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在计算出各个点的位置信息后，直接构建三角面片</span></span><br><span class="line">    TriangulateEdgeFan(center, e, cell.color);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TriangulateConnection方法增加新的参数，自身不在进行顶点的计算了</span></span><br><span class="line">    <span class="keyword">if</span> (direction &lt;= HexDirection.SE)</span><br><span class="line">    &#123;</span><br><span class="line">        TriangulateConnection(direction, cell, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最后，我们要修改<code>TriangulateConnection</code>方法，使用<code>TriangulateEdgeStrip</code>来创建细分后的连接区域。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里不再使用单个顶点，而直接使用EdgeVertices进行顶点计算</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params">HexDirection direction, HexCell cell, EdgeVertices e1</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HexCell neighbor = cell.GetNeighbor(direction);</span><br><span class="line">    <span class="keyword">if</span> (neighbor == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vector3 bridge = HexMetrics.GetBridge(direction);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先计算出两个相邻cell的高度差</span></span><br><span class="line">    bridge.y = neighbor.Position.y - cell.Position.y;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//利用高度差和第一个cell的坐标，获得连接区域另外一边的4个顶点位置</span></span><br><span class="line">    EdgeVertices e2 = <span class="keyword">new</span> EdgeVertices(e1.v1 + bridge, e1.v4 + bridge);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cell.GetEdgeType(direction) == HexEdgeType.Slope)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里使用EdgeVertices计算的顶点来构建矩形</span></span><br><span class="line">        TriangulateEdgeTerraces(e1.v1, e1.v4, cell, e2.v1, e2.v4, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里使用EdgeVertices计算的顶点来构建矩形</span></span><br><span class="line">        TriangulateEdgeStrip(e1, cell.color, e2, neighbor.color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HexCell nextNeighbor = cell.GetNeighbor(direction.Next());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 v5 = e1.v4 + HexMetrics.GetBridge(direction.Next());</span><br><span class="line">        v5.y = nextNeighbor.Position.y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cell.Elevation &lt;= neighbor.Elevation)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cell.Elevation &lt;= nextNeighbor.Elevation)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//这里使用EdgeVertices计算的顶点来构建矩形</span></span><br><span class="line">                TriangulateCorner(e1.v4, cell, e2.v4, neighbor, v5, nextNeighbor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//这里使用EdgeVertices计算的顶点来构建矩形</span></span><br><span class="line">                TriangulateCorner(v5, nextNeighbor, e1.v4, cell, e2.v4, neighbor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (neighbor.Elevation &lt;= nextNeighbor.Elevation)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里使用EdgeVertices计算的顶点来构建矩形</span></span><br><span class="line">            TriangulateCorner(e2.v4, neighbor, v5, nextNeighbor, e1.v4, cell);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这里使用EdgeVertices计算的顶点来构建矩形</span></span><br><span class="line">            TriangulateCorner(v5, nextNeighbor, e1.v4, cell, e2.v4, neighbor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　至此，我们就完成了新方法的封装，这样在细分六边形三角面片、构建双色连接区域的时候，就不用在方法内部计算每个顶点的位置了。接下来的一章中，我们在这个基础上，完成阶梯状连接区域的细分。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/5d8981eed326d0ae687c424f89cc15c4607de765">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>4-12 阶梯连接区域的细分</title>
    <url>/2020/11/16/HexMap/4-12%20%E9%98%B6%E6%A2%AF%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%9F%9F%E7%9A%84%E7%BB%86%E5%88%86/</url>
    <content><![CDATA[<p>　　在上一章中，我们创建了对计算细分顶点与构建三角面片的方法进行了抽象，将这些步骤分别封装在了不同的结构体和方法中。在这一章中我们将使用这些方法，来进行阶梯连接区域的细分。<br>　　要进行阶梯连接与其的细分，就需要把新的顶点信息传递到<code>TriangulateEdgeTerraces</code>方法中，在判断两个相邻地图单元连接方式为Slope时，进行阶梯状连接区域的构建。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params">HexDirection direction, HexCell cell, EdgeVertices e1</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cell.GetEdgeType(direction) == HexEdgeType.Slope)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里也使用EdgeVertices计算的顶点来构建矩形</span></span><br><span class="line">        TriangulateEdgeTerraces(e1.v1, e1.v4, cell, e2.v1, e2.v4, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，要修改<code>TriangulateEdgeTerraces</code>方法的参数列表，新的参数是与阶梯连接区域相邻的两个边，而不是一组顶点。然后假设<code>EdgeVertices</code>里有插值计算函数,这就可以让我们简化TriangulateEdgeTerraces方法而不是使其变得更复杂。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 构建阶梯状连接区域</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 这里不再使用单一的顶点，而是直接使用cell与阶梯区域相连接的边，通过计算得出边上的顶点位置以及每个顶点的颜色</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;begin&quot;&gt;</span>第一个cell与相邻阶梯化区域的边上顶点<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;beginCell&quot;&gt;</span>第一个cell的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;end&quot;&gt;</span>第二个cell与相邻阶梯化区域的边上顶点<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;endCell&quot;&gt;</span>第二个cell的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateEdgeTerraces</span>(<span class="params">EdgeVertices begin, HexCell beginCell, EdgeVertices end, HexCell endCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过插值计算出相邻cell边的每个坐标点</span></span><br><span class="line">    EdgeVertices e2 = EdgeVertices.TerraceLerp(begin, end, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//通过插值计算出相邻cell边每个坐标点的颜色</span></span><br><span class="line">    Color c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建阶梯的第一段</span></span><br><span class="line">    TriangulateEdgeStrip(begin, beginCell.color, e2, c2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环生成中间部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; HexMetrics.terraceSteps; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        EdgeVertices e1 = e2;</span><br><span class="line">        Color c1 = c2;</span><br><span class="line">        e2 = EdgeVertices.TerraceLerp(begin, end, i);</span><br><span class="line">        c2 = HexMetrics.TerraceLerp(beginCell.color, endCell.color, i);</span><br><span class="line">        TriangulateEdgeStrip(e1, c1, e2, c2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建阶梯的最后一段</span></span><br><span class="line">    TriangulateEdgeStrip(e2, c2, end, endCell.color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最后，回到<code>EdgeVertices.cs</code>中，创建<code>TerraceLerp</code>方法，这个方法是使用插值计算阶梯连接区域中，每一段的顶点位置。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>EdgeVertices.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> EdgeVertices</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 通过两个cell的边，计算出阶梯连接区域，每一段上顶点的位置</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;a&quot;&gt;</span>阶梯连接区域起始边<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;b&quot;&gt;</span>姐弟连接区域结束边<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;step&quot;&gt;</span>插值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>插值为step时，当前段落上每个顶点的位置信息<span class="doctag">&lt;/returns&gt;</span>    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EdgeVertices <span class="title">TerraceLerp</span>(<span class="params">EdgeVertices a, EdgeVertices b, <span class="keyword">int</span> step</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        EdgeVertices result;</span><br><span class="line">        result.v1 = HexMetrics.TerraceLerp(a.v1, b.v1, step);</span><br><span class="line">        result.v2 = HexMetrics.TerraceLerp(a.v2, b.v2, step);</span><br><span class="line">        result.v3 = HexMetrics.TerraceLerp(a.v3, b.v3, step);</span><br><span class="line">        result.v4 = HexMetrics.TerraceLerp(a.v4, b.v4, step);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-12-1.png"></p>
<p>　　至此，我们就完成了经过细分之后阶梯连接区域的构建。在下一章中，我们将修复之前暂缓的斜面与阶梯连接区域破面的问题。</p>
<p>[Github代码](</p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>4-13 修复CSS和SCS连接类型的破面</title>
    <url>/2020/11/17/HexMap/4-13%20%E4%BF%AE%E5%A4%8DCSS%E5%92%8CSCS%E8%BF%9E%E6%8E%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%A0%B4%E9%9D%A2/</url>
    <content><![CDATA[<p>　　在上一章中，我们完成了细分后阶梯连接区域的构建。当我们改变地图单元高度的时候，会发现Cliff与Slope类型之间的三角形连接区域，依然会有破面的问题这也是我们之前一直搁置的一个问题。在这一章中，我们先解决<code>cliff-slope-slope (CSS)</code>和<code>slope-cliff-slope (SCS)</code>两种连接类型种产生破面的问题。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-13-1.png"></p>
<p>　　产生破面的问题是因为分界点（阶梯连接收束到陡峭面边缘的顶点）的计算受到了干扰。这意味着它不是精确的处于陡峭面的边缘线上，所以就产生了一个裂缝。解决方案是不要对分界点应用噪声扰动，就是说我们需要能选择一个点是否应用扰动。最简单的办法是在<code>HexMesh.cs</code>中添加一个完全不对顶点进行扰动的<code>AddTriangle</code>方法。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMesh</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 添加单个三角面片的顶点位置信息和索引，顶点不扰动！</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;v1&quot;&gt;</span>顺时针 第一个顶点的Vector3<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;v2&quot;&gt;</span>顺时针 第二个顶点的Vector3<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;v3&quot;&gt;</span>顺时针 第三个顶点的Vector3<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddTriangleUnperturbed</span>(<span class="params">Vector3 v1, Vector3 v2, Vector3 v3</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span> vertexIndex = vertices.Count;</span><br><span class="line">        vertices.Add(v1);</span><br><span class="line">        vertices.Add(v2);</span><br><span class="line">        vertices.Add(v3);</span><br><span class="line">        triangles.Add(vertexIndex);</span><br><span class="line">        triangles.Add(vertexIndex + <span class="number">1</span>);</span><br><span class="line">        triangles.Add(vertexIndex + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　修改<code>TriangulateBoundaryTriangle</code>方法中的语句，在使用边界点构建三角面片时，边界点不在进行扰动。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateBoundaryTriangle</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 boundary, Color boundaryColor</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3 v2 = HexMetrics.TerraceLerp(begin, left, <span class="number">1</span>);</span><br><span class="line">    Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里收束到边界点的时候，边界点不再进行扰动</span></span><br><span class="line">    AddTriangleUnperturbed(Perturb(begin), Perturb(v2), boundary);</span><br><span class="line">    AddTriangleColor(beginCell.color, c2, boundaryColor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; HexMetrics.terraceSteps; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 v1 = v2;</span><br><span class="line">        Color c1 = c2;</span><br><span class="line">        v2 = HexMetrics.TerraceLerp(begin, left, i);</span><br><span class="line">        c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i);</span><br><span class="line">        <span class="comment">//AddTriangle(v1, v2, boundary);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里收束到边界点的时候，边界点不再进行扰动</span></span><br><span class="line">        AddTriangleUnperturbed(Perturb(v1), Perturb(v2), boundary);</span><br><span class="line">        AddTriangleColor(c1, c2, boundaryColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里收束到边界点的时候，边界点不再进行扰动</span></span><br><span class="line">    AddTriangleUnperturbed(Perturb(v2), Perturb(left), boundary);</span><br><span class="line">    AddTriangleColor(c2, leftCell.color, boundaryColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　仔细观察<code>TriangulateBoundaryTriangle</code>方法可以发现，我们并没没有用<code>v2</code>去计算其他点的位置。所以在这里我们可以直接先对v2进行扰动，这样就简化了之后调用v2的代码了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateBoundaryTriangle</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 boundary, Color boundaryColor</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//由于在此方法中，并没有用v2继续计算其他顶点，所以在这里先对v2进行扰动，之后代码中直接使用</span></span><br><span class="line">    Vector3 v2 = Perturb(HexMetrics.TerraceLerp(begin, left, <span class="number">1</span>));</span><br><span class="line">    Color c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里收束到边界点的时候，边界点不再进行扰动</span></span><br><span class="line">    AddTriangleUnperturbed(Perturb(begin), Perturb(v2), boundary);</span><br><span class="line">    AddTriangleColor(beginCell.color, c2, boundaryColor);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; HexMetrics.terraceSteps; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 v1 = v2;</span><br><span class="line">        Color c1 = c2;</span><br><span class="line">        v2 = HexMetrics.TerraceLerp(begin, left, i);</span><br><span class="line">        c2 = HexMetrics.TerraceLerp(beginCell.color, leftCell.color, i);</span><br><span class="line">        <span class="comment">//AddTriangle(v1, v2, boundary);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用扰动后的v2点</span></span><br><span class="line">        AddTriangleUnperturbed(Perturb(begin), v2, boundary);</span><br><span class="line">        AddTriangleColor(c1, c2, boundaryColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用扰动后的v2点</span></span><br><span class="line">    AddTriangleUnperturbed(v2, Perturb(left), boundary);</span><br><span class="line">    AddTriangleColor(c2, leftCell.color, boundaryColor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-13-2.png"></p>
<p>　　现在看起来好多了，但还是会有一些问题。在<code>TriangulateCornerTerracesCliff</code>方法里，分界点的位置是通过左右的坐标点插值计算得到的，但这两个点没有应用扰动。要让边界点能精确吻合陡峭斜坡边缘，需要插值去计算两个扰动过的坐标点来求得边界点。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerTerracesCliff</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里使用扰动后的坐标点计算分界点</span></span><br><span class="line">        Vector3 boundary = Vector3.Lerp(Perturb(begin), Perturb(right), b);</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　在<code>TriangulateCornerCliffTerraces</code>方法中也是同理，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerCliffTerraces</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell, </span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里使用扰动后的坐标点计算分界点</span></span><br><span class="line">        Vector3 boundary = Vector3.Lerp(Perturb(begin), Perturb(right), b);</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-13-3.png"></p>
<p>　　这样我们就修复了<code>cliff-slope-slope(CSS)</code>和<code>slope-cliff-slope(SCS)</code>两种连接类型种产生破面的问题。在接下来的章节中，我们来解决<code>cliff-cliff-slope</code>连接类型种破面的问题。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/8fb867fd3416665ced7e81d8c86517ddc3e82591">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>4-14 修复CCS连接类型的破面</title>
    <url>/2020/11/18/HexMap/4-14%20%E4%BF%AE%E5%A4%8DCCS%E8%BF%9E%E6%8E%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%A0%B4%E9%9D%A2/</url>
    <content><![CDATA[<p>　　在上一章中，我们修复了<code>cliff-slope-slope(CSS)</code>和<code>slope-cliff-slope(SCS)</code>两种连接类型种产生破面的问题。这样的问题。破面的问题同样也存在于<code>cliff-cliff-slope</code>连接类型中。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-14-1.png"></p>
<p>　　修复这个破面问题与上一章修复<code>CSS</code>和<code>SCS</code>连接类型破面的问题思路相同。在<code>TriangulateCornerTerracessCliff</code>方法的最后一个<code>else</code>中，不再让分界点进行扰动即可。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerTerracesCliff</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里不再扰动分界点</span></span><br><span class="line">        AddTriangleUnperturbed(Perturb(left), Perturb(right), boundary);</span><br><span class="line">        AddTriangleColor(leftCell.color, rightCell.color, boundaryColor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　同理，再起镜像位置的<code>TriangulateCornerCliffTerraces</code>方法中也不再对分界点进行扰动。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateCornerCliffTerraces</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 begin, HexCell beginCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 left, HexCell leftCell,</span></span></span><br><span class="line"><span class="function"><span class="params">    Vector3 right, HexCell rightCell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这里不再扰动分界点</span></span><br><span class="line">        AddTriangleUnperturbed(Perturb(left), Perturb(right), boundary);</span><br><span class="line">        AddTriangleColor(leftCell.color, rightCell.color, boundaryColor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-14-2.png"></p>
<p>　　这样我们就修复了所有斜面和阶梯三角形连接区域之间的破面。在下一章中，我们将会对地图整体进行参数调整，使地图看起来更加自然，为接下来的功能做准备。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/b8135e8da15aea701d9e4dbdc157124c9f05ab68">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>4-15 优化调整</title>
    <url>/2020/11/19/HexMap/4-15%20%E4%BC%98%E5%8C%96%E8%B0%83%E6%95%B4/</url>
    <content><![CDATA[<p>　　在上一章中，我们修复了所有斜面与阶梯面之间存在破面的问题。现在我们就完成了使用一张彩色噪点图，对地图中每个顶点，通过控制参数，控制其扰动的强度和范围，增加地图细节的功能。仔细观察我们现在生成的地图，每个顶点的扰动强度似乎过大了，虽然扰动强度大一些，会使每个地图单元变化更加明显，但是我们并不想让地图单元偏离太多。毕竟我们需要通过比较精确的网格来判断，我们正在编辑哪个地图单元。如下对比图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-15-1.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-15-2.png"></p>
<p>　　下图是扰动强度从小到大的效果，我们可以发现，现在地图单元的扰动强度设置为5，似乎有点太大了。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-15-3.gif"></p>
<p>　　我们将扰动强度降低到4，让所有底图单元在有一定随机的情况下又不会偏移太多，使每个顶点在XZ平面内的最大位移不超过 $\sqrt {32} \approx 5.66$。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexMetrics</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> cellPerturbStrength = <span class="number">4f</span>;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-15-4.png"></p>
<p>　　另一个可以调整的参数是地图单元中自身和颜色混合区域的比例。如果我们增大这个值，地图单元中六边形的区域就会变得更大一些。这给未来的内容留下了更多空间。下图是调整这个比例的效果：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-15-5.gif"></p>
<p>　　将这个参数增大到0.8，让六边形的面积占比更大一些，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexMetrics</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> solidFactor = <span class="number">0.75f</span>;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-15-6.png"></p>
<p>　　最后，现在的一个单位高度位5个Unity中的单位，每一级之间的高度差比较大。当我们检查网格生成是否正确时很方便，但这一步我们现在已经完成了，所以让我们把它减少到3。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexMetrics</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> elevationStep = <span class="number">3f</span>;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-15-7.png"></p>
<p>　　剩下两个可调整参数是扰动强度和每一级阶梯的步长，这两个参数已经比较符合我们的预期，保持不变。<br>　　至此我们就完成了对地图整体效果的调整。在接下来的章节中，我们将会创建尺寸更大的地图，并且添加更多的地图编辑器功能。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-15-8.png"></p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/f5f54a96a12a3f47613b5afcbc132aa756b5b079">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>4-2 纹理采样</title>
    <url>/2020/11/06/HexMap/4-2%20%E7%BA%B9%E7%90%86%E9%87%87%E6%A0%B7/</url>
    <content><![CDATA[<p>　　在上一章中，我们导入了一张RGB噪点图，并完成了噪点图的相关导入设置，在本章中，我们将创建一些基础的方法，来获取噪点图的实例。<br>　　首先我们要在<code>HexMetrics.cs</code>中添加一个静态方法，用来读取彩色噪点图中的各类信息，并进行相关操作。因为创建的方法是静态方法，所以其引用的噪点图变量也必须是静态的。这样，我们就可以在程序的任意位置调用这个方法了。</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexMetrics</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//彩色噪点图的实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Texture2D noiseSource;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　由于<code>HexMetrics.cs</code>并未继承MonoBehaviour，所以它不是一个组件，其中的变量也不能在Inspector面板中显示。我们也不能像普通变量那样，直接使用拖拽实例放入变量在Inspector面板的位置上进行赋初始值。那我们就简单地把HexGrid当一个中转，因为HexGrid是第一个运行的,所以在它的Awake方法开始的位置传递值就行了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexGrid</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//彩色噪点图的实例，直接将图片拖拽至Inspector面板对应位置赋初始值</span></span><br><span class="line">    <span class="keyword">public</span> Texture2D noiseSource;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//为HexMetrics的静态变量赋值</span></span><br><span class="line">        <span class="comment">//由于此脚本最先被调用，所以在这里赋初始值</span></span><br><span class="line">        HexMetrics.noiseSource = noiseSource;</span><br><span class="line">        </span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　在Play模式下，如果我们想要引用另一个彩色噪点图，那么在<code>Awake</code>的赋值语句就不起作用了。要解决这个问题还需要在<code>OnEnable</code>方法中重新赋值彩色噪点图的实例。</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexGrid</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">OnEnable</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//Unity在Play模式中，Awake只会在脚本被实例化时调用一次，如果之后噪点图改变了，没办法重新为静态变量赋值</span></span><br><span class="line">        <span class="comment">//所以这里再次进行赋值，之后只要disable后在enable，静态变量就会被重新赋值</span></span><br><span class="line">        HexMetrics.noiseSource = noiseSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-2-1.png"></p>
<p>　　现在<code>HexMetrics.cs</code>就能访问彩色纹理贴图了,我们添加一个方便的噪声采样方法，这个方法用来读取彩色噪点图，并返回一个包含四种噪声模式的4D向量。代码如下</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexMetrics</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 对彩色噪点图进行采样</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;position&quot;&gt;</span>采样点位置坐标，世界坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>RGBA四个值组成的4D向量<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector4 <span class="title">SampleNoise</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，我们完成来<code>SampleNoise</code>方法。通过双线性过滤的方式对彩色纹理图进行采样得到样本数据，由于是使用世界坐标系下的X和Z轴坐标作为UV坐标，所以噪声源是3D的，这里我们忽略掉Y轴坐标。采样后我们得到一个可以转换成4D向量的颜色，这个转换是隐式的，这意味着我们可以直接返回颜色，而不用显式的转换成Vector4。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexMetrics</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//由于入参是世界位置的vector3，而图片UV是二维的，这里忽略掉垂直方向的Y</span></span><br><span class="line">    <span class="comment">//GetPixelBilinear获取的是指定点的RGBA值，转换为Vector4是隐式的。</span></span><br><span class="line">    <span class="keyword">return</span> noiseSource.GetPixelBilinear(position.x, position.z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　至此。我们通过世界坐标内的一个点，就能获取到彩色噪点图中对应位置的RGBA值，这样我们就完成了采样的工作。在接下来的章节中，我们将利用采样得到的数据，对地图上的顶点进行偏移，也就是扰动。就会让地图产生更多的变化。</p>
<blockquote>
<p><a href="https://baike.baidu.com/item/%E5%8F%8C%E7%BA%BF%E6%80%A7%E8%BF%87%E6%BB%A4/8137007">双线性过滤</a><br>Jasper Flick大神有专门介绍UV的教程：<a href="https://catlikecoding.com/unity/tutorials/rendering/part-2/">Rendering 2 Shader Fundamentals</a>，里面详细介绍了UV坐标和纹理的相关知识。</p>
</blockquote>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/cdce76293d0d19e3a7895eb9ef82c07bffeecdf2">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>4-3 顶点扰动</title>
    <url>/2020/11/07/HexMap/4-3%20%E9%A1%B6%E7%82%B9%E6%89%B0%E5%8A%A8/</url>
    <content><![CDATA[<p>　　在上一章中，我们使用世界坐标中的一个点，在彩色噪点图上进行采样，得到了一个4D向量。在这一章中，我们使用这个4D向量，对地图内的各个顶点进行扰动，让地图看起来有更多的变化。我们回到<code>HexMesh.cs</code>中，在这里我们添加一个方法<code>Perturb </code>来负责这个工作。这个方法使用一个世界坐标内的点，进行扰动后，返回扰动后的坐标。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMesh</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 通过世界内的一个点(vector3)，经过彩色噪点图扰动后，返回扰动后的Vect3</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;position&quot;&gt;</span>世界坐标内的点<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>经过噪点图扰动后的点坐标<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Vector3 <span class="title">Perturb</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//利用世界空间内一点，在彩色噪点图上进行采样，得到彩色噪点图内一点的RGBA信息</span></span><br><span class="line">        Vector4 sample = HexMetrics.SampleNoise(position);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　通过世界坐标采样完成后，我们先使用原始坐标加采样坐标的方式获得新的扰动后坐标，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Vector3 <span class="title">Perturb</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用原始坐标加上噪点图的采样坐标，得到扰动后坐标</span></span><br><span class="line">    position.x += sample.x;</span><br><span class="line">    position.y += sample.y;</span><br><span class="line">    position.z += sample.z;</span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　那么要如何快速的让地图中所有顶点都产生扰动？只需要在<code>AddTriangle</code>和<code>AddQuad</code>里添加顶点到列表中时修改每个顶点就行了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddTriangle</span>(<span class="params">Vector3 v1, Vector3 v2, Vector3 v3</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vertexIndex = vertices.Count;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的坐标变为扰动后的坐标</span></span><br><span class="line">    vertices.Add(Perturb(v1));</span><br><span class="line">    vertices.Add(Perturb(v2));</span><br><span class="line">    vertices.Add(Perturb(v3));</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddQuad</span>(<span class="params">Vector3 v1, Vector3 v2, Vector3 v3, Vector3 v4</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> vertexIndex = vertices.Count;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的坐标变为扰动后的坐标</span></span><br><span class="line">    vertices.Add(Perturb(v1));</span><br><span class="line">    vertices.Add(Perturb(v2));</span><br><span class="line">    vertices.Add(Perturb(v3));</span><br><span class="line">    vertices.Add(Perturb(v4));</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-3-1.png"></p>
<blockquote>
<p>为什么顶点扰动后四边形依然是平坦的？<br>很可能并不是。这些四边形由两个不再对齐的三角形构成，因为这些三角形共享两个顶点，这些顶点的法线会平滑变化。这意味着你看不到两个三角形之间的明显过渡，如果扭曲的不是太明显，视觉效果上仍然会感觉这个四边形是平的。</p>
</blockquote>
<p>　　经过扰动后看起来好像没多大变化，除了单元格的坐标数字不见了之外。这是因为我们把顶点加上了噪声采样的坐标，这些坐标的计算结果总是正值，所以所有三角形都在标签上方并覆盖了它们。所以我们需要把采样的范围控制在-1至1之间。代码如下</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Vector3 <span class="title">Perturb</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将采样后的扰动结果控制在1到-1之间</span></span><br><span class="line">    position.x += sample.x * <span class="number">2f</span> - <span class="number">1f</span>;</span><br><span class="line">    position.y += sample.y * <span class="number">2f</span> - <span class="number">1f</span>;</span><br><span class="line">    position.z += sample.z * <span class="number">2f</span> - <span class="number">1f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-3-2.png"></p>
<p>　　现在我们就完成了通过一张彩色噪点图进行采样，并对地图中每个顶点进行伪随机的扰动。但是现在的扰动范围只是在-到-1之间，效果并不是很明显，在接下来的一章中，我们将加入新的参数，来控制扰动的强度。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/f7eb136ab9cea033d018e75cb24fb23d2a5b4ed1">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>4-4 扰动强度</title>
    <url>/2020/11/08/HexMap/4-4%20%E6%89%B0%E5%8A%A8%E5%BC%BA%E5%BA%A6/</url>
    <content><![CDATA[<p>　　在上一章中，我们同归在彩色噪点图中进行采样，完成了对地图上所有顶点的扰动，但是最终的视觉效果恨不明显。按照之前的代码来看，一个顶点在每个维度上最大位移距离只有1，所以每个顶点扰动的最大位移只有 $\sqrt3 \approx 1.73$ 的单位长度，而且极限位移情况产生的概率还非常低。相较于每个地图单元10的外径来说，这个扰动太小了。<br>　　解决这个问题的方式也很简单，就是在<code>HexMetrics.cs</code>中加如一个扰动强度值。让我们先把扰动强度是指为5，这样理论上一个顶点的最大位移距离就有 $\sqrt5 \approx 8.66$ 单位长度。最终扰动结果就会明显很多了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexMetrics</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//扰动强度</span></span><br><span class="line">    <span class="comment">//这个值是一个坐标点在每个轴向上的偏移强度</span></span><br><span class="line">    <span class="comment">//最大偏移量就是 √￣(3*5^2) ≈ 8.66</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> cellPerturbStrength = <span class="number">5f</span>;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　回到<code>HexMesh.Perturb</code>方法中，通过相乘的方式应用采样数据。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Vector3 <span class="title">Perturb</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//增加了每个点的扰动强度</span></span><br><span class="line">    position.x += (sample.x * <span class="number">2f</span> - <span class="number">1f</span>) * HexMetrics.cellPerturbStrength;</span><br><span class="line">    position.y += (sample.y * <span class="number">2f</span> - <span class="number">1f</span>) * HexMetrics.cellPerturbStrength;</span><br><span class="line">    position.z += (sample.z * <span class="number">2f</span> - <span class="number">1f</span>) * HexMetrics.cellPerturbStrength;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　再次运行后我们看到，增加了扰动强度之后，每个顶点的偏移就变得非常明显了。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-4-1.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-4-2.png"></p>
<p>　　但是当我们升高某个地图单元的时候，产生了一些奇怪的视觉效果，阶梯状的矩形连接变得非常扭曲，某些相邻的地图单元之间，连接部分甚至会有破面的情况发生。在接下来的章节中，我们来解决这个问题。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/e53dcbabf3c9f0a6599b338e9b56480985d09e80">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>4-5 噪声采样缩放</title>
    <url>/2020/11/09/HexMap/4-5%20%E5%99%AA%E5%A3%B0%E9%87%87%E6%A0%B7%E7%BC%A9%E6%94%BE/</url>
    <content><![CDATA[<p>　　在上一章中，我们增强了扰动强度，使每个顶点的位移更大，最终地图整体的变化效果就更加明显了。但是当我们改变一个地图单元高度的时候，我们发现矩形阶梯连接区域的视觉效果变得非常奇怪。阶梯中的各个顶点向不懂的方向偏移，造成了三角面片的扭曲，视觉效果看起来很混乱。但是使用柏林噪声不应该会发生这种情况。<br>　　造成这个现象的原因是因为我们直接用世界坐标进行噪声采样，使得彩色噪点图平铺在每个地图单元上，但是每个地图单元的尺寸比彩色噪点图本身要大得多，实际上彩色噪点图是在任意位置被采样，这破坏了其连贯性。如下图所示，其中每个蓝色的方块表示一张彩色噪点图。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-5-1.png"></p>
<p>　　为了解决这个问题，我们要对噪声采样进行缩放，这样彩色噪点图就能覆盖更大的区域。我们在<code>HexMetrics.cs</code>中添加这个缩放并设置其为0.003，然后把采样坐标与这个数值相乘。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexMetrics</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//采样缩放</span></span><br><span class="line">    <span class="comment">//这个参数的实际作用，就是将时间空间内坐标缩小一定倍率</span></span><br><span class="line">    <span class="comment">//实际上是变相扩大了一张噪点图的覆盖范围，使得进行采样时更加连续</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> noiseScale = <span class="number">0.003f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector4 <span class="title">SampleNoise</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//实际世界空间坐标乘以缩放系数，使得采样控制在一个比较小的范围内，这样就会比较连续</span></span><br><span class="line">        <span class="keyword">return</span> noiseSource.GetPixelBilinear(</span><br><span class="line">            position.x * noiseScale,</span><br><span class="line">            position.z * noiseScale</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，采样数据的范围就是原来的 $333 \frac 33$ 倍，最终运行后的诗句效果也变得更加平滑了。即使再次改变地图单元的高度，也不会出现那种很奇怪的阶梯状三角面片了。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-5-2.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-5-3.png"></p>
<p>　　加入了采样缩放之后，噪声在平铺之前有个过渡过程。实际上因为单元格的内径是 $10 \sqrt 3 $，所以没有办法精确的以X轴的尺寸平铺。但是因为噪声纹理自身的连贯性，即使细节不吻合，任然能在大范围内发现重复的样式，大约是每20个地图单元之间。这只在地图没有其他编辑形状的功能时才比较明显。<br>　　至此，我们修复了采样中的连续性问题，但是在还存在一个问题，就是每个地图单元的正六边形部分，并不是平整的，这一点从对UI的坐标点遮挡就可以看出来。我们想达到的效果是，六边形边缘部分的顶点会产生扰动，但是六边形自身还保持平整。这个问题将会在下一章解决。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/9e8a07a724cd61929b5d49e621abbf79ce13c856">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>4-6 平整地图单元表面</title>
    <url>/2020/11/10/HexMap/4-6%20%E5%B9%B3%E6%95%B4%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E8%A1%A8%E9%9D%A2/</url>
    <content><![CDATA[<p>　　在上一章中，我们对采样范围进行了缩放。通过调整一个参数，控制彩色噪点图对地图的覆盖范围，解决了当一个地图单元高度变化的时候，它的矩形阶梯状连接区域顶点更加平滑，不会出现一些看起来很奇怪的三角面片了。不过我们仔细观察整个地图的时候，发现每个地图单元的六边形部分并不平整，这种效果并不是我们想要的。这一章我们将修复这个问题。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-6-1.png"></p>
<p>　　要让每个地图单元的六边形部分变得平坦其实很简单，只要我们在<code>HexMesh.Perturb</code>方法中，对Y轴的坐标不进行扰动即可，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Vector3 <span class="title">Perturb</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    position.x += (sample.x * <span class="number">2f</span> - <span class="number">1f</span>) * HexMetrics.cellPerturbStrength;</span><br><span class="line">    <span class="comment">//为了让cell表面变得平坦，这里不再在垂直方向上进行扰动。</span></span><br><span class="line">    <span class="comment">//position.y += (sample.y * 2f - 1f) * HexMetrics.cellPerturbStrength;</span></span><br><span class="line">    position.z += (sample.z * <span class="number">2f</span> - <span class="number">1f</span>) * HexMetrics.cellPerturbStrength;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-6-2.png"></p>
<p>　　现在，所有地图单元与阶梯每一层的顶点在Y轴方向上都不会发生扰动了。但是要注意一点，现在地图中所有顶点的最大扰动距离都减小到了 $\sqrt {50} \approx 7.07$ ，并且只在XZ平面扰动了。不过这样的改动并没有什么不妥当的地方，反而实现了在扰动的同时不影响对每个地图单元坐标的识别。<br>　　现在我们就完成了平整每个地图单元表面的工作。但是经过观察我们发现，在Slope-Cliff连接类型的地图单元之间，有些三角形连接区域出现了破面的问题，而且取消了地图上所有顶点在Y轴的扰动也并不是一个好办法。这些问题我们在之后的章节来解决。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/3aea22524d6fb9f3d6fbff6a364a49b0565c1bd1">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>4-7 地图单元的垂直方向扰动</title>
    <url>/2020/11/11/HexMap/4-7%20%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E7%9A%84%E5%9E%82%E7%9B%B4%E6%96%B9%E5%90%91%E6%89%B0%E5%8A%A8/</url>
    <content><![CDATA[<p>　　在上一章中，我们取消了地图中所有顶点垂直方向的扰动，这样每个地图单元的六边形部分有变得平整了。但是取消垂直方向的扰动并不是一个好办法，我们应该让垂直方向的扰动作用在整个地图单元上，而不是单一的顶点。这样既保留了每个地图单元平坦的表面，又能让不同的地图单元之间存在差别。<br>　　按照这个思路，比较好的做法是对一个地图单元海拔高度进行扰动，并且使用一个强度系数来控制扰动的缩放比例。在<code>HexMetrics.cs</code>里添加一个强度系数。1.5的值就能使不同的地图单元之间存在一些差别，这大概是一级阶梯的高度。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Elevation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//海拔高度扰动强度系数</span></span><br><span class="line">    <span class="comment">//为了保持cell顶部六边形的平坦，这里不再对cell的每个顶点单独进行垂直方向的扰动</span></span><br><span class="line">    <span class="comment">//改为对一个cell整体海拔高度进行扰动，然后再乘以一个强度系数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> elevationPerturbStrength = <span class="number">1.5f</span>;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，我们回到<code>HexCell.Elevation</code>的<code>set</code>属性中，在这里设置每个地图单元海拔高度的时候，进行扰动，并乘以强度系数。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Elevation</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        elevation = <span class="keyword">value</span>;</span><br><span class="line">        Vector3 position = transform.localPosition;</span><br><span class="line">        position.y = <span class="keyword">value</span> * HexMetrics.elevationStep;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里对cell整体的海拔高度进行扰动，并乘以强度系数</span></span><br><span class="line">        position.y += (HexMetrics.SampleNoise(position).y * <span class="number">2f</span> - <span class="number">1f</span>) * HexMetrics.elevationPerturbStrength;</span><br><span class="line"></span><br><span class="line">        transform.localPosition = position;</span><br><span class="line"></span><br><span class="line">        Vector3 uiPosition = uiRect.localPosition;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//同样，UI也是扰动后的高度</span></span><br><span class="line">        uiPosition.z = -position.y;</span><br><span class="line"></span><br><span class="line">        uiRect.localPosition = uiPosition;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最后，我们需要在地图初始化的时候，就对每个地图单元的海拔高度进行扰动，额否则的话地图在刚被创建的时候，整体都是平坦的。我们在<code>HexGrid.CreateCell</code>方法中，UI创建后初始化每个地图单元的高度。代码如下：<br>　　这里还需要注意一点，在<code>HexGrid.Awake</code>方法中，要先执行<code>HexMetrics.noiseSource = noiseSource;</code>语句，然后再执行地图单元创建的语句。否则在创建地图单元的时候，就会有一个空引用的错误，因为在创建地图单元的时候我们还没有获取彩色噪点图。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在地图初始状态下，每个cell的海拔高度都经过扰动</span></span><br><span class="line">    cell.Elevation = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-7-1.png"></p>
<p>　　至此我们就完成了地图单元高度的扰动。我们发现当一个地图单元高度产生变化的时候，与之相邻的矩形和三角形连接区域，并没有升高到其对应的高度，这个问题我们将在下一章解决。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/ecbe7393dc2350f96b6ee0bcfe3463bb777ac87b">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>4-8 修复连接区域</title>
    <url>/2020/11/12/HexMap/4-8%20%E4%BF%AE%E5%A4%8D%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<p>　　在上一章中，我们完成了对每个地图单元整体进行海拔高度的扰动，但是我们在改变地图单元高度的时候，发现其相邻的连接区域并没有与地图单元相连接，产生了大量的破面。这是因为在构建连接区域的时候，并没有使用地图单元扰动后的高度。在<code>HexCell.cs</code>中我们添加一个属性，这样就可以在任何地方得到地图单元扰动后的坐标了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取cell在扰动后的实际坐标位置</span></span><br><span class="line">    <span class="keyword">public</span> Vector3 Position</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> transform.localPosition;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，我们就能在<code>HexMesh.Triangulate</code>方法中使用这个属性，来获得地图单元扰动后的位置了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里是获cell扰动后的位置</span></span><br><span class="line">    Vector3 center = cell.Position;</span><br><span class="line">        </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接着，在<code>TriangulateConnection</code>方法中，获取相邻地图单元位置时，也使用扰动后的坐标。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 v1, Vector3 v2</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    Vector3 v3 = v1 + bridge;</span><br><span class="line">    Vector3 v4 = v2 + bridge;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里在获取相邻cell的位置时，也是使用了扰动后的坐标位置</span></span><br><span class="line">    v3.y = v4.y = neighbor.Position.y;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (direction &lt;= HexDirection.E &amp;&amp; nextNeighbor != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Vector3 v5 = v2 + HexMetrics.GetBridge(direction.Next());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里在获取相邻cell的位置时，也是使用了扰动后的坐标位置</span></span><br><span class="line">        v5.y = nextNeighbor.Position.y;</span><br><span class="line">        </span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-8-1.png"></p>
<p>　　至此我们修复了地图单元相邻的连接区域高度不同，产生破面的问题。但是我们观察发现，在Cliff高度差类型的连接中，三角形连接区域会与矩形连接区域之间产生破面。这是因为插值计算斜边上一点的时候，使用的是扰动之前的坐标点。这个问题我们将随着细分地图单元及其周边连接区域，提升市局效果和细节的同事进行解决。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/a0412460fec876ffdb917245e4dbb5e8f3acddb3">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>4-9 细分地图单元边缘</title>
    <url>/2020/11/13/HexMap/4-9%20%E7%BB%86%E5%88%86%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E8%BE%B9%E7%BC%98/</url>
    <content><![CDATA[<p>　　在上一章中，我们修复了连接区域和地图单元高度不同的问题。但是依然存在Cliff连接类型种三角形连接区域和矩形连接区域有破面的问题。让我们将这个问题暂缓，先进一步丰富地图的整体细节，破面的问题会在这个过程中得到修复。<br>　　让我们来观察一下地图内所有顶点经过扰动后的样子，如下如所示。经过扰动的顶点虽然产生了随机性，但是每个地图单元整体看来仍然是一个六边形，虽然这样并不影响什么，但是这样显得地图的细节不够丰富，我们应该增加细节，让地图看起来更加饱满。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-9-1.png"></p>
<p>　　要添加更多的细节，那就先从地图单元的正六边形部分开始着手。如果我们能将正六边形细分更多的面出来，经过额敖东后，就应该有更多的变化。所以我们在六边形的每个边中点上，再添加一个顶点，将之前的三角面片分为两个。这就需要修改<code>HexMesh.Triangulate</code>方法，在构建三角面片的时候添加两个三角形，而不是一个。代码如下：</p>
<figure class="highlight plain"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line">private void Triangulate(HexDirection direction, HexCell cell)</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    Vector3 v2 &#x3D; center + HexMetrics.GetSecondSolidCorner(direction);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;为了增加地图的整体细节，这里在cell六边形每个边的中点上，店家一个顶点</span><br><span class="line">    &#x2F;&#x2F;让原来的6个面片变为12个。</span><br><span class="line">    Vector3 e1 &#x3D; Vector3.Lerp(v1, v2, 0.5f);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;这里添加的顶点也变为了一个边的中点</span><br><span class="line">    &#x2F;&#x2F;这3个顶点是原来六边形一个三角面片的一半</span><br><span class="line">    AddTriangle(center, v1, e1);</span><br><span class="line">        </span><br><span class="line">    AddTriangleColor(cell.color);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;这里构建原来六边形一个三角面片的另一半</span><br><span class="line">    AddTriangle(center, e1, v2);</span><br><span class="line">    AddTriangleColor(cell.color);</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-9-2.png"></p>
<p>　　顶点加倍之后，果然细节变得更加丰富了，那么我们直接在之前六边形的一条边上增加两个顶点，也就是将一个三角面片切为三个部分，这样细节会更加丰富。代码如下：</p>
<figure class="highlight plain"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line">private void Triangulate(HexDirection direction, HexCell cell)</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    Vector3 v2 &#x3D; center + HexMetrics.GetSecondSolidCorner(direction);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;这里将正六边形的每个边均分为3份，面数是原来的3倍</span><br><span class="line">    Vector3 e1 &#x3D; Vector3.Lerp(v1, v2, 1f &#x2F; 3f);</span><br><span class="line">    Vector3 e2 &#x3D; Vector3.Lerp(v1, v2, 2f &#x2F; 3f);</span><br><span class="line"></span><br><span class="line">    AddTriangle(center, v1, e1);</span><br><span class="line">    AddTriangleColor(cell.color);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;添加新增顶点的的位置信息和颜色信息</span><br><span class="line">    AddTriangle(center, e1, e2);</span><br><span class="line">    AddTriangleColor(cell.color);</span><br><span class="line">    AddTriangle(center, e2, v2);</span><br><span class="line">    AddTriangleColor(cell.color);</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/4-9-3.png"></p>
<p>　　经过细分后，六边形地图变得细节更加丰富了，不过同时也产生了很多交错面与破面。在接下来的章节中，我们将六边形每条边上细分后产生的顶点与其相邻的连接区域进行连接。消除交错面和破面。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/9ddaa477b3fc2fa4c35849fa9e15dae05ac3905e">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>5-10 摄像机旋转控制</title>
    <url>/2020/11/28/HexMap/5-10%20%E6%91%84%E5%83%8F%E6%9C%BA%E6%97%8B%E8%BD%AC%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>　　在上一章中，我们完成了摄像机移动控制的功能，并为摄像机的移动范围作出了限制。在这一章中我们将完成摄像机旋转控制的相关功能。<br>　　摄像机的旋转并不像移动那样与视距有一定的关联性，所以只需要创建一个<code>rotationSpeed</code>变量即可，默认值为180。在<code>Update</code>中通过检测<code>Rotation</code>的输入增量，来控制旋转角度。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//camera的旋转速率</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">float</span> rotationSpeed;</span><br><span class="line"></span><br><span class="line">…    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//检测 旋转 按键按下</span></span><br><span class="line">    <span class="comment">//默认在project settings -&gt; input 中没有Rotation输入检测，需要添加</span></span><br><span class="line">    <span class="keyword">float</span> rotationDelta = Input.GetAxis(<span class="string">&quot;Rotation&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (rotationDelta != <span class="number">0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        AdjustRotation(rotationDelta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">…</span><br><span class="line">    </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 控制camera旋转</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;delta&quot;&gt;</span>旋转输入增量<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustRotation</span>(<span class="params"><span class="keyword">float</span> delta</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　代码编译完成后，将<code>rotationSpeed</code>初始值设置为180，如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-10-1.png"></p>
<p>　　这里需要注意，在默认的输入配置中并没有<code>Rotation</code>相关配置，我们必须在 Project Settings 面板的 Input Manager选项卡中添加<code>Rotation</code>相关配置。这里我们使用 Q 和 E、英文句号和逗号来作为按键输入。配置如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-10-2.png"></p>
<p>　　与控制摄像机俯仰角类似，我们横向旋转摄像机，其实是在旋转<code>Hex Map Camera</code>对象。通过时间增量计算出旋转角度，再对摄像机进行旋转即可。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//用于记录旋转角度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> rotationAngle;</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustRotation</span>(<span class="params"><span class="keyword">float</span> delta</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过时间增量获取旋转角度</span></span><br><span class="line">    rotationAngle += delta * rotationSpeed * Time.deltaTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//旋转根节点物体即可达到旋转camera视角的效果</span></span><br><span class="line">    transform.localRotation = Quaternion.Euler(<span class="number">0f</span>, rotationAngle, <span class="number">0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　因为旋转一圈是360度，所以我们要将旋转角度的范围控制在0到360度之间。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustRotation</span>(<span class="params"><span class="keyword">float</span> delta</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rotationAngle += delta * rotationSpeed * Time.deltaTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将旋转角度控制在0-360之间</span></span><br><span class="line">    <span class="keyword">if</span> (rotationAngle &lt; <span class="number">0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rotationAngle += <span class="number">360f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rotationAngle &gt;= <span class="number">360f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rotationAngle -= <span class="number">360f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    transform.localRotation = Quaternion.Euler(<span class="number">0f</span>, rotationAngle, <span class="number">0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-10-3.gif"></p>
<p>　　代码完成后，我们就可以通过键盘Q和E键对视角进行旋转了。但是还有一个问题，当我们旋转了视角之后，摄像机的方向并没有改变，例如我们将视角旋转180度之后，按下W键本应该向前移动，却在向后移动。所以我们要在摄像机旋转的时候，重新计算摄像机的移动方向。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustPosition</span>(<span class="params"><span class="keyword">float</span> xDelta, <span class="keyword">float</span> zDelta</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//camera的移动方向</span></span><br><span class="line">    Vector3 direction = transform.localRotation * <span class="keyword">new</span> Vector3(xDelta, <span class="number">0f</span>, zDelta).normalized;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-10-4.gif"></p>
<p>　　至此，我们就完成了摄像机的旋转、移动与视距控制。在对摄像机的视角控制时，我们并未直接对<code>Main Camera</code>物体进行操作，而是将旋转、移动、视距这些操作分别对应了3个不同的对象，保证了在进行旋转或位移时这些对象的变化不会互相影响。在下一章中，我们将对现有的地图编辑器功能进行拓展，为其增加一些新的功能，以适应现在尺寸更大的地图。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/003ac3b3336d227550df6a257dac96e36f234439">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>5-11 高度与颜色编辑可选功能</title>
    <url>/2020/11/29/HexMap/5-11%20%E9%AB%98%E5%BA%A6%E4%B8%8E%E9%A2%9C%E8%89%B2%E7%BC%96%E8%BE%91%E5%8F%AF%E9%80%89%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>　　现在我们可以创建更大尺寸的地图了，但是地图编剧工具的功能并没有任何变化。首先是对地图单元上色和调整高度是同时进行的。其次因为有了更大的地图，一次编辑一个地图单元显得过于繁琐。在这一章中，我们先实现编辑高度与颜色功能变为可选，也就是在点击一个地图单元的时候，可以选择只改变其颜色或者只改变其高度。<br>　　这个功能可以通过添加一个toggle组来实现。复制一个颜色选项卡并将标签名改为“—”或者其他字符，与颜色选择的勾选框文字进行区分。然后设置其OnValueChanged事件传递参数为-1。此选项目的是用来取消选中颜色。如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-11-1.png"></p>
<p>　　-1对于颜色数组来说是一个无效的下标，我们可以根据这个数值确定是否对地图单元进行颜色修改。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//表示当前是否可以修改cell的颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> applyColor;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SelectColor</span>(<span class="params"><span class="keyword">int</span> _index</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//当传入的索引值大于0的时候，才会获取当前选中的颜色</span></span><br><span class="line">        applyColor = _index &gt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (applyColor)</span><br><span class="line">        &#123;</span><br><span class="line">            activeColor = colors[_index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EditCell</span>(<span class="params">HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//当applyColor为true，也就是索引值大于等于0，才会修改cell的颜色</span></span><br><span class="line">        <span class="keyword">if</span> (applyColor)</span><br><span class="line">        &#123;</span><br><span class="line">            cell.Color = activeColor;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cell.Elevation = activeElevation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　修改地图单元高度使用的是一个Slider组件，在这里创建一个toggle表示是否应用高度编辑,默认设置为开启状态。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否启用修改cell高度的功能</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> applyElevation = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EditCell</span>(<span class="params">HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (applyColor)</span><br><span class="line">        &#123;</span><br><span class="line">            cell.Color = activeColor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当toggle勾选时，才会修改cell的高度</span></span><br><span class="line">        <span class="keyword">if</span> (applyElevation)</span><br><span class="line">        &#123;</span><br><span class="line">            cell.Elevation = activeElevation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　完成代码后，我们重新整理一下UI上各个组件的位置和层级结构，将所有UI都放入一个Panel中，然后再将颜色修改的UI与高度修改的UI分开，这样就显得更加整洁，也便于后期调试。如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-11-2.png"></p>
<p>　　为了让修改高度开关起效，我们需要创建一个方法，在Toggle每次勾选或取消选择时候都调用这个方法。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 当高度修改的toggle点击时，调用此方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;toggle&quot;&gt;</span>toggle当前是否被选中<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetApplyElevation</span>(<span class="params"><span class="keyword">bool</span> toggle</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        applyElevation = toggle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　完成代码后，要在Toggle组件上挂载此方法。当挂载方法时确保是使用的方法列表顶端的dynamic bool method。如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-11-3.png"></p>
<p>　　现在我们在运行时就可以选择是修改颜色还是高度，或者像之前一样同时修改。甚至可以两个都不选，尽管现在这个功能没什么用。如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-11-4.gif"></p>
<blockquote>
<p>为什么当我选择一个颜色后自动取消选择高度了？<br>这个情况发生在把所有的选项都放在一个Group时，可能是直接复制了一份颜色选项卡然后修改成高度选项卡，但没有清理Toggle组件的Group。</p>
</blockquote>
<p>　　至此，我们就完成了单独进行高度和颜色的可选编辑功能，虽然这个功能现在看上去好像没什么用。但是随着编辑器的功能不断增多，这个功能将在之后体现出来它的作用。在下一章中，我们将定义一个笔刷大小，用来批量修改地图单元的颜色或高度。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/bda7f8778241ae754f5d9a50582e6ae5e01e4960">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>5-12 笔刷尺寸</title>
    <url>/2020/11/30/HexMap/5-12%20%E7%AC%94%E5%88%B7%E5%B0%BA%E5%AF%B8/</url>
    <content><![CDATA[<p>　　在上一章中，我们将修改地图单元的高度和颜色这两个功能，通过选中与取消选中的方式进行了分离。现在可以只对地图单元进行高度编辑，或者只进行颜色编辑。现在，随着地图尺寸的增加，我们只对单个的地图单元修改，就显得非常繁琐，效率也很低。在本章中，我们来创建一个“笔刷”功能，使用户可以调整笔刷尺寸，来批量对地图单元进行修改。<br>　　与高度滑动条类似，我们再创建一个笔刷尺寸滑动条，如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-12-1.png"></p>
<p>　　在<code>HexMapEditor.cs</code>中，添加一个方法来读取笔刷尺寸滑动条的数值，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//笔刷的尺寸</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> brushSize;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过组件获取当前笔刷的尺寸</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetBrushSize</span>(<span class="params"><span class="keyword">float</span> size</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        brushSize = (<span class="keyword">int</span>)size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　代码完成后，回到Unity中，将笔刷尺寸滚动条的最小值设置为0，最大值设置为4，并绑定<code>SetBrushSize</code>方法，如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-12-2.png"></p>
<p>　　接下来，我们需要创建一个方法，这个方法用来调用笔刷半径内所有地图单元的<code>EditCell</code>方法。其中鼠标选中的地图单元为笔刷的中心。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleInput</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//射线起点为鼠标位置，经过主摄像机</span></span><br><span class="line">    Ray _inputRay = mainCamera.ScreenPointToRay(Input.mousePosition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测射线是否碰撞到了collider</span></span><br><span class="line">    RaycastHit _hit;</span><br><span class="line">    <span class="keyword">if</span> (Physics.Raycast(_inputRay, <span class="keyword">out</span> _hit))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//hexGrid.ColorCell(_hit.point, activeColor);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改单个cell</span></span><br><span class="line">        <span class="comment">//EditCell(hexGrid.GetCell(_hit.point));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//带笔刷 修改多个cell</span></span><br><span class="line">        EditCells(hexGrid.GetCell(_hit.point));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EditCells</span>(<span class="params">HexCell center</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们定义了笔刷尺寸的最大值和最小值，当笔刷半径为0时，就只修改鼠标当前选中的地图单元。当半径为1时，包含当前选中的地图单元和跟选中地图单元相邻的地图单元。当半径为2时，包含中心地图单元、与中心地图单元相邻的所有地图单元、以及与中心地图单元相邻地图单元外侧相邻的地图单元。如笔刷范围示意图所示，此图下方代码也要用到：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-12-3.png"></p>
<p>　　要编辑这些地图单元的高度或者颜色，我们在知道笔刷半径的情况下，就需要循环遍历笔刷覆盖的所有地图单元。那么首先就需要获取笔刷中心地图单元的坐标。这里我们可以直接使用<code>HexCoordinates</code>结构体中转换好的坐标。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EditCells</span>(<span class="params">HexCell center</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取笔刷中心的cell坐标</span></span><br><span class="line">    <span class="keyword">int</span> centerX = center.coordinates.X;</span><br><span class="line">    <span class="keyword">int</span> centerZ = center.coordinates.Z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　获取到笔刷中心地图单元的坐标后，我们需要根据这个坐标和笔刷半径，来确定其余在笔刷范围内的地图单元。这里我们先从Z坐标开始，并且将之分为两个部分，先从最底部一行开始遍历，一直遍历到笔刷中心地图单元所在的行为止。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EditCells</span>(<span class="params">HexCell center</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取笔刷中心的cell坐标</span></span><br><span class="line">    <span class="keyword">int</span> centerX = center.coordinates.X;</span><br><span class="line">    <span class="keyword">int</span> centerZ = center.coordinates.Z;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里先进行Z(横行)的遍历，而且只遍历一半</span></span><br><span class="line">    <span class="comment">//即从最底部一行开始，一直到中心cell所在的那行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　通过观察笔刷范围示意图我们可以发现，在笔刷覆盖范围内的下半部分中，最底部一行的第一个地图单元，永远和中心地图单元有相同的X坐标值。并且行数越接近中心行，每行第一个地图单元的X坐标值就越小。每一行的最后一个地图单元，其X坐标值都等于笔刷中心地图单元的X坐标值加上笔刷半径。根据这两个规律，我们就可以遍历得到每一行中在笔刷范围内的地图单元的X坐标了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EditCells</span>(<span class="params">HexCell center</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取笔刷中心的cell坐标</span></span><br><span class="line">    <span class="keyword">int</span> centerX = center.coordinates.X;</span><br><span class="line">    <span class="keyword">int</span> centerZ = center.coordinates.Z;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里先进行Z(横行)的遍历，而且只遍历一半</span></span><br><span class="line">    <span class="comment">//即从最底部一行开始，一直到中心cell所在的那行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>, z = centerZ - brushSize; z &lt;= centerZ; z++, r++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历每一行中在笔刷范围内cell的X坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = centerX - r; x &lt;= centerX + brushSize; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//通过计算后得出的坐标，获取到对应cell的实例，并对其进行高度或颜色的改变</span></span><br><span class="line">            EditCell(hexGrid.GetCell(<span class="keyword">new</span> HexCoordinates(x, z)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这里要注意，我们目前并没有<code>hexGrid.GetCell(HexCoordinates coordinates)</code>这个重载，所以需要在<code>HexGrid.cs</code>中创建这个重载方法。目的是通过地图中的一组坐标值，来获取到对应坐标值的地图单元实例。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexGrid</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 通过hexmap中的坐标，来获取cell的实例</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;coordinates&quot;&gt;</span>hexmap中cell的坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>对应hexmap坐标值的cell实例<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HexCell <span class="title">GetCell</span>(<span class="params">HexCoordinates coordinates</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">int</span> z = coordinates.Z;</span><br><span class="line">        <span class="keyword">int</span> x = coordinates.X + z / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> cells[x + z * cellCountX];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　至此，我们就可以修改一半笔刷范围内的地图单元了，如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-12-4.png"></p>
<p>　　接下来，我们只需要参考之前的逻辑，将循环进行对称，也就是从最顶端一行开始遍历，一直到除了中间行之外的上半部分所有的地图单元。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EditCells</span>(<span class="params">HexCell center</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里是通过循环补足上半部分地图单元的代码</span></span><br><span class="line">    <span class="comment">//出了避免重复排除了中间行外，其余的逻辑是完全对称的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>, z = centerZ + brushSize; z &gt; centerZ; z--, r++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = centerX - brushSize; x &lt;= centerX + r; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            EditCell(hexGrid.GetCell(<span class="keyword">new</span> HexCoordinates(x, z)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-12-5.png"></p>
<p>　　现在笔刷范围虽然完整了，但是当我们对地图进行修改的时候，如果笔刷范围延伸到地图边界之外时，就会报一个数组越界的错误。为了避免这个错误，我们在<code>HexGrid.GetCell(HexCoordinates coordinates)</code>方法中检测边界，并且当获取到不存在的地图单元时返回null。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HexCell <span class="title">GetCell</span>(<span class="params">HexCoordinates coordinates</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//为了避免产生数组越界，这里要先检查X和Z坐标是否在范围内</span></span><br><span class="line">    <span class="keyword">int</span> z = coordinates.Z;</span><br><span class="line">    <span class="keyword">if</span> (z &lt; <span class="number">0</span> || z &gt;= cellCountZ)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = coordinates.X + z / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= cellCountX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cells[x + z * cellCountX];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　并且为了防止空引用异常，在<code>HexMapEditor.EditCell(HexCell cell)</code>方法中要检查被编辑的地图单元是否有实例存在。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EditCell</span>(<span class="params">HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//cell.Color = activeColor;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//避免空引用异常，首先检查被编辑的cell是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (cell)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当applyColor为true，也就是索引值大于等于0，才会修改cell的颜色</span></span><br><span class="line">        <span class="keyword">if</span> (applyColor)</span><br><span class="line">        &#123;</span><br><span class="line">            cell.Color = activeColor;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//cell.Elevation = activeElevation;</span></span><br><span class="line">        <span class="comment">//hexGrid.Refresh();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当toggle勾选时，才会修改cell的高度</span></span><br><span class="line">        <span class="keyword">if</span> (applyElevation)</span><br><span class="line">        &#123;</span><br><span class="line">            cell.Elevation = activeElevation;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-12-6.gif"></p>
<p>　　至此，我们就完成了笔刷的基本功能，我们可以自定义笔刷大小，来批量修改地图单元的颜色或者高度，这样效率就会高很多，对用户也非常友好。在下一章中，我们将完成目前地图编辑器的最后一部分：显示和隐藏坐标值UI。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/956ed28ecd47abfceb5fe6a06a5f6e8c4952c3ec">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>5-1 地图网格块</title>
    <url>/2020/11/20/HexMap/5-1%20%E5%9C%B0%E5%9B%BE%E7%BD%91%E6%A0%BC%E5%9D%97/</url>
    <content><![CDATA[<p>　　在之前的章节中，我们使用一张彩色噪点图，并采样噪点图中的像素点，对地图中的每个顶点进行位置扰动，让地图整体看起来有一些随机性，视觉效果也更加自然。在接下来的章节中，我们将创建更大的地图区域，并为地图编辑器添加新的功能。<br>　　在Unity3D中单个mesh的顶点容量是65000个，所以我们不能把单个地图尺寸设置的过大。如果想要一张尺寸更大的地图，解决方案是将多个mesh进行拼接，也就是使用若干小块拼接成一个尺寸更大的地图。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-1-1.png"></p>
<p>　　这里我们先定义一个地图块的尺寸为$5*5$，也就是说一个地图块由25个地图单元组成。这个尺寸在<code>HexMetrics.cs</code>中进行定义。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> HexMetrics</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//应为Unity mesh最多只能有65000个顶点，想要尺寸更大的地图，就只能将多个chunk拼接起来</span></span><br><span class="line">    <span class="comment">//这里定义一个chunk的长宽各有几个cell</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">int</span> chunkSizeX = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">int</span> chunkSizeZ = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>地图块的尺寸设置成多大比较合适？<br>视情况而定，较大的地图块意味着地图块数量少，但是每个地图块的mesh中会有比较多的顶点，这会使draw calls较少。但是较小的地图块会在视锥体裁剪剔除时效率较高，绘制的三角形较少。实际方法就是先设置一个预估的大小，根据不同的需求再进行微调。</p>
</blockquote>
<p>　　接下来我们定义整个地图中长宽各有多少个地图块。这里定义地图的尺寸为$4<em>3$，也就是整个地图由12个地图块拼接组成。根据之前代码地图的尺寸定义，整个地图是由$12</em>25$，也就是300个地图单元组成。这个尺寸对于我们目前测试与查看效果是比较合适的。定义地图块尺寸在<code>HexGrid.cs</code>中的代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexGrid</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义整个地图长宽各有多少个chunk</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> chunkCountX = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> chunkCountZ = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-1-2.png"></p>
<p>　　在<code>HexGrid.cs</code>中，我们使用<code>width</code>和<code>height</code>这两个变量来初始化存储地图单元数组的大小。这里仍然要使用这两个变量，但要将它们变成私有类型。然后重命名为<code>cellCountX</code>和<code>cellCountZ</code>。使用IDE的快捷功能可以一次重命名所有出现这些变量的位置。这样在处理地图块或者单元格的个数时就会很清楚。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> HexGrid</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里使用新的变量来初始化cells的尺寸</span></span><br><span class="line">    <span class="comment">//这两个变量的值可以通过地图中有几个chunk和每个chunk的尺寸计算出来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cellCountX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cellCountZ;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　重命名完成后，<code>cellCountX</code>和<code>cellCountZ</code>的值就可以通过在<code>Awake</code>方法中地图块尺寸和地图尺寸相乘计算得出。同时，我们再将数组初始化的代码提取出来，封装成一个方法，这样让整个<code>Awake</code>方法就看起来更加整洁。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算出整个地图横向和纵向cell的个数，也就是二维数组的长和宽</span></span><br><span class="line">    cellCountX = chunkCountX * HexMetrics.chunkSizeX;</span><br><span class="line">    cellCountZ = chunkCountZ * HexMetrics.chunkSizeZ;</span><br><span class="line"></span><br><span class="line">    CreateCells();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 初始化存储cell实例的数组</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCells</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过计算出来的长和宽，对数组进行初始化</span></span><br><span class="line">    cells = <span class="keyword">new</span> HexCell[cellCountZ * cellCountX];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">0</span>, i = <span class="number">0</span>; z &lt; cellCountZ; z++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; cellCountX; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            CreateCell(x, z, i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　现在，我们就初步完成了地图网格块的设置，规定了一个大地图由多少个地图块构成，每个地图块有多少个地图单元构成，同时还对之前存储所有地图单元的数组，其初始化方式作出了调整。在下一章节中，我们将修改场景中的一些结构及组件，创建地图块Prefab，为之后在场景中生成地图块做准备。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/21f655175246ba12b8de067e67a25669736018b2">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>5-13 坐标显示UI开关</title>
    <url>/2020/12/01/HexMap/5-13%20%E5%9D%90%E6%A0%87%E6%98%BE%E7%A4%BAUI%E5%BC%80%E5%85%B3/</url>
    <content><![CDATA[<p>　　在上一章中，我们创建了笔刷功能，可以通过选择笔刷尺寸，来批量修改地图单元的颜色或高度。在这一章中，我们将做一个开关，用来隐藏或显示地图单元上的UI坐标。这是因为在之后的编辑地图中，我们并不需要时刻看到这些UI坐标，它们的存在有时候反而会妨碍我们对地图的编辑和查看。<br>　　由于整个大地图是由多个地图块拼接而成的，每一个地图块都有自己的canvas，所以需要在<code>HexGridChunk.cs</code>中添加一个<code>ShowUI</code>方法，来控制当前地图块的UI显示和隐藏。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGridChunk.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexGridChunk</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 控制当前地图块上的坐标显示UI 关闭/显示</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;visible&quot;&gt;</span>UI坐标显示状态<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowUI</span>(<span class="params"><span class="keyword">bool</span> visible</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        gridCanvas.gameObject.SetActive(visible);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　同时，在<code>Awake</code>方法中，默认关闭UI。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGridChunk.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认关闭坐标的UI显示</span></span><br><span class="line">    ShowUI(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　在地图编辑器中是通过一个按钮控制所有坐标UI的显示和隐藏，所以这里我们要在<code>HexGrid.cs</code>中也同样添加一个<code>ShowUI</code>方法，这个方法遍历所有的地图块，并控制其坐标UI的显示和隐藏。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 控制所有地图块的坐标显示UI的 显示/隐藏</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;visible&quot;&gt;</span>所有UI的显示状态<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowUI</span>(<span class="params"><span class="keyword">bool</span> visible</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chunks.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        chunks[i].ShowUI(visible);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　在<code>HexMapEditor.cs</code>中，也同样添加一个方法，供UI调用，将UI的状态传递至<code>HexGrid.cs</code>中。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 通过UI组件修改坐标UI的显示/隐藏</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;visible&quot;&gt;</span>UI坐标显示的状态<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowUI</span>(<span class="params"><span class="keyword">bool</span> visible</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hexGrid.ShowUI(visible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　回到Unity中，我们在地图编辑器中创建一个<code>Toggle</code>组件，并将<code>HexMapEditor.ShowUI</code>方法绑定到组件上即可。如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-13-1.png"></p>
<p>　　至此我们就完成了坐标显示UI开关的功能了，在程序启动时，是默认关闭所有UI显示的，通过点击最下方的<code>Label</code>开关，可以控制坐标显示UI的开启和关闭，从而达到印象或者显示全部坐标的效果。<br>　　在下一章中，我们将会对现有的UI作出一些修改，例如现在显示高度和笔刷范围，并不能看到数值，这在编辑的时候会很不方便。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/commit/92732821af9584adade3e0fa1f45c45be2cb2d5a">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>5-14 添加高度数字显示和笔刷大小数字显示</title>
    <url>/2020/12/02/HexMap/5-14%20%E6%B7%BB%E5%8A%A0%E9%AB%98%E5%BA%A6%E6%95%B0%E5%AD%97%E6%98%BE%E7%A4%BA%E5%92%8C%E7%AC%94%E5%88%B7%E5%A4%A7%E5%B0%8F%E6%95%B0%E5%AD%97%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>　　在上一章中，我们完成了坐标显示UI的关凯功能，在这一章中我们将对现有的UI作出一些调整和补充。现在的地图编辑器UI中，基本所有的元素和选项都混在一起，没有进行分类，视觉效果上并不美观。这里我们创建一个<code>Image</code>组件，宽度设置为100，高度设置为1，分别在颜色选择UI、高度选择UI、笔刷选择UI下方插入并调整它们之间的间距。这样我们对地图编辑器UI中的各项进行了分类，使视觉效果更佳清晰。如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-14-1.png"></p>
<p>　　接下来，我们在通过Slider组件调整高度和笔刷大小的时候，并不能看到确切的数值，这里我们首先在<code>HexMapEditor.cs</code>中添加两个<code>Text</code>类型的变量，用于获取UI中高度和笔刷大小的文本，在文字后方加入对应的数值显示。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//显示当前选择高度的文本</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Text elevationText = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//显示当前笔刷大小的文本</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Text brushSizeText = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置高度和笔刷大小默认显示数值</span></span><br><span class="line">        elevationText.text = <span class="string">&quot;Elevation: 0&quot;</span>;</span><br><span class="line">        brushSizeText.text = <span class="string">&quot;Brush Size: 0&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetElevation</span>(<span class="params"><span class="keyword">float</span> elevation</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在改变高度的同时，更新显示的文字信息</span></span><br><span class="line">        elevationText.text = <span class="string">&quot;Elevation: &quot;</span> + elevation.ToString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetBrushSize</span>(<span class="params"><span class="keyword">float</span> size</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在设置笔刷大小的同时，更新显示的文字信息</span></span><br><span class="line">        brushSizeText.text = <span class="string">&quot;Brush Size: &quot;</span> + size.ToString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最后，将ElevationToggle子物体中的Label与BrushSize_Text拖入对应<code>Hex Map Editor</code>变量位置即可。效果如下：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-14-2.png"></p>
<p>　　至此，我们就完成了使用多个地图块拼接大地图，以及对应的摄像机控制、高度与颜色修改功能分离、添加笔刷等功能。在接下来的章节中，我们将为现在的地图添加更多的环境细节。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/commit/be4b35659b8979e71f2591964dd41459ca628cfd">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>5-2 创建地图块Prefab</title>
    <url>/2020/11/21/HexMap/5-2%20%E5%88%9B%E5%BB%BA%E5%9C%B0%E5%9B%BE%E5%9D%97Prefab/</url>
    <content><![CDATA[<p>　　在上一章中，我们为了让地图的尺寸更大，加入了“地图块”这个概念，并添加了相关的代码。在这一章中，我们将创建地图块的Prefab，<br>　　我们需要一个新的脚本，用来执行地图块的相关逻辑。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGridChunk.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"><span class="keyword">using</span> UnityEngine.UI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexGridChunk</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来回到Unity的Hierarchy面板中，复制<code>HexGrid</code>对象并重命名为<code>HexGridChunk</code>。删除<code>HexGridChunk</code>挂载的<code>HexGrid.cs</code>脚本，并使用<code>HexGridChunk.cs</code>来代替。然后将其拖入Prefabs文件夹中创建为一个Prefab，再将场景中的<code>HexGridChunk</code>物体删除。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-2-1.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-2-2.png"></p>
<p>　　由于逻辑顺序的改变，在地图初始化的时候，首先要创建地图块。所以我们在<code>HexGrid</code>中添加对<code>HexGridChunk</code>的引用，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexGrid</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//逻辑变成了 地图初始化 -&gt; 创建chunk -&gt;创建cell</span></span><br><span class="line">    <span class="comment">//这里要先引用Chunk的Prefab</span></span><br><span class="line">    <span class="keyword">public</span> HexGridChunk chunkPrefab;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　代码部分完成后，将Prefab文件夹中<code>HexGridChunk</code>拖入到<code>HexGrid</code>组件的<code>chunkPrefab</code>栏中。如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-2-3.png"></p>
<p>　　实例化地图块的逻辑，与实例化地图单元的逻辑相类似。这里我们在<code>HexGrid</code>中创建一个数组，用来保存地图块。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexGrid</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用来存储实例化的chunk</span></span><br><span class="line">    <span class="keyword">private</span> HexGridChunk[] chunks;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        …</span><br><span class="line">        </span><br><span class="line">        CreateChunks();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 创建地图块，并将创建的实例循环添加至数组chunks中</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateChunks</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//设置数组长宽</span></span><br><span class="line">        chunks = <span class="keyword">new</span> HexGridChunk[chunkCountX * chunkCountZ];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//双循环，将创建的chunk实例添加到chunks数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">0</span>, i = <span class="number">0</span>; z &lt; chunkCountZ; z++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; chunkCountX; x++)</span><br><span class="line">            &#123;</span><br><span class="line">                HexGridChunk chunk = chunks[i++] = Instantiate(chunkPrefab);</span><br><span class="line">                chunk.transform.SetParent(transform);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　在<code>HexGridChunk</code>中实例化地图单元的思路，与之前直接在<code>HexGrid</code>中实例化地图单元类似。在<code>Awake</code>方法中设置相关参数，接着在<code>Start</code>方法中进行三角构建。与之前相同，<code>HexGridChunk</code>也需要引用其子物体的canvas和mesh组件实例，同时还需要一个数组来保存所有实例化的地图单元。不过我们在<code>HexGridChunk</code>中只是对数组进行初始化，并不会创建地图单元的实例，创建地图单元实例的步骤仍然在<code>HexGrid</code>中执行。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGridChunk.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexGridChunk</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用来存储属于自己范围内的cell实例</span></span><br><span class="line">    <span class="keyword">private</span> HexCell[] cells;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对其子物体中HexMesh 和 Canvas组件实例的引用</span></span><br><span class="line">    <span class="comment">//在Unity中，直接将其引用拖入变量对应的栏位即可</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> HexMesh hexMesh;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Canvas gridCanvas;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//设置其存储cell数组的长宽</span></span><br><span class="line">        cells = <span class="keyword">new</span> HexCell[HexMetrics.chunkSizeX * HexMetrics.chunkSizeZ];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//cell实例会由HexGrid创建</span></span><br><span class="line">        <span class="comment">//之后会将实例分配到各个HexGridChunk的数组中，这样再进行mesh的构建</span></span><br><span class="line">        hexMesh.Triangulate(cells);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　至此我们就完成了<code>HexGridChunk.cs</code>的初步功能。不过当前运行会报空引用的错误，这是因为<code>HexGridChunk</code>的<code>hexMesh.Triangulate(cells);</code>这个语句中，参数<code>cells</code>为空。在下一章中，我们将修改<code>HexGrid.cs</code>中的代码，将其创建的地图单元实例分配至各个<code>HexGridChunk</code>的数组中，这样就能解决空引用的错误了。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/43139b1a694c48b1f303feb4a7ba4eabf629b636">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>5-3 将地图单元分配到不同的地图块中</title>
    <url>/2020/11/22/HexMap/5-3%20%E5%B0%86%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E5%88%86%E9%85%8D%E5%88%B0%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9C%B0%E5%9B%BE%E5%9D%97%E4%B8%AD/</url>
    <content><![CDATA[<p>　　在上一章中，我们创建了地图块的Prefab，并完成了其相关的脚本。在最后一流了一个问题，就是<code>HexGridChunk.Start</code>方法中的<code>hexMesh.Triangulate(cells);</code>语句会报空引用的错误，这是因为地图块只创建了存放地图单元实例的数组，而这个数组是空的。创建地图单元实例的语句是在<code>HexGrid</code>中，我们需要做的就是将创建的地图单元实例添加到其对应的地图块数组中，而不是在<code>HexGrid</code>中设置其父级和进行三角构建。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">CreateCell</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, <span class="keyword">int</span> i</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    HexCell cell;</span><br><span class="line">    cells[i] = Instantiate&lt;HexCell&gt;(cellPrefab);</span><br><span class="line">    cell = cells[i];</span><br><span class="line">    <span class="comment">//这里不再对cell实例设置父级，将其分配到对应chunk后，由chunk进行实例父级的设置</span></span><br><span class="line">    <span class="comment">//cell.transform.SetParent(transform, false);</span></span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    Text label = Instantiate&lt;Text&gt;(cellLabelPrefab);</span><br><span class="line">    <span class="comment">//这里不再设置label的父级，而是将其分配到对应chunk中，由chunk进行父级的设置</span></span><br><span class="line">    <span class="comment">//label.rectTransform.SetParent(gridCanvas.transform, false);</span></span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    AddCellToChunk(x, z, cell);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 通过cell在数组中的坐标计算后，将其分配到对应的chunk中</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;x&quot;&gt;</span>cell在整体数组中的横坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;z&quot;&gt;</span>cell在整体数组中的纵坐标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cell&quot;&gt;</span>cell自身的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddCellToChunk</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们可以通过地图单元在<code>HexGrid.cells</code>数组中的横纵坐标，计算出当前地图单元应该属于哪个地图块。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddCellToChunk</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过cell整体数组的横纵坐标，计算出cell属于哪个chunk</span></span><br><span class="line">    <span class="keyword">int</span> chunkX = x / HexMetrics.chunkSizeX;</span><br><span class="line">    <span class="keyword">int</span> chunkZ = z / HexMetrics.chunkSizeZ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过计算得到的坐标，获取对应chunk的实例</span></span><br><span class="line">    HexGridChunk chunk = chunks[chunkX + chunkZ * chunkCountX];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　通过计算结果，我们还可以知道当前地图单元在其对应地图块数组中的下标。有了这个下标，我们就可以将当前地图单元实例分配到对应的地图块数组中了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddCellToChunk</span>(<span class="params"><span class="keyword">int</span> x, <span class="keyword">int</span> z, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过cell整体数组坐标，计算出其在对应chunk数组中的下标</span></span><br><span class="line">    <span class="keyword">int</span> localX = x - chunkX * HexMetrics.chunkSizeX;</span><br><span class="line">    <span class="keyword">int</span> localZ = z - chunkZ * HexMetrics.chunkSizeZ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到下标后，将cell实例添加到对应chunk的数组中</span></span><br><span class="line">    chunk.AddCell(localX + localZ * HexMetrics.chunkSizeX, cell);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接着，我们回到<code>HexGridChunk</code>中，创建<code>AddCell</code>方法。这个方法负责将地图单元实例添加到自身数组中，并且设置地图单元及其UI的父节点。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGridChunk.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 将cell实例添加到自身的数组中</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;index&quot;&gt;</span>cell在自身数组的下标<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cell&quot;&gt;</span>cell的实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddCell</span>(<span class="params"><span class="keyword">int</span> index, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过下标将cell实例添加到数组中</span></span><br><span class="line">    cells[index] = cell;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置cell和cell UI的父节点</span></span><br><span class="line">    cell.transform.SetParent(transform, <span class="literal">false</span>);</span><br><span class="line">    cell.uiRect.SetParent(gridCanvas.transform, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　至此我们就完成了将地图单元实例分配到期对应地图块中的功能了。不过现在的代码还是有一些需要清理的地方，例如在<code>HexGrid</code>中依然有进行三角构建的的相关方法。在下一章中，我们要清理这些遗留的代码，让整个地图系统正常运行。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/e84f1311ce78af2593ceda4e41c7ef1163405ab2">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>5-4 清理代码</title>
    <url>/2020/11/23/HexMap/5-4%20%E6%B8%85%E7%90%86%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>　　在上一章中，我们通过计算一个地图单元在数组中的下标，将其分配到对应的地图块中。不过现在项目中依然存在很多我们不需要的代码，在这一章中，我们将清理这些代码。<br>　　首先在<code>HexGrid</code>中清除掉<code>gridCanvas</code>和<code>hexMesh</code>这两个对象，还有与其相关的代码。如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGrid.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexGrid</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//private Canvas gridCanvas;</span></span><br><span class="line">    <span class="comment">//private HexMesh hexMesh;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="comment">//hexMesh = GetComponentInChildren&lt;HexMesh&gt;();</span></span><br><span class="line">        <span class="comment">//gridCanvas = GetComponentInChildren&lt;Canvas&gt;();</span></span><br><span class="line">    </span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private void Start()</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    hexMesh.Triangulate(cells);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//public void Refresh()</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//    hexMesh.Triangulate(cells);</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TouchCell</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        …</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//hexMesh.Triangulate(cells);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　因为我们删除了<code>Refresh</code>方法，所以在<code>HexMapEditor</code>中不能再调用它了。</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EditCell</span>(<span class="params">HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cell.color = activeColor;</span><br><span class="line">    cell.Elevation = activeElevation;</span><br><span class="line">    <span class="comment">//hexGrid.Refresh();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　回到Unity中，因为我们删除了掉<code>gridCanvas</code>和<code>hexMesh</code>，所以在场景中我们不再需要<code>Hex Grid Canvas</code>和<code>Hex Mesh</code>这两个对象，删除后入下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-4-1.png"></p>
<p>　　清理完成后，运行游戏。我们发现Game窗口中地图生成并没有发生变化，但是Hierarchy窗口中的层级关系已经发生了变化。<code>HexGrid</code>生成地图块，再由每个地图块的实例生成地图单元和其相对应的UI。如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-4-2.png"></p>
<p>　　经过观察我们还发现一个问题，地图单元的坐标显示UI还存在一些问题：我们一开始设置的标签宽度是5，这足够显示两个字符。在较小的地图上刚好用完，但现在我们可以获取到“-10”这样有三个字符的坐标，这样一来字符无法相匹配并有断层。把UI的宽度增加到10或更多来解决这个问题。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-4-3.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-4-4.png"></p>
<p>　　现在我们终于可以创建一个比之前章节中尺寸更大的底图了！虽然生成地图需要花费比原来尺寸较小地图更长的时间，不过生化池呢个完成后，我们就拥有了一个尺寸跟大的地图。因为删除掉一些代码的原因，我们的地图编辑器功能不再起作用了，下一章中我们将解决这个问题。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/b5782f3190a4c9858f978735597d267cc5b5d6aa">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>5-5 修复地图编辑器</title>
    <url>/2020/11/24/HexMap/5-5%20%E4%BF%AE%E5%A4%8D%E5%9C%B0%E5%9B%BE%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<p>　　在上一章中，我们已经可以创建更大尺寸的地图了。但是因为删除了一些代码的原因，现在地图编辑器处于失效的状态中。在这一章中，我们将根据新的生成地图单元方式，修复地图编辑器。在上一章中我们删除了<code>HexGrid</code>中的<code>Refresh</code>，如果现在要改变某个地图单元的高度或者颜色，应该刷新其所在地图块的网格，而不是所有的地图单元网格。所以在<code>HexGridChunk</code>中添加新的<code>Refresh</code>方法。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGridChunk.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 重新构建当前chunk内的所有cell</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Refresh</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hexMesh.Triangulate(cells);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　那应该在什么时候调用这个方法？之前我们是在改变地图单元的高度或者颜色的时候对mesh进行重新构建，因为那时只有一个mesh，但现在我们有很多的地图块，每个地图块都包含了一个mesh组件。就不能每个地图块都刷新，而是仅当地图块被改变时再刷新效率会更高，否则编辑较大地图时会感觉很卡。<br>　　接下来问题就变成了如何知道哪个地图块需要刷新。一个比较简单的方法是确保每个地图单元都知道它是属于哪一个地图块，这样地图单元就能在其被改变时刷新它所在的地图块，所以给<code>HexCell</code>一个地图块的引用。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//引用当前其所在的地图块</span></span><br><span class="line">    <span class="keyword">public</span> HexGridChunk chunk;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　当添加地图单元实例时<code>HexGridChunk</code>可以直接把自己赋值给它。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AddCell</span>(<span class="params"><span class="keyword">int</span> index, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cells[index] = cell;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//将chunk自身实例添加到cell中，这样cell就知道自己属于哪个chunk了</span></span><br><span class="line">    cell.chunk = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　将这些引用连接建立之后,在<code>HexCell</code>里创建一个<code>Refresh</code>方法，地图单元刷新时就同步刷新自己所在的地图块。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line">…</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 当自身状态改变时，刷新自身所在chunk的所有cell</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Refresh</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chunk.Refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们之所以不需要把<code>HexCell.Refresh</code>设置为<code>public</code>方法，因为只有地图单元自己清楚它什么时候发生了变化。例如，在高度改变之后。</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Elevation</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        …</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置高度后刷新当前chunk</span></span><br><span class="line">        Refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　其实只有当前地图单元的高度被设置成了一个不同值时才需要刷新，并不需要在赋了一个相同的高度值后重新计算，所以新的高度值相同时，可以在<code>set</code>属性的一开始就跳出。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Elevation</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当新的高度值赋值是，与旧的相同，直接返回，不执行之后的代码</span></span><br><span class="line">        <span class="keyword">if</span> (elevation == <span class="keyword">value</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　然而这会跳过第一次设置高度为0时的计算，因为0是地图网格的默认高度，为预防这一点，确保初始值是永远都不会用到的值。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为高度赋初始值，这样避免了初始值为0，新输入的值也为0，不会刷新mesh的问题</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> elevation = <span class="keyword">int</span>.MinValue;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>什么是int.MinValue?<br>这是int所能表示的最小值，在C#中int是一个32位的数字,它有2的32次方种可能的整数值,分成正值和负值和0,其中一位用来指出这个值是不是负的。<br>最小值是负的2的31次方=-2147483648，我们永远不会使用这个高度等级。<br>最大值是2的31次方减1=2147483647,比2的31次方少1是因为还有0存在。<br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.int32.minvalue?view=net-5.0">MSDN连接</a></p>
</blockquote>
<p>　　除了改变高度会刷新当前的地图块，改变颜色也会。为了检测颜色是否被改变，我们也要把颜色设置成一个属性。重命名成首字母大写的Color,接着改成属性并使用私有的color变量。颜色的默认值是标准黑色，这里就不用再添加赋初始值的代码了。</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//cell颜色</span></span><br><span class="line"><span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cell颜色</span></span><br><span class="line"><span class="keyword">public</span> Color Color</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//当新颜色与现在颜色相同时，不再进行赋值和刷新</span></span><br><span class="line">        <span class="keyword">if</span> (color == <span class="keyword">value</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        color = <span class="keyword">value</span>;</span><br><span class="line">        </span><br><span class="line">        Refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　回到Unity中运行，我们发现会报空引用异常，这是因为在把地图单元赋值给它所在的地图块之前，就设置了其默认的颜色和高度。最好的办法是在这里先不刷新，因为我们会在初始化完成之后三角化它们。换句话说就是只有在地图块被赋值完成后才进行刷新。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Refresh</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chunk != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        chunk.Refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　现在又可以使用地图编辑器了，但是我们发现一个问题，就是在两个地图块的交界处，如果地图单元的颜色不是白色， 那就会产生很明显的一个边界。如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-5-1.png"></p>
<p>　　这个问题很好理解，因为一个地图单元发生变化后，所有与它相邻的地图单元也会发生改变，而这些相邻的地图单元有可能在不同的地图块中。最简单的解决方案是当地图单元与其相邻地图单元不在一个地图块时，也刷新一下相邻单元格的地图块。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Refresh</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chunk != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        chunk.Refresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历自身当前所有相邻的cell</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; neighbors.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            HexCell neighbor = neighbors[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当自身与相邻cell不在同一个chunk时，刷新相邻的chunk</span></span><br><span class="line">            <span class="keyword">if</span> (neighbor != <span class="literal">null</span> &amp;&amp; neighbor.chunk != chunk)</span><br><span class="line">            &#123;</span><br><span class="line">                neighbor.chunk.Refresh();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样修改虽然视觉效果正确，但我们要刷新单个地图块多次，一旦我们在一次绘制横跨多个地图单元时，情况就更糟糕了。我们没必要在地图块刷新信息时直接三角化，我们可以通知这个地图块需要刷新，然后在编辑完成时一次性三角化。<br>　　因为<code>HexGridChunk</code>没有用来做其它的事情，我们可以用脚本的enable状态作为需要刷新的信号，当开始刷新时，给脚本设置enable状态，就算多次设置也没关系，因为不会有变化。稍后脚本更新时，我们就在这里进行三角化，然后再次设置状态为disable。<br>　　因我们使用LateUpdate，这样就能确保三角化发生在当前帧编辑完成之后。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexGridChunk.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Refresh</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//hexMesh.Triangulate(cells);</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//需要对当前Chunk刷新时，就启用当前脚本</span></span><br><span class="line">    enabled = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">LateUpdate</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//完成三角构建后，就停用当前脚本，这样就不会发生重复刷新的问题了</span></span><br><span class="line">    hexMesh.Triangulate(cells);</span><br><span class="line">    enabled = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Update与LateUpdate有什么区别？<br>每一帧中, 所有enabled状态的组件中的Update会在随机时候调用。在这结束之后，LateUpdate方法也是同样的逻辑。所以这是两个更新步骤，一个早一些一个晚一些。<a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">Unity官方文档</a><br>Unity内脚本的生命周期如下图：</p>
</blockquote>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/Unity3D_MonoBehaviour_Lifecycle.jpg"></p>
<p>　　因为脚本组件默认状态就是enabled，所以不再需要在Start里进行三角构建，现在就可以删掉这个方法了。</p>
<figure class="highlight csharp"><figcaption><span>HexGridChunk.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//private void Start()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    cell实例会由HexGrid创建</span></span><br><span class="line"><span class="comment">//    之后会将实例分配到各个HexGridChunk的数组中，这样再进行mesh的构建</span></span><br><span class="line"><span class="comment">//    hexMesh.Triangulate(cells);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-5-2.png"></p>
<p>　　至此，我们就修复了地图编辑器的所有功能了，当我们编辑一个在地图块边缘的地图单元时，相邻地图块也会随之刷新。在接下来的章节中，我们会对现有代码进行一些优化。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/b8806263fd26e8ec7691382ce368811deaf73686">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>5-6 代码优化 共享列表</title>
    <url>/2020/11/25/HexMap/5-6%20%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%20%E5%85%B1%E4%BA%AB%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>　　在上一章中，我们修复了地图编辑器的功能。虽然现在构建地图的方式有了比较大的变化，但<code>HexMesh</code>里的代码逻辑并没有改变，它只需要一个单元格数组就能干活，无论是一个还是多个mesh都没有关系。之前我们并没有考虑过使用多个mesh构建整个地图的方案，或许这里能有优化的地方。<br>　　<code>HexMesh</code>里使用的列表实际是一个临时数据缓存，它只在三角构建的过程中使用。然而现在地图块的三角构建也是一次性完成的，所以还是只需要设置一次列表的数据而不是每个mesh三角构建时都设置一次，我们可以把列表设置为静态类型来实现这个改动。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMesh</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//存储所有正六边形的顶点位置信息</span></span><br><span class="line">    <span class="comment">//private List&lt;Vector3&gt; vertices;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">List</span>&lt;<span class="title">Vector3</span>&gt; vertices</span> = <span class="keyword">new</span> List&lt;Vector3&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//索引，每个三角面片顶点的渲染顺序</span></span><br><span class="line">    <span class="comment">//private List&lt;int&gt; triangles;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">List</span>&lt;<span class="title">int</span>&gt; triangles</span> = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存储cell每个顶点的颜色信息</span></span><br><span class="line">    <span class="comment">//private List&lt;Color&gt; colors;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="title">List</span>&lt;<span class="title">Color</span>&gt; colors</span> = <span class="keyword">new</span> List&lt;Color&gt;();</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        …</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化vertices、triangles链表 用于存储顶点和面片信息</span></span><br><span class="line">        <span class="comment">//vertices = new List&lt;Vector3&gt;();</span></span><br><span class="line">        <span class="comment">//triangles = new List&lt;int&gt;();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化colors链表，用于存储顶点颜色信息</span></span><br><span class="line">        <span class="comment">//colors = new List&lt;Color&gt;();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用静态类型的列表会有很大的效率提升么？<br>这只是一个说明该如何使用列表的简单改动，虽然提升不大但值得这么去做，即使我们现在不用太过担心它的效率问题。<br>这样改动后效率会有些提升，因为列表共享以后所需要的内存分配要少上一些。当使用20乘20的地图块时，节省的内存差不多刚超过100MB。</p>
</blockquote>
<p>　　代码经过优化之后，在性能上有些许的提升。因为有了更大尺寸的地图，我们就的摄像机现在已经不能完全显示整个地图了，在接下来的章节中，我们将会增加对摄像机控制的功能，让它可以移动和旋转视角，方便我们在运行时编辑地图。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/25dedf954243306e9cc0c2fbd3ac65988bb7e3bf">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>5-7 摄像机控制 调整层级结构</title>
    <url>/2020/11/26/HexMap/5-7%20%E6%91%84%E5%83%8F%E6%9C%BA%E6%8E%A7%E5%88%B6%20%E8%B0%83%E6%95%B4%E5%B1%82%E7%BA%A7%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>　　在上一章中，我们对<code>HexMesh.cs</code>脚本中的代码进行了优化。现在我们能创建尺寸更大的地图了，但是摄像机依然只显示了几个地图单元的范围，这导致在游戏运行时我们没办法编辑摄像机事业之外的地图单元。为了能看清整各地图的全貌，那就需要摄像机有移动、旋转和焦距变化的功能，在接下来的章节中，我们步来实现。<br>　　现在我们需要对摄像机的层级结构做出一些调整，新建一个空对象命名为<code>Hex Map Camera</code>，重置它的<code>transform</code>组件。为其新建一个子对象并命名为<code>Swivel</code>，然后在<code>Swivel</code>下创建一个子对象<code>Stick</code>。把主相机设置为<code>Stick</code>的子物体,然后重置其<code>transform</code>组件。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-7-1.png"></p>
<p>　　Swivel的控制摄像机看向的角度,把它的<code>Rotation</code>默认设置为<code>(45, 0, 0)</code>。Stick则是用来控制摄像机的远近,设置<code>Position</code>默认坐标为<code>(0, 0, -45)</code>。<br>　　接下来我们需要一个脚本来控制这个组合装置，在根节点添加这个脚本并添加Swivel和Stick的引用。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapCamera</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//控制camera视角旋转</span></span><br><span class="line">    <span class="keyword">private</span> Transform swivel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//控制camera视角远近</span></span><br><span class="line">    <span class="keyword">private</span> Transform stick;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Awake</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//获取对应的实例</span></span><br><span class="line">        swivel = transform.GetChild(<span class="number">0</span>);</span><br><span class="line">        stick = swivel.GetChild(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-7-2.png"></p>
<p>　　这样我们就完成了摄像机层级的设置和创建脚本的准备工作了。在下一章中我们将添加调整摄像机视距的功能。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/50dff1ce86ed256373979fcdb2b32681ec5f41db">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>5-8 摄像机视距控制</title>
    <url>/2020/11/26/HexMap/5-8%20%E6%91%84%E5%83%8F%E6%9C%BA%E8%A7%86%E8%B7%9D%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>　　在上一章中，创建了新的摄像机层级关系。在这一章中我们来实现第一个功能，就是摄像机的视距远近控制。我们可以用一个float变量记录当前的视距，当这个值为0的时候表示摄像机视距最远，反之为1的时候表示摄像机的视距最近。初始值为1即最近。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapCamera</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//camera视距控制，0最远，1最近</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> zoom = <span class="number">1f</span>;</span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　在PC平台下，摄像机改变视距通常都是通过鼠标滚轮或者类似的输入方法控制，所以我们可以使用Unity默认的<code>MouseScrollWheel</code>在<code>Update</code>方法里检查是否有输入增量，如果有再调用相应方法调整视距。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapCamera</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//检测鼠标滚轮是否有输入，有输入的话就调用 AdjustZoom</span></span><br><span class="line">        <span class="keyword">float</span> zoomDelta = Input.GetAxis(<span class="string">&quot;Mouse ScrollWheel&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (zoomDelta != <span class="number">0f</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            AdjustZoom(zoomDelta);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 控制camera视距远近</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;delta&quot;&gt;</span>鼠标滚轮输入的值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustZoom</span>(<span class="params"><span class="keyword">float</span> delta</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　要控制视距缩放就简单的加上输入增量，然后将值限制在0-1之间即可。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustZoom</span>(<span class="params"><span class="keyword">float</span> delta</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将变化值限制在0到1之间</span></span><br><span class="line">    zoom = Mathf.Clamp01(zoom + delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　因为摄像机Stick的子物体，我们在改变摄像机视距远近，其实就是在改变Stick的Z轴坐标。添加两个公共类型的float变量,用来规定Stick的最远和最近距离。由于我们创建的地图相对较小，先暂时设置为-250和-45。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapCamera</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//camera的最远和最近视距</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> stickMinZoom;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> stickMaxZoom;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-8-1.png"></p>
<p>　　设置好视距的最近最远值后，根据<code>stickMinZoom</code>、<code>stickMaxZoom</code>和<code>zoom</code>三个数值进行插值计算，得出Stick的Z轴坐标值，也就是摄像机的视距。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustZoom</span>(<span class="params"><span class="keyword">float</span> delta</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//视距远近其实就是stick.localPosition.z的值</span></span><br><span class="line">    <span class="comment">//设置最大值和最小值后，根据zoom取其插值即可</span></span><br><span class="line">    <span class="keyword">float</span> distance = Mathf.Lerp(stickMinZoom, stickMaxZoom, zoom);</span><br><span class="line">    stick.localPosition = <span class="keyword">new</span> Vector3(<span class="number">0f</span>, <span class="number">0f</span>, distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-8-2.gif"></p>
<p>　　现在能调整摄像机的视距了，但还是有些不太好用。通常游戏中的摄像机会在视距拉远的时候从斜向45度视角过渡到由上至下俯视角。这里我们可以通过旋转Swivel来实现，所以也同样为Swivel添加最大和最小的旋转角度标量，默认设置为90和45。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapCamera</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//camera的俯角和仰角值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> swivelMinZoom;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> swivelMaxZoom;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-8-3.png"></p>
<p>　　与计算Stick的Z轴坐标值类似，我们使用<code>swivelMinZoom</code>、<code>swivelMaxZoom</code>和<code>zoom</code>三个值进行插值计算，得出Swivel的X轴旋转角度。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustZoom</span>(<span class="params"><span class="keyword">float</span> delta</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在视距远近变化的时候，俯仰角也会变化</span></span><br><span class="line">    <span class="comment">//视距最小时是斜向45度，视距最大是垂直90度</span></span><br><span class="line">    <span class="keyword">float</span> angle = Mathf.Lerp(swivelMinZoom, swivelMaxZoom, zoom);</span><br><span class="line">    swivel.localRotation = Quaternion.Euler(angle, <span class="number">0f</span>, <span class="number">0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-8-4.gif"></p>
<p>　　我们可以通过调整鼠标滚轮的灵敏度设置来控制视距的变化速度，在 Edit / ProjectSettings / Input Manager 面板中可以找到<code>Mouse ScrollWhell</code> / <code>Sensitivity</code>，例如可以把灵敏度默认值0.1改为0.025来获得更为平滑的视距变化感觉。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-8-5.png"></p>
<p>　　如果不希望每次都要在Input Manager中修改鼠标滚轮的灵敏度，我们也可以创建一个控制鼠标灵敏度的变量，需要修改鼠标滚轮灵敏度的时候，我们只需要修改这个变量的值就可以了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapCamera</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//控制鼠标滚轮灵敏度，数值越大，速度越慢</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="keyword">float</span> zoomSensitivity = <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustZoom</span>(<span class="params"><span class="keyword">float</span> delta</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//添加了灵敏度控制</span></span><br><span class="line">        zoom = Mathf.Clamp01(zoom + delta/zoomSensitivity);</span><br><span class="line">        </span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　至此我们就完成了通过鼠标滚轮控制摄像机视距远近的功能，但是只能调整视距还无法满足灵活编辑地图的需求。在接下来的章节中，我们将为摄像机添加移动的功能。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/075bf320b8b2482f9a89569005798b5179500976">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>5-9 摄像机移动控制</title>
    <url>/2020/11/27/HexMap/5-9%20%E6%91%84%E5%83%8F%E6%9C%BA%E7%A7%BB%E5%8A%A8%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>　　在上一章中，我们完成了摄像机视距控制的功能，通过鼠标滚轮可以控制摄像机视距的远近。接下来我们继续完善摄像机控制的相关功能。<br>　　要让摄像机在水平和垂直方向移动，与调整摄像机视距思路相似，可以检测水平和垂直的输入信息，对应<code>Hex Map Camera</code>在X和Z方向的运动。代码如下</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测 水平 和 垂直 方向的输入</span></span><br><span class="line">    <span class="keyword">float</span> xDelta = Input.GetAxis(<span class="string">&quot;Horizontal&quot;</span>);</span><br><span class="line">    <span class="keyword">float</span> zDelta = Input.GetAxis(<span class="string">&quot;Vertical&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (xDelta != <span class="number">0f</span> || zDelta != <span class="number">0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        AdjustPosition(xDelta, zDelta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 控制摄像机移动</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;xDelta&quot;&gt;</span>X轴输入增量<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;zDelta&quot;&gt;</span>Z轴输入增量<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustPosition</span>(<span class="params"><span class="keyword">float</span> xDelta, <span class="keyword">float</span> zDelta</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　使<code>Hex Map Camera</code>移动最简单的方式，就是先获取当前位置，然后再加上X和Z轴的输入增量，这样的出来的结果就是移动后的位置。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustPosition</span>(<span class="params"><span class="keyword">float</span> xDelta, <span class="keyword">float</span> zDelta</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//先获取当前位置</span></span><br><span class="line">    Vector3 position = transform.localPosition;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前位置加上位移增量，得出新的位移位置，此方法会受到帧率影响</span></span><br><span class="line">    position += <span class="keyword">new</span> Vector3(xDelta, <span class="number">0f</span>, zDelta);</span><br><span class="line">    transform.localPosition = position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　现在我们就可以通过WSAD来控制摄像机在X和Z轴方向上的移动了。但是这样移动的速度并不是恒定的，会受到帧率的影响。为了避免受到帧率的影响，我们改变一下思路，使用方向乘以位移距离的方式来描述摄像机的移动。而距离则是由时间增量和速度所组成的。我们添加<code>moveSpeed</code>变量，用来控制摄像机的移动速度，初始值为100。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapCamera</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//摄像机移动速度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> moveSpeed;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustPosition</span>(<span class="params"><span class="keyword">float</span> xDelta, <span class="keyword">float</span> zDelta</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//通过实践增量和速度，计算出位移距离</span></span><br><span class="line">        <span class="keyword">float</span> distance = moveSpeed * Time.deltaTime;</span><br><span class="line">        </span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里的 new Vector3是作为方向来使用的distance表示移动的距离， new Vector3表示移动的方向</span></span><br><span class="line">        position += <span class="keyword">new</span> Vector3(xDelta, <span class="number">0f</span>, zDelta) * distance;</span><br><span class="line"></span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-9-1.png"></p>
<p>　　通过勾股定理我们可以发现，摄像机在斜向移动的时候，会比只沿着X或Z轴速度更快。所以需要将移动方向进行归一化处理，这样就保证摄像机向着各个方向移动时速度相同。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustPosition</span>(<span class="params"><span class="keyword">float</span> xDelta, <span class="keyword">float</span> zDelta</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//camera的移动方向</span></span><br><span class="line">    Vector3 direction = <span class="keyword">new</span> Vector3(xDelta, <span class="number">0f</span>, zDelta).normalized;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    position += direction * distance;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　修复了移动速度的问题后，还存在一个问题，就是当我们持续按下一个方向键一段时间，抬起后摄像机的移动不会立刻就停止，而是会持续移动一段时间。这是因为当我们按下方向键后摄像机位置不会立即变为计算后的位置，而是需要一个过渡时间，抬起按键也是相同的原理，而且我们将表示方向的向量进行了归一化，所以在这段时间内，摄像机都会以一个恒定的速度运动一段时间。<br>　　解决这个问题的方式，就是增加一个阻尼值，阻尼值取X或Z轴向两个输入值中绝对值最大的那个，这样既保留了开始和停止时的平滑感，又解决了抬起按键还会持续移动的问题。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustPosition</span>(<span class="params"><span class="keyword">float</span> xDelta, <span class="keyword">float</span> zDelta</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//阻尼系数，取X或Z的绝对值中最大的一个，这样避免抬起按键后还会移动，又保留了平滑感</span></span><br><span class="line">    <span class="comment">//这个值是慢慢减少的，所以移动距离也会是慢慢变小，最终到0。与按键的按下和抬起同步</span></span><br><span class="line">    <span class="keyword">float</span> damping = Mathf.Max(Mathf.Abs(xDelta), Mathf.Abs(zDelta));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过实践增量和速度，计算出位移距离</span></span><br><span class="line">    <span class="keyword">float</span> distance = moveSpeed * damping * Time.deltaTime;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-9-2.gif"></p>
<p>　　现在摄像机移动的相关代码已经完成了，但是当我们将镜头视距在默认位置时没没有什么问题，拉至最远的时候会感觉摄像机运动的比较慢。那就需要我们有两个速度值，一个是视距最远的时候，一个是视距最近的时候。按照这个思路，将<code>moveSpeed</code>拆分为2个变量，默认值分别为400和100，对应视距最远和最近时的移动速度，通过<code>zoom</code>变量进行插值计算。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapCamera</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//camera的两个移动值，分别对应视距最远和最近</span></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="keyword">float</span> moveSpeedMinZoom;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="keyword">float</span> moveSpeedMaxZoom;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustPosition</span>(<span class="params"><span class="keyword">float</span> xDelta, <span class="keyword">float</span> zDelta</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//根据当前视距计算移动速度</span></span><br><span class="line">        <span class="keyword">float</span> moveSpeed = Mathf.Lerp(moveSpeedMinZoom, moveSpeedMaxZoom, zoom);</span><br><span class="line">        </span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-9-3.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-9-4.gif"></p>
<p>　　至此摄像机终于可以正确的移动了。但是还存在一个问题，就是摄像机不应该移动到地图的边界之外。为了让摄像机只能在地图范围内移动，我们首先要知道地图的范围，在<code>HexMapCamera</code>中创建<code>HexGrid</code>变量，并在Unity中将<code>HexGrid</code>物体拖入这个变量对应栏位中。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapCamera</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为了控制camera的移动范围，要获取地图的实例</span></span><br><span class="line">    <span class="keyword">public</span> HexGrid grid;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-9-5.png"></p>
<p>　　获取到地图实例后，使用一个新的方法来计算当前摄像机的位置是否在地图的范围内，并将这个计算后的位置赋值为摄像机当前的位置。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AdjustPosition</span>(<span class="params"><span class="keyword">float</span> xDelta, <span class="keyword">float</span> zDelta</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对camera的移动范围进行限制</span></span><br><span class="line">    transform.localPosition = ClampPosition(position);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 限制camera的移动范围在地图尺寸内</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;position&quot;&gt;</span>当前camera的位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>计算是否在地图范围内后的位置<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Vector3 <span class="title">ClampPosition</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　X的范围最小值是0，最大值则需要获取地图的实际尺寸。</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Vector3 <span class="title">ClampPosition</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取地图的实际宽度</span></span><br><span class="line">    <span class="keyword">float</span> xMax = grid.chunkCountX * HexMetrics.chunkSizeX * (<span class="number">2f</span> * HexMetrics.innerRadius);</span><br><span class="line">    <span class="comment">//将camera的位置限制在宽度范围内</span></span><br><span class="line">    position.x = Mathf.Clamp(position.x, <span class="number">0f</span>, xMax);</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　Z的范围取值也是相同的原理，代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Vector3 <span class="title">ClampPosition</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取地图的实际宽度</span></span><br><span class="line">    <span class="keyword">float</span> zMax = grid.chunkCountZ * HexMetrics.chunkSizeZ * (<span class="number">1.5f</span> * HexMetrics.outerRadius);</span><br><span class="line">    <span class="comment">//将camera的Z限制在宽度范围内</span></span><br><span class="line">    position.z = Mathf.Clamp(position.z, <span class="number">0f</span>, zMax);</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　实际上只是获取地图的宽度并不精确，我们希望摄像机最终会停在最右边地图单元的中心上，因此需要在X的最大值上减去半个地图单元的宽度。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Vector3 <span class="title">ClampPosition</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里为了使camera镜头中心在最右侧cell的中心，这里要减去半个cell的宽度</span></span><br><span class="line">    <span class="keyword">float</span> xMax = (grid.chunkCountX * HexMetrics.chunkSizeX - <span class="number">0.5f</span>) * (<span class="number">2f</span> * HexMetrics.innerRadius);</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　Z的取值范围也是相同，不过因为地图单元的排列在横纵坐标的度量方式不同，所以这里要减去整个地图单元的高度。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapCamera.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Vector3 <span class="title">ClampPosition</span>(<span class="params">Vector3 position</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为cell排列方式，这里Z方向是减去一个cell的Z</span></span><br><span class="line">    <span class="keyword">float</span> zMax = (grid.chunkCountZ * HexMetrics.chunkSizeZ - <span class="number">1</span>) * (<span class="number">1.5f</span> * HexMetrics.outerRadius);</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　当我们现在移动摄像机时，就不会超出地图范围了。这里还有一个细节需要注意，因为我们使用的是检测水平和垂直的输入，所以Unity会响应WSAD和方向键上下左右的输入。但是同时UI也会响应方向键的输入。这样的结果就是当我们点击UI并把鼠标停留在UI上，同时使用方向键控制摄像机移动的时候，UI中的滑动条也会跟着移动。可以取消选择EventSystem上的<code>Send Navigation Event</code>选项来禁止UI监听按键事件来解决这个问题。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/5-9-6.png"></p>
<p>　　这样，我们就完成了摄像机的移动控制功能，在接下来的一章中，我们将完成通过鼠标旋转摄像机视角的功能。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/a26d432d6429b410e712aa9693f349d3e745ed2a">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>6-1 地图单元与河流</title>
    <url>/2020/12/03/HexMap/6-1%20%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E4%B8%8E%E6%B2%B3%E6%B5%81/</url>
    <content><![CDATA[<p>　　第6章是目前为止篇幅最长的一个章节，难度也相对之前的章节会大很多。在第6章中。我没事用的三角剖分方法会更为复杂，而且还要使用着色器代码实现一些简单的视觉效果。在之前的章节中，我们为了丰富地图的细节，加入了高度属性，又对地图单元之间的连接处进行了阶梯化，还加入了噪点扰动。但是这些细节并不够丰富，在接下来的章节中，我们将添加地貌的另一个基本要素：河流。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-1-1.png"></p>
<p>　　在六边形地图中添加河流有三种方法：<br>　　第一种方法是让河流从地图单元中穿过，即从一个地图单元流向另一个地图单元,这是《无尽传说》中的做法。<br>　　第二种方法是让河流在地图单元之间流过，沿着地图单元的边缘到另一个地图单元的边缘,《文明5》中是这么做的。<br>　　第三种方法是不使用额外的河流结构特性，而是直接用特殊的地图单元表示水体,《奇迹时代3》中是这么做的。<br>　　第而在我们的项目中，由于地图单元的边缘连接已经用阶梯化或陡峭的方式特殊处理过，没有留给河流的空间，所以就采用第一种方法，让河流从一个单元格流向另一个单元格。这意味着每个单元格要么就是没有河流经过，要么河流穿过这个单元格，要么这个单元格是河流的起点或者终点。而在有河流穿过的单元格中，要么河流是笔直穿过，要么是一步锐角转弯，要么是两步钝角转弯。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-1-2.png"></p>
<p>　　结合项目中地图单元的特性，分析后得出了一些有规律的信息。在接下来的章节中，我们首先通过代码设置有河流经过的地图单元中河流的方向。</p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>6-10 增加连接区域中的顶点数量</title>
    <url>/2020/12/12/HexMap/6-10%20%E5%A2%9E%E5%8A%A0%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%9F%9F%E4%B8%AD%E7%9A%84%E9%A1%B6%E7%82%B9%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<p>　　在上一章中，我们在两种创建连接区域的河道方案中选择了较为合适的一种，就是在连接区域内增加一个四边形，通过调整连接区域中间位置的顶点高度，来形成一条两侧倾斜的河道。<br>　　要把连接处的3个四边形变为4个，就需要在地图单元的每条边上增加额外的顶点。首先我们回到<code>EdgeVertices.cs</code>脚本中，在这里我们来修改顶点的数量。首先使用IDE的重命名功能，将<code>v4</code>重命名为<code>v5</code>，接着将<code>v3</code>重命名为<code>v4</code>。注意，这里一定要使用IDE工具的重命名功能，不然只能手动的搜索整个项目中的脚本来重命名变量了，很可能导致不可预知的错误发生。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>EdgeVertices.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> EdgeVertices</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Vector3 v1, v2, v4, v5;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　重命名完成后，再添加一个新的变量<code>v3</code>。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>EdgeVertices.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> EdgeVertices</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Vector3 v1, v2, v3, v4, v5;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　因为增加了新的顶点，我们就要修改构造函数。添加新增的这个顶点。<code>v3</code>是在连接区域的中央，也就是0.5的位置上，而与其左右相邻的两个顶点，就分别到了0.25和0.75的位置上。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>EdgeVertices.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> EdgeVertices</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeVertices</span>(<span class="params">Vector3 corner1, Vector3 corner2</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        v1 = corner1;</span><br><span class="line">        <span class="comment">//v2 = Vector3.Lerp(corner1, corner2, 1f / 3f);</span></span><br><span class="line">        <span class="comment">//v4 = Vector3.Lerp(corner1, corner2, 2f / 3f);</span></span><br><span class="line">        <span class="comment">//添加了新的v3顶点，其左右相邻的顶点位置也要相应的改变</span></span><br><span class="line">        v2 = Vector3.Lerp(corner1, corner2, <span class="number">0.25f</span>);</span><br><span class="line">        v3 = Vector3.Lerp(corner1, corner2, <span class="number">0.5f</span>);</span><br><span class="line">        v4 = Vector3.Lerp(corner1, corner2, <span class="number">0.75f</span>);</span><br><span class="line">        v5 = corner2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　同样的，我们在<code>TerraceLerp</code>方法中，也要将新的<code>v3</code>顶点添加进去。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>EdgeVertices.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> EdgeVertices</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EdgeVertices <span class="title">TerraceLerp</span>(<span class="params">EdgeVertices a, EdgeVertices b, <span class="keyword">int</span> step</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        EdgeVertices result;</span><br><span class="line">        result.v1 = HexMetrics.TerraceLerp(a.v1, b.v1, step);</span><br><span class="line">        result.v2 = HexMetrics.TerraceLerp(a.v2, b.v2, step);</span><br><span class="line">        <span class="comment">//添加了新的v3顶点</span></span><br><span class="line">        result.v3 = HexMetrics.TerraceLerp(a.v3, b.v3, step);</span><br><span class="line">        result.v4 = HexMetrics.TerraceLerp(a.v4, b.v4, step);</span><br><span class="line">        result.v5 = HexMetrics.TerraceLerp(a.v5, b.v5, step);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接着，我们回到<code>HexMesh.cs</code>中，这里对<code>EdgeVertices.cs</code>中的方法进行了调用构建mesh，所以也要做出一些修改。首先是<code>TriangulateEdgeFan</code>方法。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMesh</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateEdgeFan</span>(<span class="params">Vector3 center, EdgeVertices edge, Color color</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AddTriangle(center, edge.v1, edge.v2);</span><br><span class="line">        AddTriangleColor(color);</span><br><span class="line">        <span class="comment">//AddTriangle(center, edge.v2, edge.v4);</span></span><br><span class="line">        <span class="comment">//AddTriangleColor(color);</span></span><br><span class="line">        <span class="comment">//加入了新的顶点信息</span></span><br><span class="line">        AddTriangle(center, edge.v2, edge.v3);</span><br><span class="line">        AddTriangleColor(color);</span><br><span class="line">        AddTriangle(center, edge.v3, edge.v4);</span><br><span class="line">        AddTriangleColor(color);</span><br><span class="line"></span><br><span class="line">        AddTriangle(center, edge.v4, edge.v5);</span><br><span class="line">        AddTriangleColor(color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　然后要修改<code>TriangulateEdgeStrip</code>方法。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMesh</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateEdgeStrip</span>(<span class="params">EdgeVertices e1, Color c1, EdgeVertices e2, Color c2</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        AddQuad(e1.v1, e1.v2, e2.v1, e2.v2);</span><br><span class="line">        AddQuadColor(c1, c2);</span><br><span class="line">        <span class="comment">//AddQuad(e1.v2, e1.v4, e2.v2, e2.v4);</span></span><br><span class="line">        <span class="comment">//AddQuadColor(c1, c2);</span></span><br><span class="line">        <span class="comment">//添加了新的顶点信息</span></span><br><span class="line">        AddQuad(e1.v2, e1.v3, e2.v2, e2.v3);</span><br><span class="line">        AddQuadColor(c1, c2);</span><br><span class="line">        AddQuad(e1.v3, e1.v4, e2.v3, e2.v4);</span><br><span class="line">        AddQuadColor(c1, c2);</span><br><span class="line"></span><br><span class="line">        AddQuad(e1.v4, e1.v5, e2.v4, e2.v5);</span><br><span class="line">        AddQuadColor(c1, c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，我们就完成了添加顶点数量的相关代码。下图是添加顶点前后地图mesh的变化对比。在下一章中，我们将设置河道的高度，这样可以将地面与河道使用不同高度区分开来。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-10-1.png"></p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-10-2.png"></p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/adb88c20545b2f5b820f8ae539f56ace7271d9b8">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>6-11 设置河床高度</title>
    <url>/2020/12/13/HexMap/6-11%20%E8%AE%BE%E7%BD%AE%E6%B2%B3%E5%BA%8A%E9%AB%98%E5%BA%A6/</url>
    <content><![CDATA[<p>　　在上一章中，我们为地图单元添加了一个新的顶点，使连接区域从以前的3个矩形构成，变为4个矩形构成。新增的顶点其实就是河床的最低点。在这一章中，我们将设置这个顶点在垂直方向上的坐标。使其成为河床最低点。<br>　　首先现在的地图单元中的每个顶点，都是经过扰动的。但是我们希望河床最低点的顶点不会扰动，这样就能避免因为高低起伏的随机，让河流的某些地方看起来想逆流的情况。同时，还需要让这个顶点足够低，即使其两侧的顶点有随机扰动，也会和自身高驰一定的高度距离，为水面流出足够的空间。<br>　　我们回到<code>HexMetrics.cs</code>脚本中，在这里定义一个常量，用来表示河道最低点的偏移量。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexMetrics</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//河道最低点的偏移量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> streamBedElevationOffset = <span class="number">-1f</span>;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接着，我们回到<code>HexCell.cs</code>脚本中添加一个属性，使用之前定义的常量来计算当前地图单元河床顶点的高度。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//河床最低点的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> StreamBedY</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//通过偏移常量，计算出当前cell对应河床顶点的实际高度</span></span><br><span class="line">            <span class="keyword">return</span> (elevation + HexMetrics.streamBedElevationOffset) * HexMetrics.elevationStep;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样我们就通过一个常量，设置好了河床最低点的偏移量。并且创建了一个方法以供地图单元或连接区域进行构建的时候调用。接下来的一章中，我们将使用这个方法构建带河道的连接区域。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/106ab3e1dc8c54f021936d65482d23f3c47b61c1">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>6-12 创建连接区域的河道</title>
    <url>/2020/12/14/HexMap/6-12%20%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5%E5%8C%BA%E5%9F%9F%E7%9A%84%E6%B2%B3%E9%81%93/</url>
    <content><![CDATA[<p>　　在上一章中，我们声明了一个常量用来存储河床最低点的偏移量。在这一章中，我们要使用这个偏移量来构建连接区域。<br>　　首先回到<code>HexMesh.cs</code>甲苯中，在这里有构建连接区域的方法。当我们构建地图单元的时候，获取其河流的状态。如果存在流入或者流出的河流，那么我们就修改中间顶点的高度。让其变为河床的最低点。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    EdgeVertices e = <span class="keyword">new</span> EdgeVertices(</span><br><span class="line">        center + HexMetrics.GetFirstSolidCorner(direction),</span><br><span class="line">        center + HexMetrics.GetSecondSolidCorner(direction)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测当前边缘是否有河流穿过</span></span><br><span class="line">    <span class="keyword">if</span> (cell.HasRiverThroughEdge(direction))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果有河流穿过，就降低中间顶点的高度，使其成为河床最低点</span></span><br><span class="line">        e.v3.y = cell.StreamBedY;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    TriangulateEdgeFan(center, e, cell.Color);</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-12-1.png"></p>
<p>　　通过上图我们发现，在连接区域产生了破面的情况。要填补这些破面，就要在进行三角构建连接区域的时候，同时要将相邻地图单元边上中央顶点的坐标也下降到相应高度。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateConnection</span>(<span class="params">HexDirection direction, HexCell cell, EdgeVertices e1</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    EdgeVertices e2 = <span class="keyword">new</span> EdgeVertices(e1.v1 + bridge, e1.v5 + bridge);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使得相邻地图单元的中间顶点坐标也下降到河床最低点位置，不然会有破面产生</span></span><br><span class="line">    <span class="keyword">if</span> (cell.HasRiverThroughEdge(direction))</span><br><span class="line">    &#123;</span><br><span class="line">        e2.v3.y = neighbor.StreamBedY;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-12-2.png"></p>
<p>　　现在，我们就可以通过按下鼠标左脚拖拽在地图上创建河流了。不过我们发现一个问题，就是河流穿过地图单元中央的时候，河流就收缩到一起了。这明显是不正确的，我们将会在接下来的章节修复这个问题。</p>
<p>[Github代码](</p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>6-13 区分是否有河流</title>
    <url>/2020/12/15/HexMap/6-13%20%E5%8C%BA%E5%88%86%E6%98%AF%E5%90%A6%E6%9C%89%E6%B2%B3%E6%B5%81/</url>
    <content><![CDATA[<p>　　在上一章中，我们对河床最低点的顶点进行了偏移，当鼠标左键按下并拖拽的时候，就会产生相应的河道。但是我们发现河道进入地图单元后，并不像在连接处那样保持宽度，而变成了逐渐向地图单元中心汇集。修复这个问题比较复杂，我们来分情况讨论。首先我们从最简单的情况开始考虑：河流从一侧流入地图单元，又从其相对的方向流出。<br>　　如果一个地图单元中没有河流，其顶点与一条边所组成的图形是一个扇形。当有河流时，就需要把地图单元中被河流穿过的三角形变成四边形，而扇形整体就变成了梯形。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-13-1.png"></p>
<p>　　穿过地图单元的河道要比穿过连接处的河道长很多，所以地图单元内组成河道的各个顶点被扰动后，变化会更加明显。为了减小扰动所带来的这个问题，我们在顶点到边缘之间再插入一个新的顶点，将原来的区域分为两段。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-13-2.png"></p>
<p>　　一个地图单元内，有河流穿过和没有河流穿过，两者的三角剖分会有很大不同。这里我们为此创建一个新的方法。如果一个地图单元内有河流经过，就使用这个新创建的方法，如果没有，就使用之前的方法。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMesh</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cell.HasRiver)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//检测当前边缘是否有河流穿过</span></span><br><span class="line">            <span class="keyword">if</span> (cell.HasRiverThroughEdge(direction))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果有河流穿过，就降低中间顶点的高度，使其成为河床最低点</span></span><br><span class="line">                e.v3.y = cell.StreamBedY;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//使用带河流的构建方式</span></span><br><span class="line">                TriangulateWithRiver(direction, cell, center, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//在计算出各个点的位置信息后，直接构建三角面片</span></span><br><span class="line">            <span class="comment">//这个是不带河流的构建方式</span></span><br><span class="line">            TriangulateEdgeFan(center, e, cell.Color);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 当cell中有河流的时候，使用这个方法来进行构建</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 参考图 http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-13-1.png</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>河流方向<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cell&quot;&gt;</span>cell这身实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;center&quot;&gt;</span>cell中心点实际位置<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e&quot;&gt;</span>河流穿过的这个边，在这条边上所有的顶点的位置信息<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateWithRiver</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们虽然创建了有河流经过地图单元时，所使用的三角剖分方法，但是并没有任何内容，所以现在河流经过的地图单元是空的。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-13-3.png"></p>
<p>　　为了更好的观察三角剖分情况，我们先暂时不使用坐标扰动。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMetrics.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">HexMetrics</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">const</span> <span class="keyword">float</span> cellPerturbStrength = <span class="number">0f</span>;<span class="comment">//4f;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-13-4.png"></p>
<p>　　至此，我们根据十一地图单元内是否有河流进行了区分，从而使用了不同的三角剖分方式进行构建。在下一张中，我们先处理最简单的河流情况，也就是河流笔直穿过一个地图单元。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/b8a3bd915432c338d4c90f185176450b5cfa68c2">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>6-14 河流笔直穿过地图单元的三角剖分</title>
    <url>/2020/12/16/HexMap/6-14%20%E6%B2%B3%E6%B5%81%E7%AC%94%E7%9B%B4%E7%A9%BF%E8%BF%87%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E7%9A%84%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<p>　　在上一章中，我们将有河流穿过和没河流穿过地地图单元进行了区分，并且创建了一个方法，专门对有河流穿过的地图单元进行构建。在这一章中，我们先分析最简单的情况：河流笔直穿过一个地图单元。并实现这种情况的构建。<br>　　要构建一个笔直的河道，就需要把汇聚到地图单元中心的点，延伸成一条与河道宽度相同的直线。通过观察现在的三角剖分可以发现，如果我们只改变当前河流经过的扇形区域，对其进行拉伸或缩放，那其他两侧相邻的扇形区域就一定会产生破面或重面的情况。所以我们不仅要对当前扇形区域内的顶点进行计算，还会涉及到其两侧相邻的扇形区域内的顶点。<br>　　之前我们用5个顶点，将地图单元的每一条边分城了4等份，河道宽度为二分之一边长。而且通过之前的章节我们已经知道，地图单元的外接圆直径与边长相等。如果要实现河流在地图单元中心也保持这个宽度，那么需要将其两侧的扇形区域中，之前的顶点与地图单元重点重合，现在要变为距中心点四分之一距离处。左右两个各四分之一外接圆半径长度，两个组成二分之一外接圆半径长度，刚好跟河道宽度相同。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateWithRiver</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//河流宽度为二分之一cell边长，又已知边长与外接圆半径(cell外径outerRadius)相同</span></span><br><span class="line">    <span class="comment">//为了保持河道在cell中央的时候不会变形，且没有破面等现象产生</span></span><br><span class="line">    <span class="comment">//所以要将当前河流穿过区域左右两侧的外径，之前顶点与中心重合，现在变为各自距离中心四分之一处</span></span><br><span class="line">    Vector3 centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="number">0.25f</span>;</span><br><span class="line">    Vector3 centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="number">0.25f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　我们计算出了两个新的顶点坐标，根据这两个坐标，使用<code>EdgeVertices</code>结构体来计算其余3个顶点的坐标，并将它们全都保存下来。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateWithRiver</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据两侧新的顶点位置，计算出其余顶点的位置</span></span><br><span class="line">    EdgeVertices m = <span class="keyword">new</span> EdgeVertices(</span><br><span class="line">        Vector3.Lerp(centerL, e.v1, <span class="number">0.5f</span>),</span><br><span class="line">        Vector3.Lerp(centerR, e.v5, <span class="number">0.5f</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接着，我们修改中间顶点的高度，使其下降成为河道。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateWithRiver</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将河道中心的顶点高度下降</span></span><br><span class="line">    m.v3.y = center.y = e.v3.y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　然后，我们先使用<code>TriangulateEdgeStrip</code>方法来构建连接区域。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateWithRiver</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过计算后的顶点构建连接区域</span></span><br><span class="line">    TriangulateEdgeStrip(m, cell.Color, e, cell.Color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-14-1.png"></p>
<p>　　我们观察构建的结果，发现好像河道还是向内压缩了。河道左右两边的顶点还是在向中间靠拢。结合下图、运行效果与<code>TriangulateEdgeStrip</code>方法来看。我们理想中的构建方式，应该是河道宽度保持不变，而河道左右两侧的平面，越接近中心位置就越窄。也就是下图中所表示的情况。而我们现在因为使用了<code>TriangulateEdgeStrip</code>方法来计算中间的三个顶点。导致这五个顶点是等距分布在梯形的中位线上的，结果也就是上图运行效果的样子。</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-14-2.png"></p>
<p>　　所以在这里，我们需要重载<code>TriangulateEdgeStrip</code>方法，使其按照新的方式来计算梯形中位线上的5个顶点。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>EdgeVertices.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> EdgeVertices</span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 有河流经过一条边时，三角形变为梯形，提醒区域中位线的顶点分布不是平均的</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 参考图 http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-14-2.png</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;corner1&quot;&gt;</span>梯形区域第一个顶点<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;corner2&quot;&gt;</span>提醒区域最后一个顶点<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;outerStep&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeVertices</span>(<span class="params">Vector3 corner1, Vector3 corner2, <span class="keyword">float</span> outerStep</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//注意，这里不再是等距分布一条直线上的5个顶点</span></span><br><span class="line">        <span class="comment">//而是按照左右较窄，中间宽度为四分之一外径，这样分布的</span></span><br><span class="line">        v1 = corner1;</span><br><span class="line">        v2 = Vector3.Lerp(corner1, corner2, outerStep);</span><br><span class="line">        v3 = Vector3.Lerp(corner1, corner2, <span class="number">0.5f</span>);</span><br><span class="line">        v4 = Vector3.Lerp(corner1, corner2, <span class="number">1f</span> - outerStep);</span><br><span class="line">        v5 = corner2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　现在，我们就可以回到构建河道连接区域的方法中，调用<code>TriangulateEdgeStrip</code>方法的重载。这里要注意我们计算梯形区域中位线上五个顶点的位置中间顶点，及其两侧的顶点计算方式不变，因为河道的宽度不变。主要是最外侧两个顶点的位置需要重新计算。这里观察上图我们发现，中位线是底边长度的四分之三，也就是外径长度的四分之三。而两侧顶点各偏移了八分之一外径长，也就是六分之一的中位线长。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateWithRiver</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里使用新的顶点计算方式，关键是两侧顶点的偏移量</span></span><br><span class="line">    <span class="comment">//参考图 http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-14-2.png</span></span><br><span class="line">    <span class="comment">//注意梯形中位线部分，中间河道为 1/4+1/4，只看左侧顶点偏移，为1/4的一半，也就是1/8</span></span><br><span class="line">    <span class="comment">//并且中位线是底边长的3/4，以中位线为计算基础，左右两个顶点其实各偏移了中位线的6/1</span></span><br><span class="line">    <span class="comment">//可以这么理解： 1/4 + 1/4 + (1/8 +1/8) 是中位线宽度，其中的1/4其实是中位线的1/3、而一侧偏移量是1/8，也就是中位线的1/6</span></span><br><span class="line">    EdgeVertices m = <span class="keyword">new</span> EdgeVertices(</span><br><span class="line">        Vector3.Lerp(centerL, e.v1, <span class="number">0.5f</span>),</span><br><span class="line">        Vector3.Lerp(centerR, e.v5, <span class="number">0.5f</span>),</span><br><span class="line">        <span class="number">1f</span> / <span class="number">6f</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，梯形区域的一部分就已经可以正常的构建出来了。如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-14-3.png"></p>
<p>　　接下来我们将构建剩下的部分。梯形的顶边上只有三个顶点，无法用之前的方法进行顶点计算。这里我们手动添加顶点进行构建。首先创建河道两侧的三角形面片。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateWithRiver</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//之前构建的是梯形中位线到底边的部分</span></span><br><span class="line">    <span class="comment">//这里构建中位线到顶边的部分</span></span><br><span class="line">    <span class="comment">//由于之前所有方法均不适用于这里，所以手动添加顶点</span></span><br><span class="line">    <span class="comment">//首先构建河道两侧三角形区域</span></span><br><span class="line">    AddTriangle(centerL, m.v1, m.v2);</span><br><span class="line">    AddTriangleColor(cell.Color);</span><br><span class="line">    AddTriangle(centerR, m.v4, m.v5);</span><br><span class="line">    AddTriangleColor(cell.Color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-14-4.png"></p>
<p>　　通过观察运行结果，河道两边的三角形区域正确构建了出来。接下来构建中间河道的四边形部分。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateWithRiver</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//之前构建的是梯形中位线到底边的部分</span></span><br><span class="line">    <span class="comment">//这里构建中位线到顶边的部分</span></span><br><span class="line">    <span class="comment">//由于之前所有方法均不适用于这里，所以手动添加顶点</span></span><br><span class="line">    <span class="comment">//首先构建河道两侧三角形区域</span></span><br><span class="line">    AddTriangle(centerL, m.v1, m.v2);</span><br><span class="line">    AddTriangleColor(cell.Color);</span><br><span class="line">    AddTriangle(centerR, m.v4, m.v5);</span><br><span class="line">    AddTriangleColor(cell.Color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们之前没有使用一个颜色值作为参数构建四边形区域的方法，这里我们重载<code>AddQuadColor</code>方法。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMesh</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 使用一个颜色值构建四边形区域，河道在cell中心时候用到</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;color&quot;&gt;</span>cell自身的颜色值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AddQuadColor</span>(<span class="params">Color color</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        colors.Add(color);</span><br><span class="line">        colors.Add(color);</span><br><span class="line">        colors.Add(color);</span><br><span class="line">        colors.Add(color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-14-5.png"></p>
<p>　　至此，我们就完成了集中河流组合中最简单的一种：河流笔直穿过一个地图单元，这种情况下的地图单元构建。接下来的章节中，我们先来分析河流起点和终点应该如何进行三角构建，并实现。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/a2a6458abff017eae5ebb9397743f6641a524a41">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>6-15 河流的起点与终点</title>
    <url>/2020/12/17/HexMap/6-15%20%E6%B2%B3%E6%B5%81%E7%9A%84%E8%B5%B7%E7%82%B9%E4%B8%8E%E7%BB%88%E7%82%B9/</url>
    <content><![CDATA[<p>　　在上一章中，我们完成了当河流笔直穿过地图单元时，河道的三角构建。在这一章中我们先来分析如何构建河流的起点与终点。这一章中我们来完成河流起点与终点的构建。<br>　　河流的起点和终点的构建，与之前构建地图单元的方式有很大的区别。所以我们需要创建一个专门构建地图单元内河流起点与终点的方法，如果在一个地图单元内存在河流的起点或终点，那就调用这个方法进行构建。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Triangulate</span>(<span class="params">HexDirection direction, HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cell.HasRiver)</span><br><span class="line">    &#123;</span><br><span class="line">        …</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//检测是否为河流的起点或者终点</span></span><br><span class="line">        <span class="comment">//如果是起点或终点，那就使用特殊的方法构建</span></span><br><span class="line">        <span class="keyword">if</span> (cell.HasRiverBeginOrEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            TriangulateWithRiverBeginOrEnd(direction, cell, center, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TriangulateWithRiver(direction, cell, center, e);</span><br><span class="line">        &#125;</span><br><span class="line">    ｝</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　我们希望河流在地图单元的中心开始或终止，这里还是使用中位线的方式将其分为两个部分，我们先构建中位线到地图单元边缘的部分。这里要注意，由于起点或终点是要向地图单元的中心点聚拢的，所以我们这里依然使用各个顶点均分中位线的方式，来计算每个顶点的位置。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMesh</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 构建河流起点或终点的cell</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>河流进入或者流出的方向<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;cell&quot;&gt;</span>cell自身实例<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;center&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateWithRiverBeginOrEnd</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//计算中位线上的5个顶点位置</span></span><br><span class="line">        <span class="comment">//这里注意，由于是河流的终点或起点，所以河流整体是向内聚拢的，5个顶点对中位线进行等分</span></span><br><span class="line">        EdgeVertices m = <span class="keyword">new</span> EdgeVertices(</span><br><span class="line">            Vector3.Lerp(center, e.v1, <span class="number">0.5f</span>),</span><br><span class="line">            Vector3.Lerp(center, e.v5, <span class="number">0.5f</span>)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依然保持河道高度</span></span><br><span class="line">        m.v3.y = e.v3.y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建中位线到cell边缘的梯形，这里是由4个矩形组成的，跟连接区域类似，所以使用了构建连接区域的方法</span></span><br><span class="line">        TriangulateEdgeStrip(m, cell.Color, e, cell.Color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，可以构建中位线到地图单元中心的部分，这里已经获得了中位线上的5个顶点位置了，所以直接使用对应的方法进行构建即可。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateWithRiverBeginOrEnd</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构建顶点到中位线的区域</span></span><br><span class="line">    TriangulateEdgeFan(center, m, cell.Color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-15-1.png"></p>
<p>　　至此，我们就完成了有河流起点或重点的地图单元内河道的构建。接下来的章节中，我们来分析如何构建地图单元内有拐弯的河流。</p>
<p>[Github代码](</p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>6-16 一折河道的构建</title>
    <url>/2020/12/18/HexMap/6-16%20%E4%B8%80%E6%8A%98%E6%B2%B3%E9%81%93%E7%9A%84%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<p>　　在上一章中，我们完成了河流的起点或终点在地图单元中的构建。结合之前笔直穿过地图单元的河流，我们现在已经可以在地图上画出不拐弯的河流并正确的显示出来了。但是我们发现，如果一条河流经过地图单元的时候，方向发生了变化，那么河流的视觉效果就产生了错误。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-16-1.png"></p>
<p>　　这里，我们将河流在一个地图单元上的流入口和流出口，在两个相邻边上的情况，叫做<code>一折河道</code>，另外一种情况，就是流出口和流入口中间相隔一条边的情况，叫做<code>二折河道</code>。在本章中，我们来实现如何正确的构建一折河道的三角面片。<br>　　我们回到<code>HexMesh.TriangulateWithRiver</code>方法中，在这里进行判断，如果河流是笔直穿过地图单元，那么就使用现有的方式进行构建。否则依然将中位线上的5个顶点平均分布在其上，使得河道呈现向地图单元中心点聚拢的效果。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateWithRiver</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3 centerL, centerR;</span><br><span class="line">    <span class="comment">//这里将河道情况分开讨论了</span></span><br><span class="line">    <span class="comment">//1 笔直穿过cell的河道</span></span><br><span class="line">    <span class="comment">//2 出入口相邻的河道</span></span><br><span class="line">    <span class="comment">//3 出入口间隔一条边的河道</span></span><br><span class="line">    <span class="keyword">if</span> (cell.HasRiverThroughEdge(direction.Opposite()))<span class="comment">//先判断是否是笔直穿过</span></span><br><span class="line">    &#123;</span><br><span class="line">        centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="number">0.25f</span>;</span><br><span class="line">        centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="number">0.25f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果不是笔直的河道，就将河流端点聚拢在cell中心</span></span><br><span class="line">        centerL = centerR = center;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-16-2.png"></p>
<p>　　接着，我们判断当前河道的两个相邻边，是否有其他河道，这样我们就知道当前穿过地图单元的河道是否为一折河道了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateWithRiver</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cell.HasRiverThroughEdge(direction.Opposite()))</span><br><span class="line">    &#123;</span><br><span class="line">        centerL = center + HexMetrics.GetFirstSolidCorner(direction.Previous()) * <span class="number">0.25f</span>;</span><br><span class="line">        centerR = center + HexMetrics.GetSecondSolidCorner(direction.Next()) * <span class="number">0.25f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cell.HasRiverThroughEdge(direction.Next()))<span class="comment">//出入口相邻的河道 出口在下面</span></span><br><span class="line">    &#123;</span><br><span class="line">        centerL = center;</span><br><span class="line">        centerR = Vector3.Lerp(center, e.v5, <span class="number">0.5f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cell.HasRiverThroughEdge(direction.Previous()))<span class="comment">//出入口相邻的河道 出口在上面</span></span><br><span class="line">    &#123;</span><br><span class="line">        centerL = Vector3.Lerp(center, e.v1, <span class="number">0.5f</span>);</span><br><span class="line">        centerR = center;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        centerL = centerR = center;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　在确认了河道两侧端点位置之后，我们可以通过偏移中心点的位置，使其偏离河道的中心一些，让河道在转弯处看起来没那么狭窄。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateWithRiver</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cell.HasRiverThroughEdge(direction.Opposite()))</span><br><span class="line">    &#123;</span><br><span class="line">        …</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新计算cell中心点的位置，让其偏离河道弯折处，这样河道在转弯的地方就不会显得狭窄了</span></span><br><span class="line">    center = Vector3.Lerp(centerL, centerR, <span class="number">0.5f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-16-3.png"></p>
<p>　　在观察运行结果之后，我们发现虽然河道宽度在转弯的时候没有改变，但还是有一种河道被挤压了的感觉。这是应为河道因为转弯，中心线形成了一个60度的夹角，内侧看起来就像变窄了一样。在这里我们将弯道内侧的顶点偏移量减小，使得内侧的空间变大，来避免出现这种挤压感。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMesh.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">TriangulateWithRiver</span>(<span class="params">HexDirection direction, HexCell cell, Vector3 center, EdgeVertices e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cell.HasRiverThroughEdge(direction.Next()))<span class="comment">//出入口相邻的河道 出口在下面</span></span><br><span class="line">    &#123;</span><br><span class="line">        centerL = center;</span><br><span class="line">        <span class="comment">//虽然河道宽度一直没有改变，但是因为弯道造成了一种挤压感</span></span><br><span class="line">        <span class="comment">//这里将弯道内侧的顶点偏移量减小，环节视觉上的挤压感</span></span><br><span class="line">        centerR = Vector3.Lerp(center, e.v5, <span class="number">2f</span> / <span class="number">3f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cell.HasRiverThroughEdge(direction.Previous()))<span class="comment">//出入口相邻的河道 出口在上面</span></span><br><span class="line">    &#123;</span><br><span class="line">        centerL = Vector3.Lerp(center, e.v1, <span class="number">2f</span> / <span class="number">3f</span>);</span><br><span class="line">        centerR = center;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-16-4.png"></p>
<p>　　至此，我们就完成了一折河道的构建，并优化了其在视觉上产生的一些挤压感，让河道看起来更加自然。在下一章中，我们将分析并完成二折河道的构建。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/e56e19fa8c02c9a7af9630dc29691bd6060cf4da">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>6-2 河流方向</title>
    <url>/2020/12/04/HexMap/6-2%20%E6%B2%B3%E6%B5%81%E6%96%B9%E5%90%91/</url>
    <content><![CDATA[<p>　　在上一章中，我们确认了要使用哪种河流的形式，并分析了河流在地图单元中的几种分布形式。这一章中我们先创建一些变量和方法，用来存储和获取当前地图单元内是否有河流，并且记录河流的流向等。<br>　　首先我们先定义两个变量，用来存储河流经过当前地图单元的流向，即是流入还是流出的。这两个变量我们可以在<code>HexCell</code>中声明，因为构建单个地图单元，都是在这个勒种完成的。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用来记录当前cell是否有河流 流入/流出</span></span><br><span class="line">    <span class="comment">//只流出是河流起点，只流入是河流终点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> hasIncomingRiver;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> hasOutgoingRiver;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　但是仅仅只有河流的流入和流出信息还不够，我们还需要知道河流的流出方位与流出方位。再声明两个变量，用来存储河流是从哪个方位流入与流出的。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//记录河流的流入方位和流出方位</span></span><br><span class="line">    <span class="keyword">private</span> HexDirection incomingRiver;</span><br><span class="line">    <span class="keyword">private</span> HexDirection outgoingRiver;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　变量声明完成后，我们使用对应的Get属性来获取这些变量的值，对这些变量的赋值操作，将会在之后章节的其他方法中实现。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//cell中是否有河流 流入/流出 以及 流入、流出方位，都使用属性来获取</span></span><br><span class="line">    <span class="comment">//赋值部分会在其他的方法中进行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取cell是否有河流的流入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> HasIncomingRiver</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> hasIncomingRiver;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取cell是否有河流的流出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> HasOutgoingRiver</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> hasOutgoingRiver;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取cell中河流的流入方向</span></span><br><span class="line">    <span class="keyword">public</span> HexDirection IncomingRiver</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> incomingRiver;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取cell中河流的流出方向</span></span><br><span class="line">    <span class="keyword">public</span> HexDirection OutgoingRiver</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> outgoingRiver;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接着就是要能获取当前地图单元是否含有河流。我们同样声明一个属性来获取这个信息。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取当前cell中是否有河流</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> HasRiver</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> hasIncomingRiver || hasOutgoingRiver;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　然后是要判断，当前的地图单元是否为河流的起点或者终点，也就是说当<code>hasIncomingRiver</code>与<code>hasOutgoingRiver</code>两个变量的值不同的时候，就表示当前地图单元是河流的起点或者终点。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取当前的cell是否为河流的起点或终点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> HasRiverBeginOrEnd</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> hasIncomingRiver != hasOutgoingRiver;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最后，我们还需要一个方法来判断，地图单元的某个特定方位的边，是否有河流经过，不管河流是流入还是流出。这个方法是比较重要的，因为它涉及到后面一些三角剖分的工作。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexCell</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 检查cell中指定方位的边是否有河流经过，不论是流入还是流出</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>当前cell指定方位的边<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>true该边有河流经过，false该边没有河流经过<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">HasRiverThroughEdge</span>(<span class="params">HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            <span class="comment">//检查指定方位是否有河流的流入</span></span><br><span class="line">            hasIncomingRiver &amp;&amp; incomingRiver == direction</span><br><span class="line">            ||</span><br><span class="line">            <span class="comment">//检查指定方位是否有河流的流出</span></span><br><span class="line">            hasOutgoingRiver &amp;&amp; outgoingRiver == direction;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　至此，我们创建了一些变量、属性和方法，用来保存和获取河流经过一个地图单元的各种形式和状态。在接下来的章节中，我们将创建一些方法用来移出和添加河流。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/commit/d95af304a44eb2fe5eba3cb4291d99e6996f3039">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>6-3 移除河流</title>
    <url>/2020/12/05/HexMap/6-3%20%E7%A7%BB%E9%99%A4%E6%B2%B3%E6%B5%81/</url>
    <content><![CDATA[<p>　　在上一章中，我们创建了一些方法，来存储河流经过一个地图单元的方位等信息。在这一章节中，我们先来创建移除地图单元内河流的一些相关方法。<br>　　首先创建一个方法，移除地图单元内河流的流出部分，如果检测到当前地图单元没有河流的流出，那就直接跳出。如果有河流的流出，进行修改后，将标记设置为<code>false</code>并且刷新地图。这里实际移除河流的代码，会在之后的章节中完善。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 删除cell自身流出的河流</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveOutgoingRiver</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断当前cell是否有流出的河流</span></span><br><span class="line">    <span class="comment">//没有河流留出的话就直接跳出</span></span><br><span class="line">    <span class="keyword">if</span> (hasOutgoingRiver == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有流出的河流，就将cell流出状态改为false，并刷新当前chunk</span></span><br><span class="line">    hasOutgoingRiver = <span class="literal">false</span>;</span><br><span class="line">    Refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　如果当前地图单元有河流的流出，那么其相邻地图单元也一定会有河流的流入。根据处理流入的逻辑，用同样方法处理流出。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveOutgoingRiver</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasOutgoingRiver == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hasOutgoingRiver = <span class="literal">false</span>;</span><br><span class="line">    Refresh();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除当前cell河流的流出部分，那就要同时移除相邻cell河流的流入部分</span></span><br><span class="line">    HexCell neighbor = GetNeighbor(outgoingRiver);</span><br><span class="line">    <span class="comment">//将相邻cell流入的标记设置为false</span></span><br><span class="line">    neighbor.hasIncomingRiver = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//刷新相邻cell所在的chunk</span></span><br><span class="line">    neighbor.Refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>河流会延伸到地图之外么?<br>虽然有能实现这个功能,但我们不会这么做。所以也不用检查相邻地图单元存在。</p>
</blockquote>
<p>　　移除当前地图单元的河流，只会影响它自身的外观，这与改变高度与颜色不同，我们不用考虑其对相邻地图单元造成的影响，所以我们只需要刷新当前的地图单元就可以了。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveOutgoingRiver</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasOutgoingRiver == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hasOutgoingRiver = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//Refresh();</span></span><br><span class="line">    <span class="comment">//与改变高度和颜色不同，移除河流只会影响自身，所以只需要刷新自身mesh即可</span></span><br><span class="line">    <span class="comment">//与其相邻的cell同理</span></span><br><span class="line">    RefreshSelfOnly();</span><br><span class="line"></span><br><span class="line">    HexCell neighbor = GetNeighbor(outgoingRiver);</span><br><span class="line">    neighbor.hasIncomingRiver = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//刷新相邻cell所在的chunk</span></span><br><span class="line">    <span class="comment">//neighbor.Refresh();</span></span><br><span class="line">    neighbor.RefreshSelfOnly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这个<code>RefershSelfOnly</code>方法目前就使用刷新当前你地图单元所在的地图块方法，因为当整个地图初始化时还没有对河流进行编辑，所以也不需要考虑此时地图块是否已赋值的问题。编辑河流后刷新自身的代码，会在之后的章节完善。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 刷新cell自身的mesh</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RefreshSelfOnly</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当前并未完善河流编辑功能，目前先使用刷新chunk的方法</span></span><br><span class="line">    chunk.Refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　移除相邻流入河流的方法思路基本相同。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 移除cell自身流入的河流</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveIncomingRiver</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//思路与移除流出河流基本相同</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasIncomingRiver == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hasIncomingRiver = <span class="literal">false</span>;</span><br><span class="line">    RefreshSelfOnly();</span><br><span class="line"></span><br><span class="line">    HexCell neighbor = GetNeighbor(incomingRiver);</span><br><span class="line">    neighbor.hasOutgoingRiver = <span class="literal">false</span>;</span><br><span class="line">    neighbor.RefreshSelfOnly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最后再添加一个方法，移除地图单元内的全部河流。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 移除cell自身流入和流出的河流</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RemoveRiver</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RemoveOutgoingRiver();</span><br><span class="line">    RemoveIncomingRiver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　至此，我们就完成了移除地图单元内河流的方法。接下来的一章中，我们将创建给地图单元内添加河流的方法。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/ecd7d026629a8301180a16438bfae442d1c28364">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>6-4 添加河流</title>
    <url>/2020/12/06/HexMap/6-4%20%E6%B7%BB%E5%8A%A0%E6%B2%B3%E6%B5%81/</url>
    <content><![CDATA[<p>　　在上一章中，我们完成了移除地图单元内河流的方法。在这一章中，我们将创建在地图单元内添加河流的方法。要实现添加河流的功能，<br>　　要实现z唉地图单元内添加河流的功能，只需要一个方法设置地图单元内流出方向的河流。这个方法应该覆盖之前流出方向的河流，并设置相应的相邻地图单元的流入方向的河流。<br>　　首先，当要设置的方向已经存在河流时直接跳出。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 创建一条流出当前cell的河流</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;direction&quot;&gt;</span>流出河流的方位<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetOutgoingRiver</span>(<span class="params">HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果当前cell内有流出的河流，并且流出的方向与入参给出的方向相同，直接跳出</span></span><br><span class="line">    <span class="keyword">if</span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　然后得确保在流出方向上存在一个相邻的地图单元。并且河流不能向着更高的位置流动，所以检测到相邻地图单元高于当前地图单元时时跳出方法。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetOutgoingRiver</span>(<span class="params">HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasOutgoingRiver &amp;&amp; outgoingRiver == direction)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与移除河流思路相似，同时为相邻的cell添加流入的河流</span></span><br><span class="line">    HexCell neighbor = GetNeighbor(direction);</span><br><span class="line">    <span class="comment">//这里注意，如果没有相邻的cell，或者相邻的cell高于当前cell，都不可以创建河流</span></span><br><span class="line">    <span class="comment">//河流是不会从低处流向高处的</span></span><br><span class="line">    <span class="keyword">if</span> (!neighbor || elevation &lt; neighbor.elevation)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接下来，清除之前流出方向不同的河流。并且当前地图单元中流入的河流方向，与新的流出的方向相同，那么还要移除当前地图单元中流入的河流。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetOutgoingRiver</span>(<span class="params">HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除当前cell中，与入参方向不同的那个流出的河流</span></span><br><span class="line">    RemoveOutgoingRiver();</span><br><span class="line">    <span class="comment">//如果入参河流的方向，与流入当前cell河流的方向相同，那么还要移除流入当前cell 的河流</span></span><br><span class="line">    <span class="keyword">if</span> (hasIncomingRiver &amp;&amp; incomingRiver == direction)</span><br><span class="line">    &#123;</span><br><span class="line">        RemoveIncomingRiver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　然后设置流出河流标记和方向，并刷新当前地图单元。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetOutgoingRiver</span>(<span class="params">HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置流出标记和方向，并刷新当前cell</span></span><br><span class="line">    hasOutgoingRiver = <span class="literal">true</span>;</span><br><span class="line">    outgoingRiver = direction;</span><br><span class="line">    RefreshSelfOnly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最后，当相邻地图单元中已经有流入的河流时，移除它并设置新的流入河流。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetOutgoingRiver</span>(<span class="params">HexDirection direction</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除相邻cell中旧的流入河流，设置流入标记和新的方位，并且刷新相邻的cell</span></span><br><span class="line">    neighbor.RemoveIncomingRiver();</span><br><span class="line">    neighbor.hasIncomingRiver = <span class="literal">true</span>;</span><br><span class="line">    neighbor.incomingRiver = direction.Opposite();</span><br><span class="line">    neighbor.RefreshSelfOnly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　至此，我们就完成了在地图单元内创建河流的基本方法了。这些方法目前只是创建河流的基本思路，在之后的章节中，我们将逐步完善这些方法。在下一章中，我们将添加一些代码，来防止河流逆流的情况发生。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/43d90cd39cd6ddd7af3333eb5f14f30ad83ca9a5">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>6-5 防止河流逆流</title>
    <url>/2020/12/07/HexMap/6-5%20%E9%98%B2%E6%AD%A2%E6%B2%B3%E6%B5%81%E9%80%86%E6%B5%81/</url>
    <content><![CDATA[<p>　　在之前的章节中，我们创建了添加、移除河流的方法。但是我们忽略了一点，就是河流不能从低处往高处流，也就是河流逆流的情况。当我们编辑地图单元的高度的时候，我们需要判断其中的河流是否会发生逆流的情况，如果有的话，就要移除这些逆流的河流。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexCell.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Elevation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> elevation;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">        …</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//当前有河流从cell流出，如果流出cell高度小于相邻流入cell高度，这就是河流的逆流，移除流出河流</span></span><br><span class="line">        <span class="keyword">if</span> (hasOutgoingRiver &amp;&amp; elevation &lt; GetNeighbor(outgoingRiver).elevation)</span><br><span class="line">        &#123;</span><br><span class="line">            RemoveOutgoingRiver();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//与流出判断相类似，当流入cell高度大于流出cell高度时，也是逆流的情况</span></span><br><span class="line">        <span class="keyword">if</span> (hasIncomingRiver &amp;&amp; elevation &gt; GetNeighbor(incomingRiver).elevation)</span><br><span class="line">        &#123;</span><br><span class="line">            RemoveIncomingRiver();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，在编辑地图单元高度的时候，就可以防止河流出现逆流的情况了。在下一章中，我们要创建编辑河流的UI部分，为最后时限拖拽鼠标创建河流做准备。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/ae932aaf8387aea2c875a0791aa42f637a421001">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>6-6 河流编辑器UI</title>
    <url>/2020/12/08/HexMap/6-6%20%E6%B2%B3%E6%B5%81%E7%BC%96%E8%BE%91%E5%99%A8UI/</url>
    <content><![CDATA[<p>　　在之前的章节中，我们创建了添加、移除河流的相关方法，并对每个地图单元内的河流作出了防止逆流的检测。在这一章中，我们要创建地图编辑器UI中，与创建河流相关的功能UI。在现有UI基础上，我们添加一个河流选项卡，选项卡中有三种模式可选，分别是：关闭、添加、移除。这个选项卡的形式，与颜色选项卡类似，都使用<code>Toggle</code>组件即可。同时我们使用枚举来记录当前的选中状态。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//河流编辑器的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> OptionalToggle</span><br><span class="line">    &#123;</span><br><span class="line">        Ignore, Yes, No</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前河流编辑器选中的状态</span></span><br><span class="line">    <span class="keyword">private</span> OptionalToggle riverMode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接着，要创建一个方法以供UI中的选项卡按钮调用，来更改当前状态。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 设置河流编辑器的状态</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;mode&quot;&gt;</span>状态美剧索引值<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetRiverMode</span>(<span class="params"><span class="keyword">int</span> mode</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        riverMode = (OptionalToggle)mode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　接最后我们需要一个新的<code>Toggle Group</code>组件来建立这三个<code>Toggle</code>组件的联系。并且这三个<code>Toggle</code>组件都挂载<code>SetRiverMode</code>方法。最终结果如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-6-1.png"></p>
<p>　　至此，我们就完成了河流编辑器UI部分的功能了。在下一章中，我们将检测鼠标左键按下时的拖拽信息，这些信息可以用来当做创建河流的起点和方向。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/b42ce1a50db76badcb4563e79364b64e10ad5d6b">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>6-7 检测鼠标拖拽</title>
    <url>/2020/12/09/HexMap/6-7%20%E6%A3%80%E6%B5%8B%E9%BC%A0%E6%A0%87%E6%8B%96%E6%8B%BD/</url>
    <content><![CDATA[<p>　　在上一章中，我们完成了河流编辑器的UI部分，通过点选<code>Toggle</code>就可以选择当前是否可以编辑河流。在这一章中，我们继续为创建河流做前期的一些工作，首先是通过什么样的交互形式来创建河流。这里我们通过参考其他的地图编辑器功能，选择了使用鼠标拖动的形式来创建河流。也就是拖动鼠标经过若干个地图单元，地图系统就会跟着鼠标的轨迹在这些地图单元上创建河流。<br>　　要实现这个功能，就需要同时获得地图单元的位置和鼠标在这个地图单元移动的方位，回到<code>HexMapEditor.cs</code>中，在脚本中添加获取这两个数据的方法。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断当前是否处于拖拽状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">bool</span> isDrag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断鼠标在当前cell的移动方位</span></span><br><span class="line">    <span class="keyword">private</span> HexDirection dragDirection;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当鼠标到下一个cell 的时候，这里记录上一个cell</span></span><br><span class="line">    <span class="keyword">private</span> HexCell previousCell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　最初的时候是没有拖拽事件的，也就没有上一个地图单元的记录。所以当没有输入信息或者没有与地图交互时，需要设置其为null。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonUp(<span class="number">0</span>) &amp;&amp; !EventSystem.current.IsPointerOverGameObject())</span><br><span class="line">        &#123;</span><br><span class="line">            HandleInput();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当鼠标左键没有按下的时候，记录上一个经过的cell为空</span></span><br><span class="line">            previousCell = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleInput</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Physics.Raycast(_inputRay, <span class="keyword">out</span> _hit))</span><br><span class="line">        &#123;</span><br><span class="line">            …</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当鼠标的射线未触碰到地图的时候，上一个经过的cell为空</span></span><br><span class="line">            previousCell = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　当前地图单元是根据射线碰撞点找到的，当在这一帧里结束编辑时，它就会变成下一次Update里的上一个地图单元。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleInput</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Physics.Raycast(_inputRay, <span class="keyword">out</span> _hit))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//记录当前射线碰撞到的cell</span></span><br><span class="line">            HexCell currentCell = hexGrid.GetCell(_hit.point);</span><br><span class="line">            <span class="comment">//记录当前正在编辑的cell</span></span><br><span class="line">            EditCells(currentCell);</span><br><span class="line">            <span class="comment">//目前上一个cell与当前cell是一个</span></span><br><span class="line">            previousCell = currentCell;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            …</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　确认了当前射线碰撞到的地图单元之后,我们可以与前一个地图单元(如果有的话)进行比较,当发现是两个不同的单元格时,就说明可能存在有效拖动并需要去检测,要不就是没有拖拽事件。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleInput</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        …</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Physics.Raycast(_inputRay, <span class="keyword">out</span> _hit))</span><br><span class="line">        &#123;</span><br><span class="line">            HexCell currentCell = hexGrid.GetCell(_hit.point);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断当前cell与之前的cell是否为同一个</span></span><br><span class="line">            <span class="comment">//如果是，就是在拖拽</span></span><br><span class="line">            <span class="keyword">if</span> (previousCell &amp;&amp; previousCell != currentCell)</span><br><span class="line">            &#123;</span><br><span class="line">                ValidateDrag(currentCell);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                isDrag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            …</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            …</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　如何证实确实是拖拽事件？通过检测当前地图单元是否与前一个地图单元相邻，循环遍历前一个地图单元所有相邻地图单元来进行检测，如果找到了与当前地图单元相吻合的结果，就能同时确认拖拽的方向。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line">    </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 确认拖拽方向</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name=&quot;currentCell&quot;&gt;</span>当前射线所碰撞到的cell<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ValidateDrag</span>(<span class="params">HexCell currentCell</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//循环遍历当前cell的6个方位</span></span><br><span class="line">        <span class="keyword">for</span> (dragDirection = HexDirection.NE; dragDirection &lt;= HexDirection.NW; dragDirection++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果之前cell某个方位上的cell，与当前射线触碰到的cell相同，就证明发生了碰撞</span></span><br><span class="line">            <span class="comment">//可以这样理解，当真实发生拖拽了，会记录下previousCell</span></span><br><span class="line">            <span class="comment">//鼠标移动至新的cell后，开始检测previousCell在对应方位上是不是有新的cell</span></span><br><span class="line">            <span class="comment">//如果有，就证明鼠标从previousCell拖拽移动到了新的cell上</span></span><br><span class="line">            <span class="keyword">if</span> (previousCell.GetNeighbor(dragDirection) == currentCell)</span><br><span class="line">            &#123;</span><br><span class="line">                isDrag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        isDrag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样逐帧检测这不会产生拖拽抖动么？<br>当你移动鼠标穿过地图单元边界时，可能会在单元格之间快速来回摆动，这确实会导致拖拽抖动，但情况没那么糟。<br>可以通过记录上一次拖拽事件来减缓抖动，然后防止下一次直接向相反方向拖拽即可。</p>
</blockquote>
<p>　　至此，我们完成了通过检测鼠标左键按下后，是否产生了拖拽的动作。在下一章中，我们将继续完善移除和添加河流的部分代码，并最终可以在Inspector的Debug模式下看到效果。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/bb92da8439479f62c024c9782f043dab01d95766">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>6-8 编辑地图单元上的河流信息</title>
    <url>/2020/12/10/HexMap/6-8%20%E7%BC%96%E8%BE%91%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E4%B8%8A%E7%9A%84%E6%B2%B3%E6%B5%81%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>　　在上一章中，我们完成了对鼠标左键按下时拖拽的检测，并创建了相关逻辑处理的代码。在这一章中我们将完善这些逻辑，使我们可以在Inspector面板的Debug模式下，可以看到地图单元上是否有河流与河流的信息。<br>　　目前我们已经可以检测鼠标左键按下后的拖拽事件了。接下来，我们就可以对每个地图单元上添加或移除河流信息了。这里要注意，移除河流是不需要检测鼠标左键按下时的拖拽事件的。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EditCell</span>(<span class="params">HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cell)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">        …</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (riverMode == OptionalToggle.No)</span><br><span class="line">        &#123;</span><br><span class="line">            cell.RemoveRiver();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isDrag &amp;&amp; riverMode == OptionalToggle.Yes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//设置之前的cell中 河流的流出方位</span></span><br><span class="line">            previousCell.SetOutgoingRiver(dragDirection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　这样，我们就就可以通过数百左键按下拖拽，在两个相邻的地图单元上创建流入和流出的河流了。但这样只是针对单个地图单元进行操作，我们忽略了笔刷的因素，感觉上没有什么不妥。既然有笔刷这个属性，那么我们在创建河流的时候，就应该创建出所有在笔刷范围内地图单元的河流。既然是在笔刷覆盖单位内创建河流信息，那就要确保笔刷覆盖范围内，都有地图单元的实例。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">EditCell</span>(<span class="params">HexCell cell</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cell)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line">        …</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (riverMode == OptionalToggle.No)</span><br><span class="line">        &#123;</span><br><span class="line">            cell.RemoveRiver();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isDrag &amp;&amp; riverMode == OptionalToggle.Yes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//检测当前cell的拖拽方位上，是否有相邻cell 的实例</span></span><br><span class="line">            <span class="comment">//如果有实例，就创建相应的河流信息</span></span><br><span class="line">            HexCell otherCell = cell.GetNeighbor(dragDirection.Opposite());</span><br><span class="line">            <span class="keyword">if</span> (otherCell)</span><br><span class="line">            &#123;</span><br><span class="line">                otherCell.SetOutgoingRiver(dragDirection);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　运行Unity，通过鼠标左键按下后拖拽，我们就可以创建地图单元上的河流信息了，虽然现在我们没办法在Game窗口中直接看到河流的创建和删除，但是我们可以通过Inspector面板的Debug模式来查看每个地图单元上的河流信息是否正确。如下图：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-8-1.png"></p>
<p>　　这里要注意，我们之前使用了鼠标抬起事件<code>Input.GetMouseButtonUp(0)</code>来检测是否点击到了地图上，而现在因为添加了拖拽功能，所以只检测鼠标左键事件即可<code>Input.GetMouseButton(0)</code>。代码如下：</p>
<figure class="highlight csharp"><figcaption><span>HexMapEditor.cs</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HexMapEditor</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Update</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButton(<span class="number">0</span>) &amp;&amp; !EventSystem.current.IsPointerOverGameObject())</span><br><span class="line">        &#123;</span><br><span class="line">            …</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            …</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　至此，我们就完成了鼠标左键按下拖拽进行河流的创建或移除的功能了。在接下来的章节中，我们将分析河流的三角剖分形状，逐步作出在地图系统中可见的河流。</p>
<p><a href="https://github.com/Arthur-Delacroix/Tutorial-HexMap/tree/8f5e3aa80b860697dcb70deedb127cc02b2562f8">Github代码</a></p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>6-9 地图单元之间的河道</title>
    <url>/2020/12/11/HexMap/6-9%20%E5%9C%B0%E5%9B%BE%E5%8D%95%E5%85%83%E4%B9%8B%E9%97%B4%E7%9A%84%E6%B2%B3%E9%81%93/</url>
    <content><![CDATA[<p>　　在之前的章节中，我们已经完成了鼠标左键按下后创建和移除河流信息的基本逻辑，并可以在Inspector面板的Debug模式下看到这些信息。在接下来的章节中我们将再次修改地图的Mesh，创建真正可见的河流。<br>　　河流的三角剖分可以分为两个部分来考虑，即河道和水流，这里我们首先实现河道的三角剖分。在河道的三角剖分中，最简单的部分是两个地图单元之间的连接区域。目前这个区域是由3个四边形组成的，我们可以通过江都中间四边形的高度，并在其两侧增加两道墙来创建出一条河道，如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-9-1.png"></p>
<p>　　按照这个思路来创建河道的话，我们就需要额外的两个四边形当作河道两边的墙。另外一种思路，是使用4个四边形组成连接区域，我们可以通过降低中间顶点的位置，来行程一个两边倾斜的河道。如下图所示：</p>
<p><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexmap/6-9-2.png"></p>
<p>　　相比于增加两道墙的方案，4个四边形组成新的连接区域，面数并没有增加很多，而且我们只需要改变中间顶点的位置即可，不用在添加或移除河流的时候频繁的Mesh的创建和删除。在接下来的章节中，我们将先增加连接区域中的顶点，构建新的连接区域。</p>
]]></content>
      <categories>
        <category>Unity3D Hex Map</category>
      </categories>
      <tags>
        <tag>Unity3D</tag>
        <tag>Game develop</tag>
        <tag>Hex Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Github Actions实现Hexo自动化部署</title>
    <url>/2024/03/21/Hexo/Github%20Actions%E5%AE%9E%E7%8E%B0Hexo%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h4 id="1-配置SSH"><a href="#1-配置SSH" class="headerlink" title="1. 配置SSH"></a>1. 配置SSH</h4><ul>
<li>在Windows环境下，安装git。<a href="https://git-scm.com/">官网地址</a></li>
<li>安装完成后，在任意文件目录下点击鼠标右键，在弹出的右键菜单中选择<code>git bash here</code>，调出git命令行工具</li>
<li>在命令行工具窗口中输入以下命令，生成密钥文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成秘钥</span><br><span class="line">ssh-keygen -f github-deploy-key</span><br></pre></td></tr></table></figure></li>
<li>这时当前目录中会生成两个文件<ul>
<li><code>github-deploy-key</code> 为私钥文件</li>
<li><code>github-deploy-key.pub</code> 为公钥文件</li>
</ul>
</li>
</ul>
<h3 id="2-在Github中配置公钥和私钥"><a href="#2-在Github中配置公钥和私钥" class="headerlink" title="2. 在Github中配置公钥和私钥"></a>2. 在Github中配置公钥和私钥</h3><ul>
<li>首先转到Hexo源代码仓库，在仓库上方菜单中找到 Settings -&gt; Secrets and variables -&gt; Actions -&gt; New repository secret 创建一个私钥的secrets，如下图所示<br><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexo/1.png" alt="创建私钥"></li>
<li>其中<code>Name</code>为自定义的私钥名称，会在之后的步骤中使用，<code>Secret</code>是<code>github-deploy-key</code> 私钥文件的内容，用vscode等工具打开，将文件中的内容粘贴进去即可</li>
<li>转到Hexo站点目录，在Github中是用户名+.github.io形式的仓库，在仓库上方菜单中找到Settings -&gt; Deploy keys -&gt; Add deploy key，创建一个公钥的key，如下图所示<br><img src="http://magi-melchiorl.gitee.io/pages/Pics/Hexo/2.png" alt="创建公钥"></li>
<li>其中<code>Title</code>为自定义的公钥名称，<code>Key</code>为公钥内容，用vscode等工具打开<code>github-deploy-key.pub</code> 公钥文件，并将其中内容全部内容粘贴进去即可</li>
</ul>
<h3 id="3-创建Gtihub-Actions"><a href="#3-创建Gtihub-Actions" class="headerlink" title="3. 创建Gtihub Actions"></a>3. 创建Gtihub Actions</h3><ul>
<li>转到Hexo源代码仓库，在根目录下新建<code>.github</code>目录，下一级新建<code>workflows</code>目录，下一级创建文件<code>deploy_blog.yml</code>。目录结构为<code>[自己博客根目录]/.github/workflows/deploy_blog.yml</code></li>
<li>用vscode打开<code>deploy_blog.yml</code>文件，输入以下内容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 未优化和整理的脚本</span><br><span class="line">name: Blog CI&#x2F;CD</span><br><span class="line"></span><br><span class="line"># 触发条件：在 push 到 master 分支后触发</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches: </span><br><span class="line">      - master</span><br><span class="line"></span><br><span class="line">permissions:</span><br><span class="line">  contents: write</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  blog-cicd:</span><br><span class="line">    name: Hexo blog build &amp; deploy</span><br><span class="line">    runs-on: ubuntu-latest # 使用最新的 Ubuntu 系统作为编译部署的环境</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">    - name: Checkout codes</span><br><span class="line">      uses: actions&#x2F;checkout@v2</span><br><span class="line"></span><br><span class="line">    - name: Setup node</span><br><span class="line">      # 设置 node.js 环境</span><br><span class="line">      uses: actions&#x2F;setup-node@v1</span><br><span class="line">      with:</span><br><span class="line">        node-version: &#39;16.x&#39;</span><br><span class="line"></span><br><span class="line">    - name: Cache node modules</span><br><span class="line">      # 设置包缓存目录，避免每次下载</span><br><span class="line">      uses: actions&#x2F;cache@v1</span><br><span class="line">      with:</span><br><span class="line">        path: ~&#x2F;.npm</span><br><span class="line">        key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles(&#39;**&#x2F;package-lock.json&#39;) &#125;&#125;</span><br><span class="line"></span><br><span class="line">    - name: Install hexo dependencies</span><br><span class="line">      # 下载 hexo-cli 脚手架及相关安装包</span><br><span class="line">      run: |</span><br><span class="line">        npm install -g hexo-cli</span><br><span class="line">        npm install</span><br><span class="line"></span><br><span class="line">    - name: Generate files</span><br><span class="line">      # 编译 markdown 文件</span><br><span class="line">      run: |</span><br><span class="line">        hexo clean</span><br><span class="line">        hexo generate</span><br><span class="line"></span><br><span class="line">    - name: 配置 SSH 环境和 Git 环境</span><br><span class="line">      env:</span><br><span class="line">        ACTION_DEPLOY_KEY: $&#123;&#123; secrets.PRIVATE &#125;&#125;</span><br><span class="line">      run: |</span><br><span class="line">        mkdir -p ~&#x2F;.ssh&#x2F;</span><br><span class="line">        echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">        chmod 700 ~&#x2F;.ssh</span><br><span class="line">        chmod 600 ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">        ssh-keyscan github.com &gt;&gt; ~&#x2F;.ssh&#x2F;known_hosts</span><br><span class="line">        git config --global user.email &quot;373974021@qq.com&quot; # 注册Github的邮箱</span><br><span class="line">        git config --global user.name &quot;Arthur-Delacroix&quot; #Github的用户名</span><br><span class="line"></span><br><span class="line">    - name: 部署博客</span><br><span class="line">      run: |</span><br><span class="line">        npm install hexo-deployer-git --save</span><br><span class="line">        hexo d</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-Hexo-Deploy配置"><a href="#4-Hexo-Deploy配置" class="headerlink" title="4. Hexo Deploy配置"></a>4. Hexo Deploy配置</h3><blockquote>
<p>注意，在Hexo源代码仓库中，各类源代码要放在文件在根目录下，否则在推送的时候会有目录丢失等各类问题</p>
</blockquote>
<ul>
<li>在Hexo源代码仓库中，找到配置文件<code>_config.yml</code>，打开后在文件最下方填写以下内容<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  # 要推送的目标仓库ssh链接</span><br><span class="line">  repo: git@github.com:Arthur-Delacroix&#x2F;arthur-delacroix.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这样就实现在使用Github Actions，当在本地编辑完博客内并进行push操作后，Github Actions会自动使用Hexo将博客生成为html文件，并推送到指定仓库中了</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Hexo</tag>
        <tag>Github Actions</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D WebGL 相关踩坑记录 1</title>
    <url>/2020/09/15/Hexo/Part1/</url>
    <content><![CDATA[<p>Unity3D发布手机版可用的项目，基于2019.4版本，问题主要集中在以下几点：</p>
<ul>
<li>Unity3D WebGL 在移动端上不再弹出移动端浏览器警告。</li>
<li>自定义加载 Logo 和背景色等样式，未找到修改位置。</li>
<li>触摸等交互方式要适配移动端。目前使用了lean。</li>
<li>UI等界面元素适配移动端。</li>
<li>将 WebGL 内容嵌入 Hexo Next 博客中。</li>
</ul>
<p>非重要修改点为：</p>
<ul>
<li>默认全屏，或者有窗口尺寸选项，这个可能要通过JS来实现。</li>
<li>加载时的自定义 Logo ，目前测试可以使用 PNG 和 Base64 编码的图片，理论上应该可以使用 SVG 格式的图片，有待测试。 </li>
<li>加载时候的界面背景色未找到修改的位置。</li>
</ul>
<h5 id="Unity3D-WebGL-在移动端上不再弹出移动端浏览器警告"><a href="#Unity3D-WebGL-在移动端上不再弹出移动端浏览器警告" class="headerlink" title="Unity3D WebGL 在移动端上不再弹出移动端浏览器警告"></a>Unity3D WebGL 在移动端上不再弹出移动端浏览器警告</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">compatibilityCheck: <span class="function"><span class="keyword">function</span>(<span class="params">e, t, r</span>) </span>&#123;</span><br><span class="line">       t();</span><br><span class="line">    <span class="comment">/*UnityLoader.SystemInfo.hasWebGL ? UnityLoader.SystemInfo.mobile ? e.popup(&quot;Please note that Unity WebGL is not currently supported on mobiles. Press OK if you wish to continue anyway.&quot;, [&#123;</span></span><br><span class="line"><span class="comment">		text: &quot;OK&quot;,</span></span><br><span class="line"><span class="comment">		callback: t</span></span><br><span class="line"><span class="comment">	&#125;]) : [&quot;Edge&quot;, &quot;Firefox&quot;, &quot;Chrome&quot;, &quot;Safari&quot;].indexOf(UnityLoader.SystemInfo.browser) == -1 ? e.popup(&quot;Please note that your browser is not currently supported for this Unity WebGL content. Press OK if you wish to continue anyway.&quot;, [&#123;</span></span><br><span class="line"><span class="comment">		text: &quot;OK&quot;,</span></span><br><span class="line"><span class="comment">		callback: t</span></span><br><span class="line"><span class="comment">	&#125;]) : t() : e.popup(&quot;Your browser does not support WebGL&quot;, [&#123;</span></span><br><span class="line"><span class="comment">		text: &quot;OK&quot;,</span></span><br><span class="line"><span class="comment">		callback: r</span></span><br><span class="line"><span class="comment">	&#125;])*/</span></span><br><span class="line">&#125;,</span><br><span class="line">buildCompatibilityCheck: <span class="function"><span class="keyword">function</span>(<span class="params">e, t, r</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;undefined&quot;</span> == <span class="keyword">typeof</span> e.graphicsAPI) <span class="keyword">return</span> ! <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> t = <span class="number">0</span>; t &lt; e.graphicsAPI.length; t++) &#123;</span><br><span class="line">            <span class="keyword">var</span> r = e.graphicsAPI[t];</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;WebGL 2.0&quot;</span> == r &amp;&amp; <span class="number">2</span> == UnityLoader.SystemInfo.hasWebGL) <span class="keyword">return</span> ! <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;WebGL 1.0&quot;</span> == r &amp;&amp; UnityLoader.SystemInfo.hasWebGL &gt;= <span class="number">1</span>) <span class="keyword">return</span> ! <span class="number">0</span>;</span><br><span class="line">            e.print(<span class="string">&quot;Warning: Unsupported graphics API &quot;</span> + r)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ! <span class="number">1</span></span><br><span class="line">       &#125;</span><br><span class="line">       t();</span><br><span class="line">    <span class="comment">//n() ? !UnityLoader.SystemInfo.hasThreads &amp;&amp; e.multithreading ? r(&quot;Your browser does not support multithreading.&quot;) : t() : r(&quot;Your browser does not support any of the required graphics API for this content.&quot;)</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>当使用Unity3D 2019.4发布了WebGL项目后，会在Build目录下生成一个UnityLoader.js文件，这个文件感觉主要是加载Unity3D WebGL的内容，而且是一个压缩版的。</p>
<ol>
<li>使用网上的JS格式美化工具，将整个JS代码进行格式美化，使代码可读。  </li>
<li>要修改的代码集中在2628到2654行之间，不同的代码格式美化工具，可能行数会有不同。</li>
<li>找到 <code>compatibilityCheck: function(e, t, r)</code> 和 <code>buildCompatibilityCheck: function(e, t, r)</code> 这两个方法，将其方法体注释掉，添加 <code>t();</code> </li>
</ol>
<p>注意，这样虽然屏蔽了所有浏览器的警告提示，可以在手机浏览器，包括微信内，都可以打开 Unity3D WebGL 的内容。但是在某些浏览器内因为内核的问题，导致内容不会加载，也没有相关提示，只显示一个灰色的色块。目前已知有问题的浏览器是Mac端的Safari。</p>
<h5 id="Unity3D-WebGL-代码嵌入-Hexo-Next-页面中"><a href="#Unity3D-WebGL-代码嵌入-Hexo-Next-页面中" class="headerlink" title="Unity3D WebGL 代码嵌入 Hexo Next 页面中"></a>Unity3D WebGL 代码嵌入 Hexo Next 页面中</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;Build/UnityLoader.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">UnityLoader.instantiate(<span class="string">&quot;unityContainer&quot;</span>, <span class="string">&quot;Build/WebGL_Build.json&quot;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;unityContainer&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 800px; height: 450px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;head&gt;</code> 标签内的两个 script 引用，和 <code>&lt;body&gt;</code> 内的div引用，需要复制到引用该 WebGL 的 html 界面对应位置，注意，这里必须是由Hexo生成的Html界面。</li>
<li>目前使用的Next深色主题，背景色为 <code>RGB(51, 51, 51, 1)</code>，宽度为800px。</li>
<li>UnityLoader.js 必须 和Unity 打包好的资源文件放在相同的目录下。例如生成的 html 界面名字为post1.html，同级目录下存放WebGL的文件夹。文件夹内存放 UnityLoader.js 脚本和相关的WebGL资源。<br>可以通过修改 <code>&lt;script&gt;</code> 标签内的引用路径，将该资源存放到其他位置。</li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Unity WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity3D WebGL 相关踩坑记录 2</title>
    <url>/2020/09/17/Hexo/Part2/</url>
    <content><![CDATA[<h5 id="自定义加载界面的-Logo-和进度条样式"><a href="#自定义加载界面的-Logo-和进度条样式" class="headerlink" title="自定义加载界面的 Logo 和进度条样式"></a>自定义加载界面的 Logo 和进度条样式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Dark: </span><br><span class="line">&#123;</span><br><span class="line">    progressLogoUrl: &quot;http:&#x2F;&#x2F;magi-melchiorl.gitee.io&#x2F;pages&#x2F;Logo.png&quot;,</span><br><span class="line">    progressEmptyUrl: &quot;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAAI0AAAASCAYAAABmbl0zAAAACXBIWXMAAAsSAAALEgHS3X78AAAATUlEQVRo3u3aIQ4AIAwEQUr4&#x2F;5cPiyMVBDOj0M2mCKgkGdAwjYCudZzLOLiITYPrCdEgGkSDaEA0iAbRIBpEA6JBNHx1vnL7V4NNwxsbCNMGI3YImu0AAAAASUVORK5CYII&#x3D;&quot;,</span><br><span class="line">    progressFullUrl: &quot;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAAI0AAAASCAYAAABmbl0zAAAACXBIWXMAAAsSAAALEgHS3X78AAAAO0lEQVRo3u3SQREAAAjDMMC&#x2F;56EB3omEXjtJCg5GAkyDaTANpsE0YBpMg2kwDaYB02AaTINpMA2Yhr8FO18EIBpZMeQAAAAASUVORK5CYII&#x3D;&quot;</span><br><span class="line">&#125;,</span><br><span class="line">Light: </span><br><span class="line">&#123;</span><br><span class="line">    progressLogoUrl: &quot;http:&#x2F;&#x2F;magi-melchiorl.gitee.io&#x2F;pages&#x2F;Logo.png&quot;,</span><br><span class="line">    progressEmptyUrl: &quot;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAAI0AAAASCAYAAABmbl0zAAAACXBIWXMAAAsSAAALEgHS3X78AAAAUUlEQVRo3u3aMQ4AEAxAUcRJzGb3v1mt3cQglvcmc&#x2F;NTA3XMFQUuNCPgVk&#x2F;nahwchE2D6wnRIBpEg2hANIgG0SAaRAOiQTR8lV+5&#x2F;avBpuGNDcz6A6oq1CgNAAAAAElFTkSuQmCC&quot;,</span><br><span class="line">    progressFullUrl: &quot;data:image&#x2F;png;base64,iVBORw0KGgoAAAANSUhEUgAAAI0AAAASCAYAAABmbl0zAAAACXBIWXMAAAsSAAALEgHS3X78AAAAQElEQVRo3u3SMREAMAgAsVIpnTvj3xlogDmR8PfxftaBgSsBpsE0mAbTYBowDabBNJgG04BpMA2mwTSYBkzDXgP&#x2F;hgGnr4PpeAAAAABJRU5ErkJggg&#x3D;&#x3D;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改加载界面Logo和进度条使用图片的代码，在UnityLoader.js的2388到2399行之间。Progress方法内有两组变量，Dark和Light为加载时候使用的的各类图片数组。</p>
<ul>
<li><p><code>progressLogoUrl</code> 为加载时候的LOGO图</p>
</li>
<li><p><code>progressEmptyUrl</code> 为空的加载进度条框</p>
</li>
<li><p><code>progressFullUrl</code> 为填满的加载进度条框</p>
</li>
<li><p>这里LOGO的引用可以是base64，也可以是png图片，按照这个情况，应该可以引用svg图片，未测试。</p>
</li>
<li><p>Unity默认使用的是Dark样式的加载界面，不知道是不是和使用的Unity版本有关，我使用的是Pro版发布的。如果使用个人版，是不是就会使用Light的界面样式。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (e.Module) </span><br><span class="line">&#123;</span><br><span class="line">    var r &#x3D; UnityLoader.Progress.Styles[e.Module.splashScreenStyle],</span><br><span class="line">    n &#x3D; e.Module.progressLogoUrl ? e.Module.resolveBuildUrl(e.Module.progressLogoUrl) : r.progressLogoUrl,</span><br><span class="line">    o &#x3D; e.Module.progressEmptyUrl ? e.Module.resolveBuildUrl(e.Module.progressEmptyUrl) : r.progressEmptyUrl,</span><br><span class="line">    i &#x3D; e.Module.progressFullUrl ? e.Module.resolveBuildUrl(e.Module.progressFullUrl) : r.progressFullUrl,</span><br><span class="line">    a &#x3D; &quot;position: absolute; left: 50%; top: 50%; -webkit-transform: translate(-50%, -50%); transform: translate(-50%, -50%);&quot;;</span><br><span class="line">    e.logo || (e.logo &#x3D; document.createElement(&quot;div&quot;), e.logo.style.cssText &#x3D; a + &quot;background: url(&#39;&quot; + n + &quot;&#39;) no-repeat center &#x2F; contain; width: 154px; height: 130px;&quot;, e.container.appendChild(e.logo)),</span><br><span class="line">    e.progress || (e.progress &#x3D; document.createElement(&quot;div&quot;), e.progress.style.cssText &#x3D; a + &quot; height: 18px; width: 141px; margin-top: 90px;&quot;, e.progress.empty &#x3D; document.createElement(&quot;div&quot;), e.progress.empty.style.cssText &#x3D; &quot;background: url(&#39;&quot; + o + &quot;&#39;) no-repeat right &#x2F; cover; float: right; width: 100%; height: 100%; display: inline-block;&quot;, e.progress.appendChild(e.progress.empty), e.progress.full &#x3D; document.createElement(&quot;div&quot;), e.progress.full.style.cssText &#x3D; &quot;background: url(&#39;&quot; + i + &quot;&#39;) no-repeat left &#x2F; cover; float: left; width: 0%; height: 100%; display: inline-block;&quot;, e.progress.appendChild(e.progress.full), e.container.appendChild(e.progress)),</span><br><span class="line">    e.progress.full.style.width &#x3D; 100 * t + &quot;%&quot;,</span><br><span class="line">    e.progress.empty.style.width &#x3D; 100 * (1 - t) + &quot;%&quot;,</span><br><span class="line">    1 &#x3D;&#x3D; t &amp;&amp; (e.logo.style.display &#x3D; e.progress.style.display &#x3D; &quot;none&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遗留问题</p>
<ul>
<li>这里应该有改变背景色的属性，使用css来改背景色。未研究。</li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Unity WebGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity中C#代码规范</title>
    <url>/2024/04/17/Other/CodeGuidelines/</url>
    <content><![CDATA[<p><strong>此篇Unity中C#代码规范，是经过长期在项目中总结的一些经验和规则，公大家学习参考。</strong></p>
<h4 id="规范目的"><a href="#规范目的" class="headerlink" title="规范目的"></a>规范目的</h4><ul>
<li>一个软件的生命周期中，80%的花费在于维护；</li>
<li>几乎没有任何一个软件，在其整个生命周期中，均由最初的开发人员来维护；</li>
<li>编码规范可以改善软件的可读性，可以让程序员尽快而彻底地理解新的代码。为了执行规范，每个软件开发人员必须一致遵守编码规范；</li>
<li>使用统一编码规范的主要原因，是使应用程序的结构和编码风格标准化，以便于阅读和理解这段代码；</li>
<li>好的编码约定可使源代码严谨、可读性强且意义清楚，与其它语言约定相一致，并且尽可能的直观。</li>
<li>推荐使用字体 Noto Sans Mono CJK sc - Regular</li>
</ul>
<h4 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h4><ul>
<li>规则1 <ul>
<li>程序块要采用缩进风格编写，缩进的空格数为4个，不允许使用TAB缩进。</li>
<li>缩进使程序更易阅读，使用空格缩进可以适应不同操作系统与不同开发工具。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例</span><br><span class="line">public class PlayerData</span><br><span class="line">&#123;</span><br><span class="line">    public string playerName;</span><br><span class="line"></span><br><span class="line">    public bool playerSex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>规则2<ul>
<li>左大括号（ <code>&#123;</code> ） 应该位于声明语声明句末尾的下一行，并独占一行，右大括号（ <code>&#125;</code> ）应该代码块末尾，并独占一行，同时与引用它们的语句左对齐。在函数体的开始、类和接口的定义、以及if、for、do、while、switch、case语句中的程序或者static、synchronized等语句块中都要采用如上的缩进方式。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例</span><br><span class="line">if (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line">    DoStart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>规则3<ul>
<li>较长的语句、表达式或参数（大于80字符）要分成多行书写，长表达式要在低优先级操作符处划分新行，操作符放在新行之首，划分出的新行要进行适当的缩进，使排版整齐，语句可读。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例</span><br><span class="line">stepTimer &#x3D; Timer.Register(</span><br><span class="line">    _data.duration_Ms,</span><br><span class="line">    onComplete: () &#x3D;&gt; &#123; NextStep(); &#125;,</span><br><span class="line">    isLooped: false,</span><br><span class="line">    useRealTime: true);</span><br></pre></td></tr></table></figure>

<ul>
<li>规则4<ul>
<li>不允许把多个短语句写在一行中，即一行只写一条语句。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;错误例子</span><br><span class="line">Object o &#x3D; new Object(); Object b &#x3D; null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;正确例子</span><br><span class="line">Object o &#x3D; new Object();</span><br><span class="line">Object b &#x3D; null;</span><br></pre></td></tr></table></figure>

<ul>
<li>规则5<ul>
<li><code>if</code>、<code>for</code>、<code>do</code>、<code>while</code>、<code>case</code>、<code>switch</code>、<code>default</code>等语句自占一行，且<code>if</code>、<code>for</code>、<code>do</code>、<code>while</code>、<code>switch</code>等语句的执行语句无论多少都要加括号<code>&#123; &#125;</code>，<code>case</code>的执行语句中如果定义变量必须加括号<code>&#123; &#125;</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例</span><br><span class="line">if (a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line">    doStart();</span><br><span class="line">&#125;</span><br><span class="line">case x:</span><br><span class="line">&#123;</span><br><span class="line">    int i &#x3D; 9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>规则6<ul>
<li>相对独立的程序块之间、变量之后必须加空行。 </li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例</span><br><span class="line">if(a &gt; b)</span><br><span class="line">&#123;</span><br><span class="line">    DoStart();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;此处是空行</span><br><span class="line">return;</span><br></pre></td></tr></table></figure>

<ul>
<li>规则7<ul>
<li>在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格；进行非对等操作时，如果是关系密切的立即操作符（如<code>.</code>），后不应加空格。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例</span><br><span class="line">if (a &#x3D;&#x3D; b)</span><br><span class="line">&#123;</span><br><span class="line">    objectA.doStart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a *&#x3D; 2;</span><br></pre></td></tr></table></figure>

<ul>
<li>规则8 类属性和类方法不要交叉放置，不同存取范围的属性或者方法也尽量不要交叉放置。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例</span><br><span class="line">类定义</span><br><span class="line">&#123;</span><br><span class="line">    公有属性定义</span><br><span class="line">    保护属性定义</span><br><span class="line">    私有属性定义</span><br><span class="line">    公有方法定义</span><br><span class="line">    保护方法定义</span><br><span class="line">    私有方法定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>规则9 修饰词按照指定顺序书写：<code>[Attribute] [访问权限] [static] [final]</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例：</span><br><span class="line">[SerializeField] private static final String str &#x3D;  &quot;abc&quot;;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul>
<li><p>代码注释约定</p>
<ul>
<li>所有的方法和函数都应该以描述这段代码的功能的一段简明注释开始（方法是干什么）。这种描述不应该包括执行过程细节（它是怎么做的），因为这常常是随时间而变的，而且这种描述会导致不必要的注释维护工作，甚至成为错误的注释。代码本身和必要的嵌入注释将描述实现方法。</li>
<li>当参数的功能不明显且当过程希望参数在一个特定的范围内时，也应描述传递给过程的参数。被过程改变的函数返回值和全局变量，特别是通过引用参数的那些，也必须在每个过程的起始处描述它们。</li>
<li>注释的内容要清楚、明了，含义准确，防止注释二义性。</li>
<li>修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。</li>
<li>避免在注释中使用缩写，特别是不常用缩写。在使用缩写时或之前，应对缩写进行必要的说明。</li>
<li>不允许在一行代码或表达式的中间插入注释。</li>
<li>源程序注释量必须在30％以上。</li>
<li>由于每个文件的代码注释不一定都可以达到30%，建议以一个系统内部模块作为单位进行检查。</li>
</ul>
</li>
<li><p>规则1</p>
<ul>
<li>每个类开头必须要有以下注释，在using代码块之下。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 一句话简述</span><br><span class="line">&#x2F;&#x2F;&#x2F; 作用：（对此类的详细描述）</span><br><span class="line">&#x2F;&#x2F;&#x2F; 作者：（创建者的中文名字）</span><br><span class="line">&#x2F;&#x2F;&#x2F; 编写日期：（模块创建日期，格式：YYYY-MM-DD）</span><br><span class="line">&#x2F;&#x2F;&#x2F; 适用Unity版本：（2021.3.27f1c2 - 2022.3.3f1c1）</span><br><span class="line">&#x2F;&#x2F;&#x2F; 脚本适用平台：（Android iOS）</span><br><span class="line">&#x2F;&#x2F;&#x2F; 脚本使用注意事项：（例如：序列帧文件名称必须从0开始计数，即 图片名_0000 类似命名）</span><br><span class="line">&#x2F;&#x2F;&#x2F; TODO：（还需要完成的功能）</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>规则2</p>
<ul>
<li>每个方法开头必须要有以下注释<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 方法名称</span><br><span class="line">&#x2F;&#x2F;&#x2F; 作用：（对这个方法的作用进行简单描述，包括所有参数的简单描述）</span><br><span class="line">&#x2F;&#x2F;&#x2F; 作者：（方法创建者的中文名字）</span><br><span class="line">&#x2F;&#x2F;&#x2F; 编写日期：（方法创建日期，格式：YYYY-MM-DD）</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;_str1&quot;&gt;参数_str1的详细说明&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;_str2&quot;&gt;参数_str2的详细说明&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;returns&gt;返回值说明&lt;&#x2F;returns&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;exception&gt;异常说明&lt;&#x2F;exception&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;remarks&gt; </span><br><span class="line">&#x2F;&#x2F;&#x2F; 该方法详细文字说明</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;remarks&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;example&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;code&gt;调用此方法的代码示例&lt;&#x2F;code&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;example&gt;</span><br><span class="line">public  int TestClass(string _str1, string _str2)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>规则3</p>
<ul>
<li>其他人对代码做出修改后，要在“作者”一行中加入自己的名字(方法或类都是如此)。</li>
<li>在“作用”一行的详细描述中，可以使用<code>@since YYYY-MM-DD</code>形式来表示从哪个日期开始，做出了什么样的修改，或添加了什么新的功能。</li>
<li>在“作用”一行的详细描述中，可以使用<code>@deprecated YYYY-MM-DD</code>形式来表示从哪个日期开始，弃用了哪些功能。</li>
<li>使用<code>@see 类名/方法名</code>形式来表示相关的类或者方法</li>
<li>使用<code>@Override</code>来表示重载父类的方法，并对重载进行文字说明</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 方法名称</span><br><span class="line">&#x2F;&#x2F;&#x2F; 作用：@since 2023-05-15 添加了对AB包进行二次加密和解密的功能</span><br><span class="line">&#x2F;&#x2F;&#x2F;       @deprecated 2023-05-17 弃用了之前过于简单的加密方式</span><br><span class="line">&#x2F;&#x2F;&#x2F;       @Override 对ResetCharacter方法进行的重载，这里是重置新添加的中立生物的状态</span><br><span class="line">&#x2F;&#x2F;&#x2F; 作者：（方法创建者的中文名字）</span><br><span class="line">&#x2F;&#x2F;&#x2F; 编写日期：（方法创建日期，格式：YYYY-MM-DD）</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; ……</span><br></pre></td></tr></table></figure>

<ul>
<li><p>规则4</p>
<ul>
<li>类和方法中声明的变量、属性、字段，其上一行均要有<code>//</code>形式的注释说明。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例：</span><br><span class="line">&#x2F;&#x2F;说明这个变量的具体作用</span><br><span class="line">[SerializeField] private static final String str &#x3D;  &quot;abc&quot;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>规则5</p>
<ul>
<li>在代码的功能、意图层次上进行注释，提供有用、额外的信息。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例</span><br><span class="line">&#x2F;&#x2F;如下注释意义不大。</span><br><span class="line">&#x2F;&#x2F; 如果 receiveFlag 为真</span><br><span class="line">if (receiveFlag)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;而如下的注释则给出了额外有用的信息。</span><br><span class="line">&#x2F;&#x2F; 如果从连结收到消息 </span><br><span class="line">if (receiveFlag)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>规则6</p>
<ul>
<li>对关键变量的定义和分支语句（条件分支、循环语句等）必须编写注释。</li>
<li>这些语句往往是程序实现某一特定功能的关键，对于维护人员来说，良好的注释帮助更好的理解程序，有时甚至优于看设计文档。</li>
</ul>
</li>
<li><p>规则7</p>
<ul>
<li>注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达。中文注释中需使用中文标点。方法和类描述的第一句话尽量使用简洁明了的话概括一下功能，然后加以句号。接下来的部分可以详细描述。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><ul>
<li>规则1<ul>
<li>类、接口、变量、函数等正确的命名以及合理地组织代码的结构，使代码成为自注释的，清晰准确的命名，可增加代码可读性，并减少不必要的注释。</li>
<li>类名、方法名、枚举名使用意义完整的英文描述，并使用大驼峰命名法(Pascal)。</li>
<li>接口名开头使用大写英文字母<code>I</code>，加意义完整的英文描述，并使用大驼峰命名法(Pascal)。</li>
<li>变量、字段使用小驼峰命名法 (Camel)。</li>
<li>局部变量、方法入参使用小驼峰命名法 (Camel)，并且变量名前要加英文半角下划线 （<code>_</code>）。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例</span><br><span class="line">public class PlayerData</span><br><span class="line">&#123;</span><br><span class="line">    private string playerName;</span><br><span class="line"></span><br><span class="line">    public void InitPlayer(string _playerName)</span><br><span class="line">    &#123;</span><br><span class="line">        playerName &#x3D; _playerName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>规则2<ul>
<li>存取属性的方法采用setter 和 getter方法，动作方法采用动词和动宾结构。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;格式：</span><br><span class="line">&#x2F;&#x2F;get + 非布尔属性名()</span><br><span class="line">&#x2F;&#x2F;is + 布尔属性名()</span><br><span class="line">&#x2F;&#x2F;set + 属性名()</span><br><span class="line">&#x2F;&#x2F;动词()</span><br><span class="line">&#x2F;&#x2F;动词 + 宾语()</span><br><span class="line">&#x2F;&#x2F;示例：</span><br><span class="line">public String getType();</span><br><span class="line">public boolean isFinished();</span><br><span class="line">public void setVisible(boolean);</span><br><span class="line">public void show();</span><br><span class="line">public void addKeyListener(Listener);</span><br></pre></td></tr></table></figure>

<ul>
<li>规则3<ul>
<li>属性名使用意义完整的英文命名，其访问器使用小写名称并在前面加英文半角下划线 （<code>_</code>）。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例</span><br><span class="line">public string CharacterName</span><br><span class="line">&#123;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        return _characterName;</span><br><span class="line">    &#125;</span><br><span class="line">    set</span><br><span class="line">    &#123;</span><br><span class="line">        _characterName &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>规则4<ul>
<li>常量名使用全大写的英文描述，英文单词之间用下划线分隔开，并且使用 static final修饰。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例： </span><br><span class="line">public static final int MAX_VALUE &#x3D; 1000;</span><br><span class="line">public static final String DEFAULT_START_DATE &#x3D; &quot;2001-12-08&quot;;</span><br></pre></td></tr></table></figure>

<ul>
<li>规则5<ul>
<li>如果函数名超过15个字母，可采用以去掉元音字母的方法或者以行业内约定俗成的缩写方式缩写函数名。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例：</span><br><span class="line">getCustomerInformation()  改为  getCustomerInfo()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>规则6</p>
<ul>
<li>namespace的命名，应按照功能范围划分并命名，防止产生冲突。</li>
<li>部门内部产品使用“部门名称 + 模块名称”的方式命名。</li>
<li>上线产品使用“产品名称 + 模块名称”的方式命名。</li>
</ul>
</li>
<li><p>规则7</p>
<ul>
<li>准确的使用访问修饰符。</li>
<li>不允许有类似标记为<code>public</code>的属性、变量等，只在该类内部进行访问的现象。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>调用方的位置</th>
<th align="center">public</th>
<th align="center">protected internal</th>
<th align="center">protected</th>
<th align="center">internal</th>
<th align="center">private protected</th>
<th align="center">private</th>
</tr>
</thead>
<tbody><tr>
<td>在类内</td>
<td align="center">✔️️</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
</tr>
<tr>
<td>派生类（相同程序集）</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="center">❌</td>
</tr>
<tr>
<td>非派生类（相同程序集）</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="center">❌</td>
<td align="center">✔️</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td>派生类（不同程序集）</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="center">✔️</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
<tr>
<td>非派生类（不同程序集）</td>
<td align="center">✔️</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
<td align="center">❌</td>
</tr>
</tbody></table>
<ul>
<li>规则8<ul>
<li>建议2    含有集合意义的属性命名，尽量包含其复数的意义。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例：</span><br><span class="line">public List&lt;GameObject&gt; characters;</span><br><span class="line">public GameObject[] orderItems;</span><br></pre></td></tr></table></figure>

<ul>
<li>规则8<ul>
<li>1到3个字母缩写的单词，用全大写字母，大于3个字母的缩写单词，用大驼峰命名法</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;示例：</span><br><span class="line">public string IOHelper;</span><br><span class="line">public string HttpClient;</span><br></pre></td></tr></table></figure>

<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><ul>
<li>规则1<ul>
<li>一个文件不要定义两个类(并非指内部类)，方便程序的阅读与代码的维护。</li>
</ul>
</li>
</ul>
<h4 id="Git-SVN提交规范"><a href="#Git-SVN提交规范" class="headerlink" title="Git/SVN提交规范"></a>Git/SVN提交规范</h4><ul>
<li><p>提交模板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[类型] 类型关键字</span><br><span class="line">[标题] 此次提交是进行哪些改动简述</span><br><span class="line">[描述] 对此次提交进行详细的文字描述</span><br><span class="line">[Bug修复情况] 此行为可选填，下面会说明如何填写</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交类型，在提交更改时，第一行要写的关键字，可以较快的辨别该提交是那种类型的</p>
</li>
<li><p>提交类型可以有多个，例如一个修复BUG是修改了FBX模型，那么[类型]就是<code>Fix Art3D_Model</code>，两个类型之间用英文半角空格进行间隔</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Settings</td>
<td>对项目配置进行了改变️</td>
</tr>
<tr>
<td>Docs</td>
<td>对文档进行了修改</td>
</tr>
<tr>
<td>Feat</td>
<td>加了新的功能</td>
</tr>
<tr>
<td>Fix</td>
<td>修复了BUG</td>
</tr>
<tr>
<td>Art_UI</td>
<td>对UI素材进行了修改</td>
</tr>
<tr>
<td>Art2D_Sprite</td>
<td>对2D精灵类型的素材进行了修改</td>
</tr>
<tr>
<td>Art3D_Model</td>
<td>对3D类型是美术文件进行了修改，包括FBX模型、动作、材质以及模型对应的贴图，要在描述中进行详细说明</td>
</tr>
<tr>
<td>Scene</td>
<td>对场景文件进行了修改</td>
</tr>
<tr>
<td>Refactor</td>
<td>既不是修复bug也不是添加特征的代码重构</td>
</tr>
<tr>
<td>Pref</td>
<td>提高性能的更改，包括代码、各类美术素材设置、项目设置等，要在描述中进行详细说明</td>
</tr>
<tr>
<td>Revert</td>
<td>回滚，要写明回滚到哪个提交节点上，以及原因</td>
</tr>
</tbody></table>
<ul>
<li><p>BUG修复情况说明，如果此次提交为修复BUG，要写明之前的BUG是什么样子的，例如网络访问错误还是人物操作抖动等，如果是修改issue的话，要引用该issue</p>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[类型] Fix Art3D_Model</span><br><span class="line">[标题] 修复了男性3号NPC在挥手时抖动的问题</span><br><span class="line">[描述] 男性3号NPC在挥手时抖动，是因为模型导出时连带的动画文件关键帧平滑有问题，已查明是blender的问题，使用maya重新导出，并在unity中进行了对应的动画压缩和代码调整</span><br><span class="line">[Bug修复情况]已经修复了男性3号NPC在挥手时抖动的问题 issue #1234</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><blockquote>
<p><a href="https://learn.microsoft.com/zh-cn/dotnet/standard/design-guidelines/naming-guidelines">命名准则（微软）</a></p>
</blockquote>
<blockquote>
<p><a href="https://google.github.io/styleguide/csharp-style.html">代码风格（谷歌）</a></p>
</blockquote>
<blockquote>
<p><a href="https://book.douban.com/subject/10797189/">《编写可读代码的艺术》</a></p>
</blockquote>
<blockquote>
<p><a href="https://book.douban.com/subject/30223371/">《Effective C#》</a></p>
</blockquote>
<blockquote>
<p><a href="https://book.douban.com/subject/6849791/">《编写高质量代码 改善C#程序的157个建议》</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Unity 3D</category>
      </categories>
      <tags>
        <tag>Unity 3D</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity HDRP Visual Environment</title>
    <url>/2019/06/24/Unity3D/Unity3D_HDRP_VisualEnvironment/</url>
    <content><![CDATA[<p>#Visual Environment</p>
<blockquote>
<p><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@6.7/manual/Override-Visual-Environment.html">官方文档</a></p>
</blockquote>
<p><img src="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@6.7/manual/Images/Override-VisualEnvironment1.png" alt="image"></p>
<p>该模块主要控制天空和与雾效。</p>
<ul>
<li>Type：天空盒类型<ul>
<li><strong>None：</strong> 不使用天空盒，Camera在当前Volume中的时候，使用纯色。</li>
<li><strong>Gradient Sky：</strong> 使用梯度天空盒。</li>
<li><strong>HDRI Sky：</strong> 使用cubemap类型的HDRI图片作为天空盒。</li>
<li><strong>Procedural Sky：</strong>  参数话天空盒，可以控制地面颜色，天空色调，太阳尺寸等。</li>
</ul>
</li>
<li>Ambient Mode：环境光(ambient light)的模式。<ul>
<li><strong>Static：</strong> 环境光照来自于烘焙的环境光</li>
<li><strong>Dynamic：</strong> 环境光来自当前使用的天空盒。这意味着，当前摄像机所在的Volume中，环境光可以实时变化。如果使用烘焙全局照明(baked global illumination)[2]，改变环境光照只会影响被环境探针(Ambient Probes)覆盖的物体[3]。<br>如果在Lighting Settings面板中勾选了实时环境光照(real-time global illumination)，改变环境光照将会同时影响静态物体和环境探针(Ambient Probes)所覆盖的物体。  <a id="more"></a>
[1] 当 Ambient Mode 选择 Static 时，需要在当前物体上添加“<a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@6.7/manual/Static-Lighting-Sky.html">Static Lighting Sky</a>”组件，该组件引用当前Volume使用的配置文件，并指定当前使用哪个天空盒。烘焙完成后，静态游戏物体会使用烘焙时的环境光照，此时环境光改变的话，静态游戏物体不会随之变化。<br>[2] baked global illumination是在Lighting Settings面板面板中勾选Baked Global Illumination。<br>[3] Ambient Probes尚不明确，Unity文档中通篇未找到关于这个东西的详细描述，在API文档中也只是寥寥几句。个人感觉好像是Light Probes。</li>
</ul>
</li>
</ul>
<p>PS：每种天空盒组件可以独立添加，根据“Type”属性来确定使用哪种天空盒。</p>
<hr>
<h4 id="Fog"><a href="#Fog" class="headerlink" title="Fog"></a>Fog</h4><ul>
<li>Type： 雾效类型<ul>
<li><strong>None：</strong> 在当前Volume中不使用任何雾效。</li>
<li><strong>Linear Fog：</strong> 线性雾效，产生的雾效距离Camera越远，密度会成线性变大。</li>
<li><strong>Exponential Fog：</strong> 指数型雾效，产生的雾效距离Camera越远，密度会成指数级变大。[1]</li>
<li><strong>Volumetric Fog：</strong> 体积雾，体积雾会与真实光照产生交互，能产生真实的物理渲染效果。[2]</li>
</ul>
</li>
</ul>
<p>[1] 指数雾效 和 线性雾效相同点是都随着距离Camera越远变得越浓密，而感觉指数雾效会变化的比线性雾效更加快。<br>[2] 感觉类似体积雾的效果，光线穿过后就会有体积光的效果。</p>
]]></content>
      <categories>
        <category>Unity 3D</category>
      </categories>
      <tags>
        <tag>Unity 3D</tag>
        <tag>Render</tag>
        <tag>HDRP</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity HDRP Volume</title>
    <url>/2019/05/07/Unity3D/Unity_HDRP_Volume/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@6.7/manual/Volumes.html">官方文档</a></p>
</blockquote>
<h3 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h3><p><img src="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@6.7/manual/Images/Volumes1.png" alt="image"></p>
<ul>
<li>Is Global：勾选后Volume变为全局形式，影响整个场景。[1]</li>
<li>Blend Distance：当Is Global未勾选时会显示此项。可以设置一个混合区域，该区域为从一个Volume到当前Volum时，各项数值渐变的一个区域。[2]</li>
<li>Weight：混合程度，Camera进入到当前区域后，最终的混合结果。[3]</li>
<li>Priority：当两个Volume重叠时，根据此项判断当前使用哪一个Volume的配置。该项数值越大，越会被优先使用。</li>
<li>Profile：使用Volume配置文件，点击“New”新建一个配置文件。</li>
</ul>
<p>[1] 当Is Global未勾选时，需要在当前Volume所在物体上挂载Box Collider组件，并且勾选Box Collider组件的Is Trigger。<br>[2] 混合区域是从Collider外侧边缘开始计算。例如Collider为4，Blend Distance为5，混合区域位置就是4到9。<br>[3] 混合程度是 摄像机距离和混合距离 运算结果后，再乘以混合程度数值最终所得的结果。例如，当前Volume区域设置亮度为100，混合程度为0.5，在该Volume中最终亮度为50，当进入混合区域时，所有渐变的数值也会乘以0.5。</p>
]]></content>
      <categories>
        <category>Unity 3D</category>
      </categories>
      <tags>
        <tag>Unity 3D</tag>
        <tag>Render</tag>
        <tag>HDRP</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Compute Shader - 1 第一个Compute Shader</title>
    <url>/2022/03/13/Unity3D/ComputeShader/Compute_Shader_1/</url>
    <content><![CDATA[<p>创建第一个Compute Shader时，需要先做一些准备工作：</p>
<ol>
<li>创建一个Unity Built-in项目</li>
<li>在场景中创建一个Quad，设置其位置和旋转均为0</li>
<li>选中场景中的Main Camera，设置其位置为<code>Vector3(0,0,-1)</code></li>
<li>设置Main Camera的<code>Projection</code>属性为<code>Orthographic</code></li>
<li>调整Main Camera的<code>Size</code>属性值为0.5</li>
<li>创建一个材质球，材质球的shader使用<code>Unlit/Texture</code></li>
<li>创建一个C#脚本，名称为<code>AssignTexture</code></li>
<li>C#脚本内容如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class AssignTexture : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;引用已经完成的ComputeShader，用于计算图片</span><br><span class="line">    public ComputeShader shader;</span><br><span class="line">    &#x2F;&#x2F;生成图片的分辨率</span><br><span class="line">    public int texResolution &#x3D; 256;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Quad上的MeshRenderer组件</span><br><span class="line">    public MeshRenderer meshRend;</span><br><span class="line">    &#x2F;&#x2F;经过ComputeShader计算生成的图片</span><br><span class="line">    private RenderTexture outputTexture;</span><br><span class="line">    &#x2F;&#x2F;保存获取到的ComputeShader内核索引</span><br><span class="line">    private int KernelHandle;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;获取Quad上的MeshRenderer组件</span><br><span class="line">        meshRend &#x3D; gameObject.GetComponent&lt;MeshRenderer&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;设置生成图片的大小</span><br><span class="line">        outputTexture &#x3D; new RenderTexture(texResolution, texResolution, 0);</span><br><span class="line">        &#x2F;&#x2F;创建的图片打开可读写</span><br><span class="line">        outputTexture.enableRandomWrite &#x3D; true;</span><br><span class="line">        outputTexture.Create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建一个Compute Shader，名称为<code>FirstComputeShader</code></li>
<li>将AssignTexture脚本挂载到Quad物体上，并将FirstComputeShader拖动到AssignTexture脚本的<code>Shader</code>变量栏中</li>
</ol>
<p>准备工作完成后，继续在<code>AssignTexture</code>脚本中添加代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class AssignTexture : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        InitShader();</span><br><span class="line"></span><br><span class="line">        DispatchShader(texResolution &#x2F; 16, texResolution &#x2F; 16);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void InitShader()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;获取内核名称为CSMain的索引值</span><br><span class="line">        KernelHandle &#x3D; shader.FindKernel(&quot;CSMain&quot;);</span><br><span class="line">        &#x2F;&#x2F;将outputTexture发送给内核索引值为KernelHandle的cpmpute shader中的变量Result</span><br><span class="line">        &#x2F;&#x2F;这句代码是在cpmpute shader中的Result变量来计算outputTexture</span><br><span class="line">        shader.SetTexture(KernelHandle, &quot;Result&quot;, outputTexture);</span><br><span class="line">        &#x2F;&#x2F;为Quad的材质赋值贴图，也就是计算后的outputTexture</span><br><span class="line">        meshRend.material.SetTexture(&quot;_MainTex&quot;, outputTexture);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void DispatchShader(int _x, int _y)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;运行指定的cpmpute shader，在x,y,z上启动指定数量的计算着色器线程组</span><br><span class="line">        shader.Dispatch(KernelHandle, _x, _y, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        if (Input.GetKeyUp(KeyCode.A))</span><br><span class="line">        &#123; </span><br><span class="line">            DispatchShader(texResolution &#x2F; 8, texResolution &#x2F;8 );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们就完成了第一个Compute Shader，在Unity中运行当前场景，可以看到Quad显示出了一个奇怪的图形：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_1_Pic1.png?raw=true"></p>
<p>这时按下键盘<code>A</code>键后，图片会发生变化，如下：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_1_Pic2.png?raw=true"></p>
<p>为什么会发生这样的情况？Compute Shader脚本中发生了什么？下一章中继续探索</p>
<hr>
<h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><blockquote>
<p><a href="https://docs.unity.cn/cn/2023.2/ScriptReference/RenderTexture-depth.html">RenderTexture.Depth</a></p>
</blockquote>
<blockquote>
<p><a href="https://docs.unity.cn/cn/2023.2/ScriptReference/ComputeShader.Dispatch.html">ComputeShader.Dispatch</a></p>
</blockquote>
<blockquote>
<p><a href="https://docs.unity.cn/ScriptReference/ComputeShader.FindKernel.html">ComputeShader.FindKernel</a></p>
</blockquote>
<blockquote>
<p><a href="https://docs.unity.cn/ScriptReference/ComputeShader.Dispatch.html">ComputeShader.Dispatch</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Unity 3D</category>
      </categories>
      <tags>
        <tag>Unity 3D</tag>
        <tag>Render</tag>
        <tag>Compute Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Compute Shader - 2 脚本回顾</title>
    <url>/2022/03/15/Unity3D/ComputeShader/Compute_Shader_2/</url>
    <content><![CDATA[<p>在上一章中，我们使用Compute Shader生成了一个图片，并且让这张图片显示在了Quad上，这张图看起来很奇怪，这种图形的名字是<a href="https://baike.baidu.com/item/%E8%B0%A2%E5%B0%94%E5%AE%BE%E6%96%AF%E5%9F%BA%E4%B8%89%E8%A7%92%E5%BD%A2/1332191">谢尔宾斯基三角形</a></p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_1_Pic1.png?raw=true"></p>
<p>Compute Shader所用的语言是HLSL(High Level Shader Language)，其语法和C比较相似。</p>
<p>我们打开之前创建的<code>FirstComputeShader</code>脚本，内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Each #kernel tells which function to compile; you can have many kernels</span><br><span class="line">#pragma kernel CSMain</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Create a RenderTexture with enableRandomWrite flag and set it</span><br><span class="line">&#x2F;&#x2F; with cs.SetTexture</span><br><span class="line">RWTexture2D&lt;float4&gt; Result;</span><br><span class="line"></span><br><span class="line">[numthreads(8,8,1)]</span><br><span class="line">void CSMain (uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; TODO: insert actual code here!</span><br><span class="line"></span><br><span class="line">    Result[id.xy] &#x3D; float4(id.x &amp; id.y, (id.x &amp; 15)&#x2F;15.0, (id.y &amp; 15)&#x2F;15.0, 0.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先看第一行 <code>#pragma kernel CSMain</code>，其中 <code>CSMain</code> 表示当前的内核名称。通过C#脚本中的 <code>ComputeShader.FindKernel(string kernekName)</code>就可以获得这个内核的索引，方便后续调用。也就是之前C#脚本中的 <code>ComputeShader.Dispatch</code><br>Compute Shader中声明每一个kernel，前面都需要家关键字 <code>#pragma</code><br>在当前内核中，运算入口函数名称要和频道名称相同，也就是 <code>void CSMain</code></p>
<p>在声明 <code>void CSMain</code> 函数上方还有一行代码 <code>[numthreads(8,8,1)]</code>，这是一个着色器编译指令，用于指定每个线程组的线程数量。这个指令放在着色器入口函数CSMain的前面，用来告诉编译器和运行时环境，当CSMain函数被调用时，应该以多少线程来组织线程组。当前这个指令表示8个线程在X维度，8个线程在Y维度，以及1个线程在Z维度。因此，当前线程组总共有 X<em>Y</em>Z(8×8×1=64) 个线程<br>X，Y，Z三个值也并不是也可随便乱填的。它们在不同的版本里有如下的约束：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Compute Shader</td>
<td align="center">Maximum Z</td>
<td align="center">Maximum Threads (X<em>Y</em>Z)</td>
</tr>
<tr>
<td align="center">cs_4_x</td>
<td align="center">1</td>
<td align="center">768</td>
</tr>
<tr>
<td align="center">cs_5_0</td>
<td align="center">64</td>
<td align="center">1024</td>
</tr>
</tbody></table>
<p>在Compute Shader中，线程组的每个线程都会执行CSMain函数，并且每个线程都会接收到它自己的id。线程可以使用这个id来计算它应该处理的数据，或者访问全局内存中正确的位置。</p>
<p>在Direct11中，可以通过ID3D11DeviceContext::Dispatch(X,Y,Z)方法创建X<em>Y</em>Z个线程组，一个线程组里又会包含多个线程(数量即numthreads定义)。注意顺序，先numthreads定义好每个核函数对应线程组里线程的数量，再用Dispatch定义用多少线程组来处理这个核函数。其中每个线程组内的线程都是并行的，不同线程组的线程可能同时执行，也可能不同时执行。一般一个GPU同时执行的线程数，在1000-10000之间。</p>
<p>接下来我们看核函数 <code>void CSMain (uint3 id : SV_DispatchThreadID)</code></p>
<ul>
<li><code>uint3 id</code> 表示一个包含三个分量（x、y、z）的无符号整数向量，代表当前线程在线程组中的索引位置。Compute Shader中的线程是按组（group）组织的，每个线程组可以有多个线程，线程组又可以组成更大的网格（grid）。id向量指定了线程在其线程组内的相对位置。</li>
<li><code>SV_DispatchThreadID</code> 这是参数的语义，SV_DispatchThreadID是一个系统值语义 (System Value Semantic)，在这里我们将其他相关语义一同讲解<ul>
<li>SV_GroupID：线程组的ID，其实就是一个int3的值，如果我们线程组定义为(X,Y,Z)，那么SV_GroupID的取值范围即为(0,0,0)到(X-1,Y-1,Z-1)。</li>
<li>SV_GroupThreadID：线程组内的某个线程的ID，同样是一个int3的值。它不考虑与线程组的关系，例如不同线程组里的第一个线程的SV_GroupThreadID都是(0,0,0)。</li>
<li>SV_DispatchThreadID：所有线程组中的某个线程ID，也是一个int3的值。它和SV_GroupThreadID就不一样了，需要考虑线程组，例如我一个线程组有(X,Y,Z)个线程，那么SV_GroupID=(a,b,c)的线程组里的SV_GroupThreadID=(i,j,k)的线程的SV_DispatchThreadID为 <code>(a*X+i, b*Y+j, c*Z+k)</code>。</li>
<li>SV_GroupIndex：线程组内的某个线程的下标，是一个int值。例如我一个线程组有(X,Y,Z)个线程，其中第一个线程(0,0,0)的下标为0，下标增长的顺序是从左往右(x)，然后从上往下(y)，最后从前往后(z)，例如：(1,0,0)=1，(1,0,0)=2，…,(0,1,0)=X，…，(0,0,1)=X*Y，… 因此可以得到如下公式 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SV_GroupIndex &#x3D; SV_GroupThreadID.z*X*Y + SV_GroupThreadID.y*X + SV_GroupThreadID.x</span><br></pre></td></tr></table></figure>
为了更好理解，下图计算示例如下：</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_2_Pic5.png?raw=true"></p>
<p>除了 <code>SV_DispatchThreadID</code> 以外，我们刚才介绍的参数都可以加入核函数的参数中，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void KernelFunction(uint3 groupId : SV_GroupID,</span><br><span class="line">    uint3 groupThreadId : SV_GroupThreadID,</span><br><span class="line">    uint3 dispatchThreadId : SV_DispatchThreadID,</span><br><span class="line">    uint groupIndex : SV_GroupIndex)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着是变量部分，这里只有一个变量 <code>RWTexture2D&lt;float4&gt; Result;</code></p>
<ul>
<li><code>RWTexture2D</code> 表示这是一个可读写（Read-Write）的二维纹理。与只读纹理不同，可读写纹理允许Compute Shader在其中存储数据，这在进行图像处理或其他需要输出结果到纹理的操作时非常有用</li>
<li><code>&lt;float4&gt;</code> 指定了纹理存储的数据类型。float4 是一个包含四个浮点数的向量，通常用于表示颜色（RGBA）或向量数据。在纹理中，每个像素将存储一个 float4 类型的值</li>
<li><code>Result</code> 这是变量的名称，Compute Shader中使用这个变量来访问纹理。</li>
</ul>
<p>最后是函数体部分，这里只有一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Result[id.xy] &#x3D; float4(id.x &amp; id.y, (id.x &amp; 15)&#x2F;15.0, (id.y &amp; 15)&#x2F;15.0, 0.0);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>id.xy</code> 这里使用id.xy获取了线程在其线程组内的二维索引位置，即线程在X和Y维度上的位置</li>
<li><code>Result[id.xy]</code> 通过使用id.xy作为索引，访问Result纹理对应位置的像素</li>
<li><code>id.x &amp; id.y</code> 这是一个位运算,表达式将id.x和id.y的值进行位与操作，所得结果为当前像素中R通道的值</li>
<li><code>(id.x &amp; 15)/15.0</code> 和 <code>(id.y &amp; 15)/15.0</code> 分别对线程的x和y坐标与15（二进制为00001111）进行按位与操作，然后除以15.0。这个操作将坐标值限制在一个更小的范围内（0到15），并映射到0到1的浮点数范围内，分别用于G和B通道的值</li>
<li><code>0.0</code> 这是RGBA中的Alpha（透明度）通道，这里设置为0.0表示完全透明。</li>
</ul>
<p>不要太在意这段代码是如何计算的，只需要知道通过X和Y的值计算出了每个想的RGB值，最终结果为一个谢尔宾斯基三角形的样子<br>现在我们将这个函数内的代码改成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Result[id.xy] &#x3D; float4(1,0,0,0);</span><br></pre></td></tr></table></figure>
<p>这时候运行unity，我们会得到一张红色的贴图</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_2_Pic1.png?raw=true"></p>
<p>现在我们可能注意到一个问题，在C#代码中，我们调用了两次 <code>DispatchShader</code> 方法，在Start中的参数是 <code>(texResolution / 16, texResolution / 16)</code>，而在Update中的是<code>(texResolution / 8, texResolution / 8)</code>，第一个调用时，生成的图片只占整个图片的四分之一，第二次调用时，生成的图片是全铺满的。这里就涉及到Compute Shader中 <code>[numthreads(8,8,1)]</code> 与 <code>ComputeShader.Dispatch</code>参数的问题了</p>
<p>首先我们看<code>[numthreads(8,8,1)]</code>的参数，这个如下表所示，其中横向为X坐标，纵向为Y坐标<br>当GroupID为(0,0,0)时，我们所操作的图片中像素坐标为</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>0,7,0</td>
<td>1,7,0</td>
<td>2,7,0</td>
<td>3,7,0</td>
<td>4,7,0</td>
<td>5,7,0</td>
<td>6,7,0</td>
<td>7,7,0</td>
</tr>
<tr>
<td>0,6,0</td>
<td>1,6,0</td>
<td>2,6,0</td>
<td>3,6,0</td>
<td>4,6,0</td>
<td>5,6,0</td>
<td>6,6,0</td>
<td>7,6,0</td>
</tr>
<tr>
<td>0,5,0</td>
<td>1,5,0</td>
<td>2,5,0</td>
<td>3,5,0</td>
<td>4,5,0</td>
<td>5,5,0</td>
<td>6,5,0</td>
<td>7,5,0</td>
</tr>
<tr>
<td>0,4,0</td>
<td>1,4,0</td>
<td>2,4,0</td>
<td>3,4,0</td>
<td>4,4,0</td>
<td>5,4,0</td>
<td>6,4,0</td>
<td>7,4,0</td>
</tr>
<tr>
<td>0,3,0</td>
<td>1,3,0</td>
<td>2,3,0</td>
<td>3,3,0</td>
<td>4,3,0</td>
<td>5,3,0</td>
<td>6,3,0</td>
<td>7,3,0</td>
</tr>
<tr>
<td>0,2,0</td>
<td>1,2,0</td>
<td>2,2,0</td>
<td>3,2,0</td>
<td>4,2,0</td>
<td>5,2,0</td>
<td>6,2,0</td>
<td>7,2,0</td>
</tr>
<tr>
<td>0,1,0</td>
<td>1,1,0</td>
<td>2,1,0</td>
<td>3,1,0</td>
<td>4,1,0</td>
<td>5,1,0</td>
<td>6,1,0</td>
<td>7,1,0</td>
</tr>
<tr>
<td>0,0,0</td>
<td>1,0,0</td>
<td>2,0,0</td>
<td>3,0,0</td>
<td>4,0,0</td>
<td>5,0,0</td>
<td>6,0,0</td>
<td>7,0,0</td>
</tr>
</tbody></table>
<p>这样，8x8个线程就在一张图的左下角第一个像素开始，生成了一个8x8像素的红色区域</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_2_Pic2.png?raw=true"></p>
<p>接着GroupID为(1,0,0)时，我们所操作的图片中像素坐标变成了如下表格</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>8,7,0</td>
<td>9,7,0</td>
<td>10,7,0</td>
<td>11,7,0</td>
<td>12,7,0</td>
<td>13,7,0</td>
<td>14,7,0</td>
<td>15,7,0</td>
</tr>
<tr>
<td>8,6,0</td>
<td>9,6,0</td>
<td>10,6,0</td>
<td>11,6,0</td>
<td>12,6,0</td>
<td>13,6,0</td>
<td>14,6,0</td>
<td>15,6,0</td>
</tr>
<tr>
<td>8,5,0</td>
<td>9,5,0</td>
<td>10,5,0</td>
<td>11,5,0</td>
<td>12,5,0</td>
<td>13,5,0</td>
<td>14,5,0</td>
<td>15,5,0</td>
</tr>
<tr>
<td>8,4,0</td>
<td>9,4,0</td>
<td>10,4,0</td>
<td>11,4,0</td>
<td>12,4,0</td>
<td>13,4,0</td>
<td>14,4,0</td>
<td>15,4,0</td>
</tr>
<tr>
<td>8,3,0</td>
<td>9,3,0</td>
<td>10,3,0</td>
<td>11,3,0</td>
<td>12,3,0</td>
<td>13,3,0</td>
<td>14,3,0</td>
<td>15,3,0</td>
</tr>
<tr>
<td>8,2,0</td>
<td>9,2,0</td>
<td>10,2,0</td>
<td>11,2,0</td>
<td>12,2,0</td>
<td>13,2,0</td>
<td>14,2,0</td>
<td>15,2,0</td>
</tr>
<tr>
<td>8,1,0</td>
<td>9,1,0</td>
<td>10,1,0</td>
<td>11,1,0</td>
<td>12,1,0</td>
<td>13,1,0</td>
<td>14,1,0</td>
<td>15,1,0</td>
</tr>
<tr>
<td>8,0,0</td>
<td>9,0,0</td>
<td>10,0,0</td>
<td>11,0,0</td>
<td>12,0,0</td>
<td>13,0,0</td>
<td>14,0,0</td>
<td>15,0,0</td>
</tr>
</tbody></table>
<p>也就是绘制了从左下角开始横向8到15像素，纵向0到7像素的一个红色区域</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_2_Pic3.png?raw=true"></p>
<p>当GroupID为(0,1,0)时，我们所操作的图片中像素坐标变成了如下表格</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>0,15,0</td>
<td>1,15,0</td>
<td>2,15,0</td>
<td>3,15,0</td>
<td>4,15,0</td>
<td>5,15,0</td>
<td>6,15,0</td>
<td>7,15,0</td>
</tr>
<tr>
<td>0,14,0</td>
<td>1,14,0</td>
<td>2,14,0</td>
<td>3,14,0</td>
<td>4,14,0</td>
<td>5,14,0</td>
<td>6,14,0</td>
<td>7,14,0</td>
</tr>
<tr>
<td>0,13,0</td>
<td>1,13,0</td>
<td>2,13,0</td>
<td>3,13,0</td>
<td>4,13,0</td>
<td>5,13,0</td>
<td>6,13,0</td>
<td>7,13,0</td>
</tr>
<tr>
<td>0,12,0</td>
<td>1,12,0</td>
<td>2,12,0</td>
<td>3,12,0</td>
<td>4,12,0</td>
<td>5,12,0</td>
<td>6,12,0</td>
<td>7,12,0</td>
</tr>
<tr>
<td>0,11,0</td>
<td>1,11,0</td>
<td>2,11,0</td>
<td>3,11,0</td>
<td>4,11,0</td>
<td>5,11,0</td>
<td>6,11,0</td>
<td>7,11,0</td>
</tr>
<tr>
<td>0,10,0</td>
<td>1,10,0</td>
<td>2,10,0</td>
<td>3,10,0</td>
<td>4,10,0</td>
<td>5,10,0</td>
<td>6,10,0</td>
<td>7,10,0</td>
</tr>
<tr>
<td>0,9,0</td>
<td>1,9,0</td>
<td>2,9,0</td>
<td>3,9,0</td>
<td>4,9,0</td>
<td>5,9,0</td>
<td>6,9,0</td>
<td>7,9,0</td>
</tr>
<tr>
<td>0,8,0</td>
<td>1,8,0</td>
<td>2,8,0</td>
<td>3,8,0</td>
<td>4,8,0</td>
<td>5,8,0</td>
<td>6,8,0</td>
<td>7,8,0</td>
</tr>
</tbody></table>
<p>这样就绘制了从左下角开始横向0到7像素，纵向8到15像素的一个红色区域</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_2_Pic4.png?raw=true"></p>
<p><code>[numthreads(8,8,1)]</code> 中的线程块是并行的，而 <code>ComputeShader.Dispatch</code> 中的X,Y,Z参数，分别表示了我们在这3个维度上分别要调用多少次这样的线程块</p>
<p>现在返回我们刚才生成的图片</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_2_Pic1.png?raw=true"></p>
<p>这里只有从左下角开始的四分之一，也就是 <code>(texResolution / 16, texResolution / 16)</code>，和 <code>[numthreads(8,8,1)]</code>，我们在代码中给出的图片尺寸为256x256，线程块单边的绘制长度为8x16，也就是生成图片的面积占总面积的四分之一了。而我们在Update中的方法参数是 <code>(texResolution / 8, texResolution / 8)</code>，线程块单边的绘制长度为8x32，正好绘制满整个图片</p>
<p>在本章中，我们着重讲解了 <code>numthreads</code> 和 <code>SV_DispatchThreadID</code> 的相关概念，这部分概念非常重要，在后续的计算中会频繁用到<br>在下一章中，我们会创建多个kernel，分别使用它们在图片上画出不同的视觉效果</p>
<hr>
<h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><blockquote>
<p><a href="https://cn.mathigon.org/course/fractals/sierpinski">谢尔宾斯基三角形 扩展阅读</a></p>
</blockquote>
<blockquote>
<p><a href="https://learn.microsoft.com/en-us/windows/win32/direct3dhlsl/sm5-attributes-numthreads">numthreads</a></p>
</blockquote>
<blockquote>
<p><a href="https://developer.unity.cn/projects/6116875dedbc2a00204564c9">其他扩展阅读</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Unity 3D</category>
      </categories>
      <tags>
        <tag>Unity 3D</tag>
        <tag>Render</tag>
        <tag>Compute Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Compute Shader - 3 更多内核</title>
    <url>/2022/03/16/Unity3D/ComputeShader/Compute_Shader_3/</url>
    <content><![CDATA[<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>在上一章中，我们了解了每个线程块是按照什么顺序在图片上绘制的，但是我们只使用了一个内核来绘制，在这一章中，我们将使用多个内核来同时在一张图片上绘制图案</p>
<ul>
<li>首先，我们打开 <code>FirstComputeShader</code> 脚本，修改之前的内核名称，添加一个int类型的变量用于获取传入图片的分辨率，同时要将方法名称改为和内核名称相同，如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma kernel SolidRed</span><br><span class="line"></span><br><span class="line">RWTexture2D&lt;float4&gt; Result;</span><br><span class="line">int texResolution;</span><br><span class="line"></span><br><span class="line">[numthreads(8, 8, 1)]</span><br><span class="line">void SolidRed (uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    Result[id.xy] &#x3D; float4(1, 0, 0, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到 <code>AssignTexture</code> 脚本中，添加一个string类型变量用来记录我们要使用Compute Shader中的哪个内核名称，接着修改与 <code>CSMain</code> 相关的代码，最后使用 <code>SetInt</code> 方法将图片分辨率传给Compute Shader，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class AssignTexture : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public string kernelName&#x3D; &quot;SolidRed&quot;;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        DispatchShader(texResolution &#x2F; 8, texResolution &#x2F; 8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void InitShader()</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;获取指定名称内核的索引值</span><br><span class="line">        KernelHandle &#x3D; shader.FindKernel(kernelName);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将图片的分辨率数据传给Compute Shader</span><br><span class="line">        shader.SetInt(&quot;texResolution&quot;, texResolution);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次运行，我们就会看到，Quad上显示为一张红色的图片</p>
<p>回到 <code>FirstComputeShader</code> 脚本，添加一个新的内核为 <code>Solidyellow</code>，并创建与之对应的方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma kernel Solidyellow</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[numthreads(8, 8, 1)]</span><br><span class="line">void Solidyellow(uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    Result[id.xy] &#x3D; float4(1, 1, 0, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码添加完成后，回到unity中，将inspector面板中的 <code>kernelName</code> 变量值改为 <code>Solidyellow</code>，再次运行，Quad就显示为一张纯黄色的图片了</p>
<h4 id="四等分不同颜色的正方形"><a href="#四等分不同颜色的正方形" class="headerlink" title="四等分不同颜色的正方形"></a>四等分不同颜色的正方形</h4><p>在 <code>FirstComputeShader</code> 脚本中添加一个内核，名称为 <code>SplitScreen</code> 这个方法是用来将整个图片等分为4个部分，并为每个部分填上不同的颜色，效果如下：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_3_Pic1.png?raw=true"></p>
<p>按照上图思路，首先我们需要计算出当前传入图片分辨率的一半，然后使用Compute Shader中的 <code>step</code> 函数确定4个区域的颜色<br><code>step</code> 函数入参为两个浮点型参数，并返回一个布尔值的浮点表示，工作原理如下：</p>
<ul>
<li>step(edge, x)</li>
<li>如果x大于或等于edge，则返回1.0。</li>
<li>如果x小于edge，则返回0.0。</li>
</ul>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma kernel SplitScreen</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[numthreads(8, 8, 1)]</span><br><span class="line">void SplitScreen(uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;首先计算出当前传入图片分辨率的一半</span><br><span class="line">    &#x2F;&#x2F;图片是正方形，所以只需要计算一个边长即可</span><br><span class="line">    &#x2F;&#x2F;这里使用位运算，首先是因为边长一定是正整数，而且位运算比除法更快，性能更好</span><br><span class="line">    int halfRes &#x3D; texResolution &gt;&gt; 1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;-step(edge, x)</span><br><span class="line">    &#x2F;&#x2F;如果x大于或等于edge，则返回1.0</span><br><span class="line">    &#x2F;&#x2F;如果x小于edge，则返回0.0</span><br><span class="line">    &#x2F;&#x2F;这样就将一张图切割为了4个部分，并未每个部分添加了不同的颜色</span><br><span class="line">    Result[id.xy] &#x3D; float4(step(halfRes, id.x), step(halfRes, id.y), 0, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是上一章中介绍的DispatchThreadID中X与Y分别作为step中的第二个参数。例如当DispatchThreadID为(166,50,0)时，step(halfRes, id.x)就是step(128, 166)，此时step运算结果为1.0</p>
<p>回到unity中，将inspector面板中的 <code>kernelName</code> 变量值改为 <code>SplitScreen</code>，运行后就可以看到之前示例图的效果了</p>
<h4 id="在图片中间绘制一个黄色的圆形"><a href="#在图片中间绘制一个黄色的圆形" class="headerlink" title="在图片中间绘制一个黄色的圆形"></a>在图片中间绘制一个黄色的圆形</h4><p>接下来，我们尝试在图片中央画一个黄色的圆形，效果如下：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_3_Pic2.png?raw=true"></p>
<p>根据刚才绘制正方形的经验，我们可以创建一个内核函数，其中如果id.xy在圆上，就返回1，如果不在圆上，就返回0<br>这里我们要用到HLSL的另一个函数 <code>length</code>，用来判断两个点之间的距离。例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float2 v &#x3D; float2(4, 3);</span><br><span class="line">length(v) &#x3D; 5;</span><br></pre></td></tr></table></figure>

<p>有了判断距离的方法，我们还需要思考一个问题，在当前图上绘制时，坐标原点是左下角，即左下角位置为(0, 0)。如下图所示</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_3_Pic3.png?raw=true"></p>
<p>而我们需要绘制的圆形则在图片的中心，也就是我们想将坐标的原点移到图片中心，这样移动的话，图片左下角坐标就变成了(-128，-128)，而图片右上角坐标就变成了(127,127)，如下图所示</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_3_Pic4.png?raw=true"></p>
<p>按照这个思路，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma kernel Circle</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">float inCircle(float2 pt, float radius)</span><br><span class="line">&#123;</span><br><span class="line">    if (length(pt) &lt; radius)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1.0;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return 0.0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[numthreads(8, 8, 1)]</span><br><span class="line">void Circle(uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    int halfRes &#x3D; texResolution &gt;&gt; 1;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;这里的&quot;-halfRes&quot;其实是在移动坐标原点</span><br><span class="line">    &#x2F;&#x2F;也就是x和y分别横向、纵向负方向移动了halfRes距离</span><br><span class="line">    &#x2F;&#x2F;也就是将坐标(0, 0)从左下角移动到了图片中间</span><br><span class="line">    &#x2F;&#x2F;现在图片左下角起始坐标为(-128,-128)了</span><br><span class="line">    float2 _pt &#x3D; (float2) ((int2) id.xy - halfRes);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;这里代入inCircle方法，判断图片中心点到(x,y)的距离是否大于半径</span><br><span class="line">    &#x2F;&#x2F;小于等于半径的话，就为1，否则就为0</span><br><span class="line">    float _res &#x3D; inCircle(_pt, 100.0);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;将结果转换为颜色值输出</span><br><span class="line">    Result[id.xy] &#x3D; float4(_res, _res, 0, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>inCircle</code> 方法就是在判断每组坐标(x,y)是否在圆上，如下图所示，(x1, y1)不在圆上，<code>inCircle</code> 方法返回0，(x2, y2)在圆上，<code>inCircle</code> 方法返回1：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_3_Pic5.png?raw=true"></p>
<p>回到unity中，将inspector面板中的 <code>kernelName</code> 变量值改为 <code>Circle</code>，运行后就可以看到之前示例图的效果了</p>
<h4 id="绘制蓝色正方形"><a href="#绘制蓝色正方形" class="headerlink" title="绘制蓝色正方形"></a>绘制蓝色正方形</h4><p>接下来，我们要在图片上绘制一个蓝色正方形，如下图所示：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_3_Pic6.png?raw=true"></p>
<p>通过观察最终效果图，绘制蓝色正方形与绘制黄色圆形的原理其实相似，都是通过判断一个点是否在当前图形范围内，只不过蓝色正方形是要判断当前一个点跟正方形上下左右四条边的关系，这里还是会用到 <code>step</code> 函数。同时使用一个 <code>float4</code> 类型的变量，用来记录正方形左下角起始点位置和长宽，<code>float4</code> 和C#中的 <code>Rect</code>有些类似，都是存储4个float类型的值，如下图所示：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_3_Pic7.png?raw=true"></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma kernel Square</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">float inSquare(float2 pt, float4 _rect)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;当前点跟矩形 左面 的边的关系</span><br><span class="line">    &#x2F;&#x2F;点在边左侧为0，右侧为1</span><br><span class="line">    float horz_L &#x3D; step(_rect.x, pt.x);</span><br><span class="line">    &#x2F;&#x2F;当前点跟矩形 右面 的边的关系</span><br><span class="line">    float horz_R &#x3D; step(_rect.x + _rect.z, pt.x);</span><br><span class="line">    &#x2F;&#x2F;其实这里只会出现3中情况，即</span><br><span class="line">    &#x2F;&#x2F;点在矩形左侧 0 - 0，点在矩形上 1 - 0，点在矩形右侧 1 - 1</span><br><span class="line">    float horz &#x3D; horz_L - horz_R;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;当前点与矩形 下面 的边的关系</span><br><span class="line">    float vert_B &#x3D; step(_rect.y, pt.y);</span><br><span class="line">    &#x2F;&#x2F;当前点与矩形 上面 的边的关系</span><br><span class="line">    float vert_T &#x3D; step(_rect.y + _rect.w, pt.y);</span><br><span class="line">    &#x2F;&#x2F;根据上面两个判断获取当前点在垂直方向与矩形的关系</span><br><span class="line">    float vert &#x3D; vert_B - vert_T;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;只有当前点在矩形上，即horz&#x3D;1和vert&#x3D;1，相乘才为1，其他时候都是0</span><br><span class="line">    return horz * vert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[numthreads(8, 8, 1)]</span><br><span class="line">void Square(uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    float4 _rect &#x3D; float4(10.0f, 20.0f, 30.0f, 40.0f);</span><br><span class="line"></span><br><span class="line">    float _res &#x3D; inSquare((float2) id.xy, _rect);</span><br><span class="line"></span><br><span class="line">    Result[id.xy] &#x3D; float4(0, 0, _res, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就在当前你图片上绘制了一个自定义位置和边长的矩形了，效果如下：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_3_Pic8.png?raw=true"></p>
<p>现在，我们通过在图片上绘制一个四等分颜色不同的正方形和图片中间黄色的圆形，引入了 <code>step</code> 和 <code>length</code> 两个函数的使用方法</p>
<hr>
<h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><blockquote>
<p><a href="https://docs.unity.cn/ScriptReference/ComputeShader.SetInt.html">ComputeShader.SetInt</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Unity 3D</category>
      </categories>
      <tags>
        <tag>Unity 3D</tag>
        <tag>Render</tag>
        <tag>Compute Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Compute Shader - 4 传输数据到Compute Shader</title>
    <url>/2022/03/18/Unity3D/ComputeShader/Compute_Shader_4/</url>
    <content><![CDATA[<p>在前几章中，我们在C#端使用 <code>SetTexture</code> 和 <code>SetInt</code> 方法向目标Compute Shader传输了数据，在这几章中，我们将继续熟悉向Compute Shader传值的一些方法，并绘制一些更加复杂的图形</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>在本章中，我们将先绘制一个简单的环形，并且整张图片的背景色和环形的颜色，都是可以自定义的，效果图下图：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_4_Pic1.png?raw=true"></p>
<p>按照这个思路，先创建一个新的C#脚本，命名为 <code>DrawCircle</code>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class DrawCircle : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;要操作的 Compute Shader</span><br><span class="line">    public ComputeShader shader;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;使用图片的分辨率</span><br><span class="line">    public int texResolution;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;背景色</span><br><span class="line">    public Color clearColor;</span><br><span class="line">    &#x2F;&#x2F;圆环的颜色</span><br><span class="line">    public Color circleColor;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;Quad的MeshRenderer组件</span><br><span class="line">    private MeshRenderer meshRend;</span><br><span class="line">    &#x2F;&#x2F;Compute Shader输出的图片</span><br><span class="line">    private RenderTexture outputTexture;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;背景色内核索引</span><br><span class="line">    private int circleHandle;</span><br><span class="line">    &#x2F;&#x2F;圆环内核索引</span><br><span class="line">    private int clearHandle;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        meshRend &#x3D; gameObject.GetComponent&lt;MeshRenderer&gt;();</span><br><span class="line"></span><br><span class="line">        outputTexture &#x3D; new RenderTexture(texResolution, texResolution, 0);</span><br><span class="line">        outputTexture.enableRandomWrite &#x3D; true;</span><br><span class="line">        outputTexture.Create();</span><br><span class="line"></span><br><span class="line">        InitShader();</span><br><span class="line"></span><br><span class="line">        DispatchKernels();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void InitShader()</span><br><span class="line">    &#123;</span><br><span class="line">        circleHandle &#x3D; shader.FindKernel(&quot;Circles&quot;);</span><br><span class="line">        clearHandle &#x3D; shader.FindKernel(&quot;Clear&quot;);</span><br><span class="line"></span><br><span class="line">        shader.SetInt(&quot;texResolution&quot;, texResolution);</span><br><span class="line">        shader.SetVector(&quot;clearColor&quot;, clearColor);</span><br><span class="line">        shader.SetVector(&quot;circleColor&quot;, circleColor);</span><br><span class="line"></span><br><span class="line">        shader.SetTexture(circleHandle, &quot;Result&quot;, outputTexture);</span><br><span class="line">        shader.SetTexture(clearHandle, &quot;Result&quot;, outputTexture);</span><br><span class="line"></span><br><span class="line">        meshRend.material.SetTexture(&quot;_MainTex&quot;, outputTexture);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void DispatchKernels()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;先绘制背景色，再绘制圆环，顺序反了的话，圆环就会被覆盖掉了</span><br><span class="line">        shader.Dispatch(clearHandle, texResolution &#x2F; 8, texResolution &#x2F; 8, 1);</span><br><span class="line">        shader.Dispatch(circleHandle, 1, 1, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里C#代码部分，基本和之前的代码原理相同，传输颜色数据，用到了 <code>SetVector</code> 方法。<br>还有一点比较重要，就是在 <code>DispatchKernels</code> 中绘制背景色和绘制圆环的内核调用顺序，如果最后调用背景色绘制内核，就会覆盖掉之前的图案。</p>
<h4 id="使用Compute-Shader绘制环形"><a href="#使用Compute-Shader绘制环形" class="headerlink" title="使用Compute Shader绘制环形"></a>使用Compute Shader绘制环形</h4><p>接下来创建一个Compute Shader脚本，命名为 <code>DrawCircleShader</code>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma kernel Circles</span><br><span class="line">#pragma kernel Clear</span><br><span class="line"></span><br><span class="line">shared RWTexture2D&lt;float4&gt; Result;</span><br><span class="line"></span><br><span class="line">int texResolution;</span><br><span class="line"></span><br><span class="line">float4 clearColor;</span><br><span class="line">float4 circleColor;</span><br><span class="line"></span><br><span class="line">void plot1(int x, int y, int2 centre)</span><br><span class="line">&#123;</span><br><span class="line">    Result[uint2(centre.x + x, centre.y + y)] &#x3D; circleColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void plot8(int x, int y, int2 centre)</span><br><span class="line">&#123;</span><br><span class="line">    plot1(x, y, centre);</span><br><span class="line">    plot1(y, x, centre);</span><br><span class="line">    plot1(x, -y, centre);</span><br><span class="line">    plot1(y, -x, centre);</span><br><span class="line">    plot1(-x, -y, centre);</span><br><span class="line">    plot1(-y, -x, centre);</span><br><span class="line">    plot1(-x, y, centre);</span><br><span class="line">    plot1(-y, x, centre);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void drawCircle(int2 centre, int radius)</span><br><span class="line">&#123;</span><br><span class="line">    int x &#x3D; 0;</span><br><span class="line">    int y &#x3D; radius;</span><br><span class="line">    int d &#x3D; 1 - radius;</span><br><span class="line"></span><br><span class="line">    while (x &lt; y)</span><br><span class="line">    &#123;</span><br><span class="line">        if (d &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            d +&#x3D; 2 * x + 3;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            d +&#x3D; 2 * (x - y) + 5;</span><br><span class="line">            y--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        plot8(x, y, centre);</span><br><span class="line"></span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[numthreads(8, 8, 1)]</span><br><span class="line">void Clear(uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    Result[id.xy] &#x3D; clearColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[numthreads(1, 1, 1)]</span><br><span class="line">void Circles(uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    int2 center &#x3D; (texResolution &gt;&gt; 1);</span><br><span class="line">    int radius &#x3D; 180;</span><br><span class="line"></span><br><span class="line">    drawCircle(center, radius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 <code>drawCircle</code>方法可能看起来很奇怪，其实这是中点圆算法(Midpoint circle algorithm)，就是将一个环形分为了8个部分，通过x,y的正负和镜像取值，来绘制一个环形，如下图所示：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_4_Pic2.gif?raw=true"></p>
<p>这里要注意，我们绘制背景色的方法，使用的线程组是 <code>[numthreads(8, 8, 1)]</code>，而在绘制环形时使用的是 <code>[numthreads(1, 1, 1)]</code>。这就意味着整个 <code>Circles</code> 值运行了一次，就完成了整个环形的绘制。如果从传统定点/片元着色器来看，可能会觉得很奇怪，但Compute Shader其实完全控制着对RWTexture2D的写入。我们使用单一调用就可以绘制出整个环形，而不是单个像素。</p>
<h4 id="绘制多个随机环形"><a href="#绘制多个随机环形" class="headerlink" title="绘制多个随机环形"></a>绘制多个随机环形</h4><p>现在我们在DrawCircleShader脚本中刚添加一些生成随机数的方法，让 <code>Circles</code> 方法可以在图片上随机绘制半径随机的多个环形，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float time;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用于随机生成半径</span><br><span class="line">float random(float value, float seed &#x3D; 0.546)</span><br><span class="line">&#123;</span><br><span class="line">    float random &#x3D; (frac(sin(value + seed) * 143758.5453)); &#x2F;&#x2F; + 1.0)&#x2F;2.0;</span><br><span class="line">    return random;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;用于随机生成圆心</span><br><span class="line">float2 random2(float value)</span><br><span class="line">&#123;</span><br><span class="line">    return float2(</span><br><span class="line">        random(value, 3.9812),</span><br><span class="line">        random(value, 7.1536)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[numthreads(32, 1, 1)]</span><br><span class="line">void Circles(uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    int2 center &#x3D; (int2) (random2((float) id.x + time) * (float) texResolution);</span><br><span class="line">    int radius &#x3D; (int) (random((float) id.x) * 30);</span><br><span class="line"></span><br><span class="line">    drawCircle(center, radius);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里随机生成算法并不是很重要，只需要知道这里调用 <code>random2</code> 和 <code>random</code> 方法，分别生成了一个环形的圆形和半径即可。重点在 <code>Circles</code> 上方的线程组声明上 <code>[numthreads(32, 1, 1)]</code>，根据绘制一个环形时的房线程组声明我们可以知道，线程组内只有一个线程绘制一次，就会绘制出一个环形，现在我们使用32个线程同时绘制，也就是要在当前你图片上绘制32个大小位置随机的环形<br>同时，我们将 <code>DrawCircle</code>脚本中的调用方法修改一下，让其多次调用绘制环形的方法，让整个图片基本被环形填充，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void DispatchKernels()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    shader.Dispatch(circleHandle, 10, 1, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就得到了一张绘制了320个随机大小位置环形，并且可自定义颜色的图片，效果如下：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_4_Pic3.png?raw=true"></p>
<p>在下一章中，我们将让这些环形想气泡一样都运动起来</p>
<h4 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h4><blockquote>
<p><a href="http://www.sunshine2k.de/coding/java/Bresenham/RasterisingLinesCircles.pdf">RasterisingLinesCircles</a></p>
</blockquote>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Midpoint_circle_algorithm">Midpoint circle algorithm - wiki</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Unity 3D</category>
      </categories>
      <tags>
        <tag>Unity 3D</tag>
        <tag>Render</tag>
        <tag>Compute Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Compute Shader - 5 Compute Shader buffer</title>
    <url>/2022/03/19/Unity3D/ComputeShader/Compute_Shader_5/</url>
    <content><![CDATA[<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>在上一章中，我们使用随机数在图片上生成了很多随机大小和位置的圆环，现在我们使用简单的代码让他们动起来</p>
<p>之前我们在 <code>DrawCircleShader</code>脚本中声明了 <code>float time;</code>，这里我们使用C#传入值，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">    DispatchKernels();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void DispatchKernels()</span><br><span class="line">&#123;</span><br><span class="line">    shader.SetFloat(&quot;time&quot;, Time.time);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就得到了一个每一帧都会随机生成很多圆环的图片，效果如下：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_5_Pic1.gif?raw=true"></p>
<p>虽然图片中的圆环每帧都会变化，但依然是杂乱无章的，而且速度非常快，并不太符合我们的预期，我们希望的是生成类似气泡感觉的图片</p>
<h4 id="构建Buffer数据"><a href="#构建Buffer数据" class="headerlink" title="构建Buffer数据"></a>构建Buffer数据</h4><p>为了可以生成气泡运动感觉的图片，我们这里就要用到Compute Shader Buffer，它可以让我们将任意的数据传递给Compute Shader中，并让其进行计算。我们先在 <code>DrawCircle</code>脚本中初始化所有环形的数据，例如圆心位置、运动方向和位置、半径，然后将这些数据在初始化时传输给 <code>DrawCircleShader</code>脚本，让其计算后绘制到图片上，这样就不会有环形杂乱无章随机的问题了，<code>DrawCircle</code>脚本代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class DrawCircle : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;绘制环形中 X的调用次数</span><br><span class="line">    int count &#x3D; 10;</span><br><span class="line">    &#x2F;&#x2F;存储所有环形数据</span><br><span class="line">    private Circle[] circleData;</span><br><span class="line">    &#x2F;&#x2F;存储向ComputeShader传输的数据</span><br><span class="line">    private ComputeBuffer buffer;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        InitData();</span><br><span class="line"></span><br><span class="line">        InitShader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化要传输给Compute Shader的数据</span><br><span class="line">    private void InitData()</span><br><span class="line">    &#123;</span><br><span class="line">        circleHandle &#x3D; shader.FindKernel(&quot;Circles&quot;);</span><br><span class="line">        clearHandle &#x3D; shader.FindKernel(&quot;Clear&quot;);</span><br><span class="line"></span><br><span class="line">        uint threadGroupSizeX;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;这里要获取circleHandle内核方法中，线程组内的线程数量</span><br><span class="line">        &#x2F;&#x2F;这里我们只关心X的值，也就是 [numthreads(32, 1, 1)] 中，32的值，其他的就或略了</span><br><span class="line">        shader.GetKernelThreadGroupSizes(circleHandle, out threadGroupSizeX, out _, out _);</span><br><span class="line">        &#x2F;&#x2F;根据线程数算出一共需要多少个环形，也就是数组的长度</span><br><span class="line">        int total &#x3D; (int)threadGroupSizeX * count;</span><br><span class="line"></span><br><span class="line">        circleData &#x3D; new Circle[total];</span><br><span class="line"></span><br><span class="line">        float _speed &#x3D; 100.0f;</span><br><span class="line">        float _halfSpeed &#x3D; _speed * 0.5f;</span><br><span class="line">        float _minRadius &#x3D; 10.0f;</span><br><span class="line">        float _maxRadius &#x3D; 30.0f;</span><br><span class="line">        float _radiusRange &#x3D; _maxRadius - _minRadius;</span><br><span class="line"></span><br><span class="line">        for (int i &#x3D; 0; i &lt; total; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            circleData[i].origin.x &#x3D; Random.value * texResolution;</span><br><span class="line">            circleData[i].origin.y &#x3D; Random.value * texResolution;</span><br><span class="line">            circleData[i].velocity.x &#x3D; (Random.value * _speed) - _halfSpeed;</span><br><span class="line">            circleData[i].velocity.y &#x3D; (Random.value * _speed) - _halfSpeed;</span><br><span class="line">            circleData[i].radius &#x3D; Random.value * _radiusRange + _minRadius;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void InitShader()</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;创建Compute Shader缓冲区大小</span><br><span class="line">        &#x2F;&#x2F;其中(2 + 2 + 1)与DrawCircleShader中的struct circle对应</span><br><span class="line">        &#x2F;&#x2F;两个float2和一个float，再乘以sizeof(float)，就计算出了缓冲区中一个元素的大小</span><br><span class="line">        int _stride &#x3D; (2 + 2 + 1) * sizeof(float);</span><br><span class="line">        buffer &#x3D; new ComputeBuffer(circleData.Length, _stride);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将创建好的ComputeBuffer数据传输给ComputeShader</span><br><span class="line">        buffer.SetData(circleData);</span><br><span class="line">        shader.SetBuffer(circleHandle, &quot;circleBuffer&quot;, buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void DispatchKernels()</span><br><span class="line">    &#123;</span><br><span class="line">        shader.Dispatch(circleHandle, count, 1, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;向Compute Shader传输数据的结构体</span><br><span class="line">public struct Circle</span><br><span class="line">&#123;</span><br><span class="line">    public Vector2 origin;&#x2F;&#x2F;圆心位置</span><br><span class="line">    public Vector2 velocity;&#x2F;&#x2F;运行方向和速度</span><br><span class="line">    public float radius;&#x2F;&#x2F;半径</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们首先使用 <code>struct Circle</code> 结构体声明了一个数组，用来存储我们要传递的数据，这个数组的长度是线程组中X的值乘以调用次数，也就是 <code>[numthreads(32, 1, 1)]</code> 中的32与 <code>count</code> 的乘积<br>接下来我们创建了一些辅助变量将随机值控制在一定范围内，例如 <code>_speed) - _halfSpeed;</code> 中，如果没有 <code>- _halfSpeed</code>，那么所有环形的运动方向都只会是正方向。而 <code>Random.value * _radiusRange + _minRadius</code> 控制了圆环最小的尺寸<br>接下来我们在 <code>InitShader</code> 方法中构造了ComputeBuffer，其构造函数的第一个参数是缓冲区中元素的数量，也就是 <code>circleData</code> 的长度。第二个参数是每个元素的大小，这里我们使用了两个Vector2和一个float变量，其中Vector2中包含两个float，那么其大小就是5个float，也就是 <code>(2 + 2 + 1) * sizeof(float)</code><br>最后，我们通过 <code>SetData</code> 和 <code>SetBuffer</code> 方法将我们创建好的数据传输给Compute Shader</p>
<h4 id="接收Buffer数据并运算"><a href="#接收Buffer数据并运算" class="headerlink" title="接收Buffer数据并运算"></a>接收Buffer数据并运算</h4><p>在 <code>DrawCircle</code> 脚本中完成了数据的创建和传输，回到 <code>DrawCircleShader</code> 脚本中，我们需要接收Buffer数据并进行计算，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;接收buffer数据的结构</span><br><span class="line">struct circle</span><br><span class="line">&#123;</span><br><span class="line">    float2 origin;</span><br><span class="line">    float2 velocity;</span><br><span class="line">    float radius;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;接收buffer数据的变量</span><br><span class="line">StructuredBuffer&lt;circle&gt; circleBuffer;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[numthreads(32, 1, 1)]</span><br><span class="line">void Circles(uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    int2 center &#x3D; (int2) (circleBuffer[id.x].origin + circleBuffer[id.x].velocity * time);</span><br><span class="line">    int radius &#x3D; (int) circleBuffer[id.x].radius;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们创建了一个与 <code>DrawCircle</code> 脚本相同的数据结构 <code>struct circle</code>，并且声明了一个用于接收buffer的变量，这样当 <code>DrawCircle</code> 脚本中运行 <code>shader.SetBuffer(circleHandle, &quot;circleBuffer&quot;, buffer);</code> 语句时，数据就会保存到这个变量中了<br>接下来修改了计算环形圆心和半径的方法，之前是随机生成，现在是根据线程组中线程的ID，来确定每个环形的大小与位置<br>返回unity中运行，我们可以看到已经正常生成了环形，并且这些环形运行起来已经有一种气泡的感觉了，但是还有一个问题，当我们长时间运行的时候，会发现所有环形最后都到了图片的外面，图片中再也没有环形了，这里我们需要对所有环形的圆心做一些限制，代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[numthreads(32, 1, 1)]</span><br><span class="line">void Circles(uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    while (center.x &gt; texResolution)</span><br><span class="line">    &#123;</span><br><span class="line">        center.x -&#x3D; texResolution;</span><br><span class="line">    &#125;</span><br><span class="line">    while (center.x&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        center.x +&#x3D; texResolution;</span><br><span class="line">    &#125;</span><br><span class="line">    while (center.y &gt; texResolution)</span><br><span class="line">    &#123;</span><br><span class="line">        center.y -&#x3D; texResolution;</span><br><span class="line">    &#125;</span><br><span class="line">    while (center.y &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        center.y +&#x3D; texResolution;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过修改，每个环形如果到了图片以外，就会自动回到图片中，最终效果如下：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_5_Pic2.gif?raw=true"></p>
<p>至此，我们已经可以将自定义的数据从C#脚本中传输给Compute Shader进行计算并绘制，需要注意的是，创建和计算数据会比传输快很多，所以在构建数据的时候，尽量只保留最必须的。<br>在下一章中，我们将尝试获取Compute Shader计算完成后的数据，并在C#脚本中使用这些数据</p>
<h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><blockquote>
<p><a href="https://docs.unity.cn/cn/2021.3/ScriptReference/ComputeBuffer-ctor.html">ComputeBufferConstructor</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Unity 3D</category>
      </categories>
      <tags>
        <tag>Unity 3D</tag>
        <tag>Render</tag>
        <tag>Compute Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Compute Shader - 6 获取 Compute Shader Buffer 的数据</title>
    <url>/2022/03/22/Unity3D/ComputeShader/Compute_Shader_6/</url>
    <content><![CDATA[<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>在上一章中，我们学习了如何将自定义数据传递给Compute Shader Buffer并进行计算，在本章中，我们来学习如何获取Compute Shader Buffer中的数据在C#脚本中使用<br>首先创建一个C#脚本，名称为 <code>StarsTrans</code>，创建一个Compute Shader脚本，名称为 <code>OrbitingStars</code><br>这里，我们准备向Compute Shader传输多个Vecotr3的位置信息，经过Compute Shader计算，然后取回这些计算结果，每个Vecotr3对应一个场景中圆球的位置，让这些圆球像星球一样围绕着中心店转动，<code>StarsTrans</code> 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class StarsTrans : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;球的数量</span><br><span class="line">    public int starCount;</span><br><span class="line">    public ComputeShader shader;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;球的预制体</span><br><span class="line">    public GameObject prefab;</span><br><span class="line"></span><br><span class="line">    private ComputeBuffer resultBuffer;</span><br><span class="line">    private int kernelHandle;</span><br><span class="line">    private uint threadGroupSizeX;</span><br><span class="line">    private int groupSizeX;</span><br><span class="line">    private Vector3[] output;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;球的实例</span><br><span class="line">    private Transform[] stars;</span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        kernelHandle &#x3D; shader.FindKernel(&quot;OrbitingStars&quot;);</span><br><span class="line">        shader.GetKernelThreadGroupSizes(kernelHandle, out threadGroupSizeX, out _, out _);</span><br><span class="line">        &#x2F;&#x2F;根据圆球数量和线程组中的X线程数，计算出调用次数</span><br><span class="line">        groupSizeX &#x3D; (int)((starCount + threadGroupSizeX - 1) &#x2F; threadGroupSizeX);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;填充Buffer数据</span><br><span class="line">        resultBuffer &#x3D; new ComputeBuffer(starCount, sizeof(float) * 3);</span><br><span class="line">        shader.SetBuffer(kernelHandle, &quot;Result&quot;, resultBuffer);</span><br><span class="line">        output &#x3D; new Vector3[starCount];</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;根据圆球数量创建对应实例</span><br><span class="line">        stars &#x3D; new Transform[starCount];</span><br><span class="line">        for (int i &#x3D; 0; i &lt; starCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            stars[i] &#x3D; Instantiate(prefab, transform).transform;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Compute-Shader中可读写的buffer"><a href="#Compute-Shader中可读写的buffer" class="headerlink" title="Compute Shader中可读写的buffer"></a>Compute Shader中可读写的buffer</h4><p>C#脚本中的内容，与上一章的基本相同，都是创建buffer并填充。但在Compute Shader脚本中有些许不同<br>在上一章中我们只是将数据从C#脚本传输到了Compute Shader中，这里我们需要在Compute Shader中计算一些假随机值，然后在C#脚本中获取buffer中的结果<br>这里就要使用到 <code>RWStructuredBuffer</code>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma kernel OrbitingStars</span><br><span class="line"></span><br><span class="line">RWStructuredBuffer&lt;float3&gt; Result;</span><br><span class="line">float time;</span><br><span class="line"></span><br><span class="line">float random(float value, float seed &#x3D; 0.546)</span><br><span class="line">&#123;</span><br><span class="line">    float res &#x3D; frac(sin(value + seed) * 143758.5453);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float3 random3(float value)</span><br><span class="line">&#123;</span><br><span class="line">    return float3(random(value, 3.9812), random(value, 7.1536), random(value, 5.7241));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[numthreads(64, 1, 1)]</span><br><span class="line">void OrbitingStars(uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    float3 sinDir &#x3D; normalize(random3(id.x) - 0.5);</span><br><span class="line">    float3 vec &#x3D; normalize(random3(id.x + 7.1393) - 0.5);</span><br><span class="line">    float3 cosDir &#x3D; normalize(cross(sinDir, vec));</span><br><span class="line"></span><br><span class="line">    float scaledTime &#x3D; time * 0.5 + random(id.x) * 712.131234;</span><br><span class="line"></span><br><span class="line">    float3 pos &#x3D; sinDir * sin(scaledTime) + cosDir * cos(scaledTime);</span><br><span class="line"></span><br><span class="line">    Result[id.x] &#x3D; pos * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里要注意，我们使用了 <code>RWStructuredBuffer</code>，这是一个可读写的缓冲区，可以让C#脚本获取到这个缓冲区中的计算结果数据<br>在 <code>OrbitingStars</code>方法中，我们做了上一章中圆环相似的伪随机，实现了球形围绕中心点旋转的效果</p>
<h4 id="获取Buffer的计算结果"><a href="#获取Buffer的计算结果" class="headerlink" title="获取Buffer的计算结果"></a>获取Buffer的计算结果</h4><p>回到C#脚本，在Update方法中，我们先要将数据传输给Compute Shader，然后使用 <code>ComputeBuffer.GetData</code> 方法从Compute Shader中获取计算结果数据，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class StarsTrans : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        shader.SetFloat(&quot;time&quot;, Time.time);</span><br><span class="line">        &#x2F;&#x2F;将数据传输给Compute Shader进行计算</span><br><span class="line">        shader.Dispatch(kernelHandle, groupSizeX, 1, 1);</span><br><span class="line">        &#x2F;&#x2F;获取计算结果</span><br><span class="line">        resultBuffer.GetData(output);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;将计算结果依次赋值给每个球形</span><br><span class="line">        for (int i &#x3D; 0; i &lt; stars.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            stars[i].localPosition &#x3D; output[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void OnDestroy()</span><br><span class="line">    &#123;</span><br><span class="line">        resultBuffer.Dispose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处要注意 <code>OnDestroy</code>中要主动释放掉ComputeBuffer，不然会造成内存泄漏，Unity会有警告</p>
<p>至此我们就完成了若干个小球围绕着一个中心点运动的效果，如下图：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_6_Pic1.gif?raw=true"></p>
<p>在下一章中，我们尝试使用这一章与前一章所了解的Compute Shader Buffer内容，制作一个球形与立方体之间变换的效果</p>
<h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><blockquote>
<p><a href="https://learn.microsoft.com/zh-cn/windows/win32/direct3dhlsl/sm5-object-rwstructuredbuffer?redirectedfrom=MSDN">RWStructuredBuffer</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Unity 3D</category>
      </categories>
      <tags>
        <tag>Unity 3D</tag>
        <tag>Render</tag>
        <tag>Compute Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Compute Shader - 7 网格变形</title>
    <url>/2022/03/24/Unity3D/ComputeShader/Compute_Shader_7/</url>
    <content><![CDATA[<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>在上一章中，我们了解了如何获取Compute Shader Buffer的数据，在本章中，我们将结合前两张所了解的内容，将一个立方体变成球形的效果</p>
<p>首先，我们需要使用blender制作一个立方体的模型，效果如下图：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_7_Pic1.png?raw=true"></p>
<p>这个立方体与Unity中自带的立方体不同，在Blender中制作的立方体会分很多段，是为了将其变换为球形时能有更平滑的表面<br>将制作好的立方体模型导入unity中后，需要勾选Model标签页的 <code>Read/Write</code>选项</p>
<h4 id="获取Mesh数据并传输、接收"><a href="#获取Mesh数据并传输、接收" class="headerlink" title="获取Mesh数据并传输、接收"></a>获取Mesh数据并传输、接收</h4><p>接下来创建C#和Compute Shader脚本，名称均为 <code>MeshDeform</code>，C#脚本代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEditor.Performance.ProfileAnalyzer;</span><br><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class MeshDeform : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public ComputeShader shader;</span><br><span class="line">    public float radius;</span><br><span class="line"></span><br><span class="line">    private int kernelhandle;</span><br><span class="line">    private Mesh mesh;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;存储球形的每个顶点信息</span><br><span class="line">    private Vertex[] vertexArray;</span><br><span class="line">    &#x2F;&#x2F;存储立方体的每个顶点信息</span><br><span class="line">    private Vertex[] initialArray;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;接收GPU数据的buffer</span><br><span class="line">    private ComputeBuffer vertexBuffer;</span><br><span class="line">    &#x2F;&#x2F;初始化的数据传输给GPU的buffer</span><br><span class="line">    private ComputeBuffer initialBuffer;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void InitVertexArrays(Mesh _mesh)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void InitGPUBuffers()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void GetVertexFromGPU()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public struct Vertex</span><br><span class="line">&#123;</span><br><span class="line">    public Vector3 vPosition;</span><br><span class="line">    public Vector3 vNormal;</span><br><span class="line"></span><br><span class="line">    public Vertex(Vector3 _p, Vector3 _n)</span><br><span class="line">    &#123;</span><br><span class="line">        vPosition.x &#x3D; _p.x;</span><br><span class="line">        vPosition.y &#x3D; _p.y;</span><br><span class="line">        vPosition.z &#x3D; _p.z;</span><br><span class="line"></span><br><span class="line">        vNormal.x &#x3D; _n.x;</span><br><span class="line">        vNormal.y &#x3D; _n.y;</span><br><span class="line">        vNormal.z &#x3D; _n.z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，我们创建了两个ComputeBuffer，<code>initialBuffer</code> 用来存储立方体中初始状态下每个顶点的位置和法线信息，<code>vertexBuffer</code> 是用来获取Compute Shader计算后的结果<br>在 <code>Start</code> 方法中需要初始化自身和Compute Shader中各类的参数，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void Start()</span><br><span class="line">&#123;</span><br><span class="line">    MeshFilter _mf &#x3D; gameObject.GetComponent&lt;MeshFilter&gt;();</span><br><span class="line">    mesh &#x3D; _mf.mesh;</span><br><span class="line">    kernelhandle &#x3D; shader.FindKernel(&quot;CSMain&quot;);</span><br><span class="line">    shader.SetFloat(&quot;radius&quot;, radius);</span><br><span class="line">    shader.SetFloat(&quot;radius&quot;, radius);</span><br><span class="line"></span><br><span class="line">    InitVertexArrays(_mf.mesh);</span><br><span class="line">    InitGPUBuffers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化完成后，我们需要使用立方体mesh中的顶点数据来初始化 <code>vertexArray</code> 和 <code>initialArray</code> 数组，这两个数组在初始化时，里面的数据是完全相同的，代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void InitVertexArrays(Mesh _mesh)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;模型mesh的顶点数就是数组的长度</span><br><span class="line">    vertexArray &#x3D; new Vertex[_mesh.vertices.Length];</span><br><span class="line">    initialArray &#x3D; new Vertex[_mesh.vertices.Length];</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;对两个数组中的内容进行初始化</span><br><span class="line">    for (int i &#x3D; 0; i &lt; vertexArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Vertex v1 &#x3D; new Vertex(_mesh.vertices[i], _mesh.normals[i]);</span><br><span class="line">        vertexArray[i] &#x3D; v1;</span><br><span class="line">        Vertex v2 &#x3D; new Vertex(_mesh.vertices[i], _mesh.normals[i]);</span><br><span class="line">        initialArray[i] &#x3D; v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组初始化完成后，接下来初始化 <code>vertexBuffer</code> 和 <code>initialBuffer</code>，<br>这两个字段总长度和元素长度都相同，只是 <code>initialBuffer</code> 用来保存立方体状态下mesh的顶点信息数据，<code>vertexBuffer</code> 用来接收数据并对当前立方体mesh进行变换，代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void InitGPUBuffers()</span><br><span class="line">&#123;</span><br><span class="line">    vertexBuffer &#x3D; new ComputeBuffer(vertexArray.Length, sizeof(float) * 6);</span><br><span class="line">    vertexBuffer.SetData(vertexArray);</span><br><span class="line"></span><br><span class="line">    initialBuffer &#x3D; new ComputeBuffer(initialArray.Length, sizeof(float) * 6);</span><br><span class="line">    initialBuffer.SetData(initialArray);</span><br><span class="line"></span><br><span class="line">    shader.SetBuffer(kernelhandle, &quot;vertexBuffer&quot;, vertexBuffer);</span><br><span class="line">    shader.SetBuffer(kernelhandle, &quot;initialBuffer&quot;, initialBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ComputeBuffer初始化完成后，我们需要完成 <code>GetVertexFromGPU</code> 方法，作用是将GPU中的数据保存到 <code>vertexArray</code> 中，并按照顺序赋值给立方体mesh中的每个顶点，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void GetVertexFromGPU()</span><br><span class="line">&#123;</span><br><span class="line">    vertexBuffer.GetData(vertexArray);</span><br><span class="line">    Vector3[] _vertices &#x3D; new Vector3[vertexArray.Length];</span><br><span class="line">    Vector3[] _normals &#x3D; new Vector3[vertexArray.Length];</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; vertexArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _vertices[i] &#x3D; vertexArray[i].vPosition;</span><br><span class="line">        _normals[i] &#x3D; vertexArray[i].vNormal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mesh.vertices &#x3D; _vertices;</span><br><span class="line">    mesh.normals &#x3D; _normals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是在Update方法中，传入一个在0到1之间的浮点数，使Compute Shader可以进行周期性的变化，也就是在球形和立方体之间来回变换，代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void Update()</span><br><span class="line">&#123;</span><br><span class="line">    float _delta &#x3D; (Mathf.Sin(Time.time) + 1) &#x2F; 2;</span><br><span class="line">    shader.SetFloat(&quot;delta&quot;, _delta);</span><br><span class="line">    shader.Dispatch(kernelhandle, vertexArray.Length, 1, 1);</span><br><span class="line"></span><br><span class="line">    GetVertexFromGPU();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Compute-Shader中计算顶点"><a href="#Compute-Shader中计算顶点" class="headerlink" title="Compute Shader中计算顶点"></a>Compute Shader中计算顶点</h4><p>完成了C#部分，我们接下来完成Compute Shader部分，这部分相对简单很多，主要是如何计算立方体表面顶点到球面的运动过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma kernel CSMain</span><br><span class="line"></span><br><span class="line">struct Vertex</span><br><span class="line">&#123;</span><br><span class="line">    float3 position;</span><br><span class="line">    float3 normal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RWStructuredBuffer&lt;Vertex&gt; vertexBuffer;</span><br><span class="line">StructuredBuffer&lt;Vertex&gt; initialBuffer;</span><br><span class="line"></span><br><span class="line">float delta;</span><br><span class="line">float radius;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[numthreads(8, 8, 1)]</span><br><span class="line">void CSMain(uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    float3 initialPos &#x3D; initialBuffer[id.x].position;</span><br><span class="line">    float3 initialNormal &#x3D; initialBuffer[id.x].normal;</span><br><span class="line">        </span><br><span class="line">    float3 s &#x3D; float3(normalize(initialPos) * radius);</span><br><span class="line">    float3 pos &#x3D; lerp(initialPos, s, delta);</span><br><span class="line"></span><br><span class="line">    float3 snormal &#x3D; normalize(initialPos);</span><br><span class="line">    float3 norm &#x3D; lerp(initialNormal, snormal, delta);</span><br><span class="line"></span><br><span class="line">    vertexBuffer[id.x].position &#x3D; pos;</span><br><span class="line">    vertexBuffer[id.x].normal &#x3D; norm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Compute Shader中，我们先通过 <code>initialBuffer</code>获取到立方体上每个顶点的信息，然后对每个定点进行归一化，再乘以球形的半径，这样做是因为当前顶点从立方体表面到球形表面，实际上是沿着归一化向量的方向运动的，运动的目的地就是归一化向量乘以半径的位置<br>计算出了每个顶点的初始位置和目标位置，我们就可以用lerp方法求出当前顶点的位置，最后将所有变换后的顶点信息放入 <code>vertexBuffer</code>等待C#脚本来获取</p>
<p>最终我们就实现了一个立方体变为球体的功能了，如下图：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_7_Pic2.gif?raw=true"></p>
<p>在下一章中，我们将了解如何生成噪点图，以及一些经典噪点图的生成算法，并在Compute Shader中导入和使用它们</p>
]]></content>
      <categories>
        <category>Unity 3D</category>
      </categories>
      <tags>
        <tag>Unity 3D</tag>
        <tag>Render</tag>
        <tag>Compute Shader</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Compute Shader - 8 使用噪点图</title>
    <url>/2022/03/25/Unity3D/ComputeShader/Compute_Shader_8/</url>
    <content><![CDATA[<p>在之前的章节中，我们生成环形、生成随机运动的小球，都是用了一种伪随机的方式，即每次只要输入的种子数值相同，那么得到的结果就是相同的。在Compute Shader中，还有一种获取随机数的方法，就是使用噪点图<br>在日常生活中，我们看到的很多东西都可以称为噪点图，例如斑驳的金属表面、树木的表面等，这些噪点图提供了更加自然的随机值。本章中我们就尝试在Compute Shader里生成和使用噪点图</p>
<h4 id="生成噪点图"><a href="#生成噪点图" class="headerlink" title="生成噪点图"></a>生成噪点图</h4><p>创建Compute Shader名称为 <code>Noise</code>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma kernel CSMain</span><br><span class="line"></span><br><span class="line">RWTexture2D&lt;float4&gt; Result;</span><br><span class="line">int texResolution;</span><br><span class="line">float time;</span><br><span class="line"></span><br><span class="line">float random(float2 pt, float seed)</span><br><span class="line">&#123;</span><br><span class="line">    const float a &#x3D; 12.9898;</span><br><span class="line">    const float b &#x3D; 78.233;</span><br><span class="line">    const float c &#x3D; 43758.543123;</span><br><span class="line">    return frac(sin(dot(pt, float2(a, b)) + seed) * c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[numthreads(8, 8, 1)]</span><br><span class="line">void CSMain(uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    float4 white &#x3D; 1;</span><br><span class="line">    Result[id.xy] &#x3D; random(((float2) id.xy) &#x2F; (float) texResolution, time) * white;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>创建C#脚本名称为 <code>Noise</code>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line">using System.Collections;</span><br><span class="line"></span><br><span class="line">public class SimpleNoise : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public ComputeShader shader;</span><br><span class="line">    public int texResolution &#x3D; 256;</span><br><span class="line"></span><br><span class="line">    private Renderer rend;</span><br><span class="line">    private RenderTexture outputTexture;</span><br><span class="line"></span><br><span class="line">    private int kernelHandle;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        outputTexture &#x3D; new RenderTexture(texResolution, texResolution, 0);</span><br><span class="line">        outputTexture.enableRandomWrite &#x3D; true;</span><br><span class="line">        outputTexture.Create();</span><br><span class="line"></span><br><span class="line">        rend &#x3D; GetComponent&lt;Renderer&gt;();</span><br><span class="line">        rend.enabled &#x3D; true;</span><br><span class="line"></span><br><span class="line">        InitShader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void InitShader()</span><br><span class="line">    &#123;</span><br><span class="line">        kernelHandle &#x3D; shader.FindKernel(&quot;CSMain&quot;);</span><br><span class="line"></span><br><span class="line">        shader.SetInt(&quot;texResolution&quot;, texResolution);</span><br><span class="line">        shader.SetTexture(kernelHandle, &quot;Result&quot;, outputTexture);</span><br><span class="line"></span><br><span class="line">        rend.material.SetTexture(&quot;_MainTex&quot;, outputTexture);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void DispatchShader(int x, int y)</span><br><span class="line">    &#123;</span><br><span class="line">        shader.SetFloat(&quot;time&quot;, Time.time);</span><br><span class="line">        shader.Dispatch(kernelHandle, x, y, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        DispatchShader(texResolution &#x2F; 8, texResolution &#x2F; 8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将C#代码挂载到Quad上，添加Compute Shader引用，运行后会有一种老式电视机无信号时的效果，如下：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_8_Pic1.gif?raw=true"></p>
<p>我们还可以改变Compute Shader方法 <code>random</code> 中a、b、c的值，使画面有相应的改变，比如 <code>a = 3; b = 3; c = 10</code> 时，生成的图像会变为如下效果：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_8_Pic2.gif?raw=true"></p>
<p>我们也注意到了，这样虽然生成了很多随机噪点，但是这些噪点之间会有很明显的边界，并不是平滑过渡的，所以像这样的噪点图在实际中没没有太大的使用价值</p>
<p>在上世纪80年代，Camplin被委托为科幻电影<a href="https://movie.douban.com/subject/1293482/">Tron</a>制作更好的模型和特效贴图纹理，他的解决方案就是创造一个平滑变化的量，其返回值具有随机性，而且随着X和Y分量的变化，这个值是平滑变化的</p>
<p>相似的平滑噪点图的生成算法，在制作Shader时时非常有用的，代码库在最下方的参考链接中已经给出，这里，我们可以将 <code>noiseSimplex.cginc</code> 文件拖入unity工程中，在Compute Shader里直接使用</p>
<h4 id="制作木质纹理"><a href="#制作木质纹理" class="headerlink" title="制作木质纹理"></a>制作木质纹理</h4><p>接下来，我们就尝试使用这个库来制作一个平滑变化的木纹理，创建C#和Compute Shader脚本，名称都为ProceduralWood，C#脚本代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class ProceduralWood : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public ComputeShader shader;</span><br><span class="line">    public int texResolution &#x3D; 256;</span><br><span class="line"></span><br><span class="line">    private Renderer rend;</span><br><span class="line">    private RenderTexture outputTexture;</span><br><span class="line"></span><br><span class="line">    private int kernelHandle;</span><br><span class="line"></span><br><span class="line">    public Color paleColor &#x3D; new Color(0.733f, 0.565f, 0.365f, 1);</span><br><span class="line">    public Color darkColor &#x3D; new Color(0.49f, 0.286f, 0.043f, 1);</span><br><span class="line">    public float frequency &#x3D; 2.0f;</span><br><span class="line">    public float noiseScale &#x3D; 6.0f;</span><br><span class="line">    public float ringScale &#x3D; 0.6f;</span><br><span class="line">    public float contrast &#x3D; 4.0f;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        outputTexture &#x3D; new RenderTexture(texResolution, texResolution, 0);</span><br><span class="line">        outputTexture.enableRandomWrite &#x3D; true;</span><br><span class="line">        outputTexture.Create();</span><br><span class="line"></span><br><span class="line">        rend &#x3D; GetComponent&lt;Renderer&gt;();</span><br><span class="line">        rend.enabled &#x3D; true;</span><br><span class="line"></span><br><span class="line">        kernelHandle &#x3D; shader.FindKernel(&quot;CSMain&quot;);</span><br><span class="line"></span><br><span class="line">        shader.SetInt(&quot;texResolution&quot;, texResolution);</span><br><span class="line"></span><br><span class="line">        DispatchData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void DispatchData()</span><br><span class="line">    &#123;</span><br><span class="line">        shader.SetVector(&quot;paleColor&quot;, paleColor);</span><br><span class="line">        shader.SetVector(&quot;darkColor&quot;, darkColor);</span><br><span class="line">        shader.SetFloat(&quot;frequency&quot;, frequency);</span><br><span class="line">        shader.SetFloat(&quot;noiseScale&quot;, noiseScale);</span><br><span class="line">        shader.SetFloat(&quot;ringScale&quot;, ringScale);</span><br><span class="line">        shader.SetFloat(&quot;contrast&quot;, contrast);</span><br><span class="line"></span><br><span class="line">        shader.SetTexture(kernelHandle, &quot;Result&quot;, outputTexture);</span><br><span class="line"></span><br><span class="line">        rend.material.SetTexture(&quot;_MainTex&quot;, outputTexture);</span><br><span class="line"></span><br><span class="line">        shader.Dispatch(kernelHandle, texResolution &#x2F; 8, texResolution &#x2F; 8, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        if (Input.GetKeyUp(KeyCode.A))</span><br><span class="line">        &#123;</span><br><span class="line">            DispatchData();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Compute Shader脚本代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma kernel CSMain</span><br><span class="line"></span><br><span class="line">RWTexture2D&lt;float4&gt; Result;</span><br><span class="line">int texResolution;</span><br><span class="line"></span><br><span class="line">float4 paleColor;</span><br><span class="line">float4 darkColor;</span><br><span class="line">float frequency;</span><br><span class="line">float noiseScale;</span><br><span class="line">float ringScale;</span><br><span class="line">float contrast;</span><br><span class="line"></span><br><span class="line">#include &quot;noiseSimplex.cginc&quot;</span><br><span class="line"></span><br><span class="line">[numthreads(8, 8, 1)]</span><br><span class="line">void CSMain(uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    float3 pos &#x3D; (((float3) id) &#x2F; (float) texResolution) * 2.0;</span><br><span class="line">    float n &#x3D; snoise(pos);</span><br><span class="line">    float ring &#x3D; frac(frequency * pos.z + noiseScale * n);</span><br><span class="line"></span><br><span class="line">    ring *&#x3D; contrast * (1.0 - ring);</span><br><span class="line"></span><br><span class="line">    float delta &#x3D; pow(abs(ring), ringScale) + n;</span><br><span class="line"></span><br><span class="line">    Result[id.xy] &#x3D; lerp(darkColor, paleColor, delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意，我们使用了 <code>#include &quot;noiseSimplex.cginc&quot;</code>语句来将之前导入到项目的 <code>noiseSimplex.cginc</code>脚本添加了引用，这样才可以使用 <code>snoise</code> 函数</p>
<p>此时我们挂载好C#脚本，添加Compute Shader引用，运行后就能看到生成了一个随机平滑变化的木质纹理，我们还可以在inspector面板调整其参数后，按下键盘A键，改变其纹理外观。效果如下：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_8_Pic3.png?raw=true"></p>
<h4 id="创建大理石纹理"><a href="#创建大理石纹理" class="headerlink" title="创建大理石纹理"></a>创建大理石纹理</h4><p>接下来，我们可以使用经典的Perlin Noise制作一个大理石纹理，创建C#和Compute Shader脚本，名称为 <code>ProceduralMarble</code>，C#脚本代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using UnityEngine;</span><br><span class="line"></span><br><span class="line">public class ProceduralMarble : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    public ComputeShader shader;</span><br><span class="line">    public int texResolution &#x3D; 256;</span><br><span class="line"></span><br><span class="line">    private Renderer rend;</span><br><span class="line">    private RenderTexture outputTexture;</span><br><span class="line"></span><br><span class="line">    private int kernelHandle;</span><br><span class="line">    private bool marble &#x3D; true;</span><br><span class="line"></span><br><span class="line">    private void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        outputTexture &#x3D; new RenderTexture(texResolution, texResolution, 0);</span><br><span class="line">        outputTexture.enableRandomWrite &#x3D; true;</span><br><span class="line">        outputTexture.Create();</span><br><span class="line"></span><br><span class="line">        rend &#x3D; GetComponent&lt;Renderer&gt;();</span><br><span class="line">        rend.enabled &#x3D; true;</span><br><span class="line"></span><br><span class="line">        InitShader();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void InitShader()</span><br><span class="line">    &#123;</span><br><span class="line">        kernelHandle &#x3D; shader.FindKernel(&quot;CSMain&quot;);</span><br><span class="line"></span><br><span class="line">        shader.SetInt(&quot;texResolution&quot;, texResolution);</span><br><span class="line">        shader.SetTexture(kernelHandle, &quot;Result&quot;, outputTexture);</span><br><span class="line"></span><br><span class="line">        rend.material.SetTexture(&quot;_MainTex&quot;, outputTexture);</span><br><span class="line"></span><br><span class="line">        shader.SetBool(&quot;marble&quot;, marble);</span><br><span class="line">        marble &#x3D; !marble;</span><br><span class="line"></span><br><span class="line">        shader.Dispatch(kernelHandle, texResolution &#x2F; 8, texResolution &#x2F; 8, 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        if (Input.GetKeyUp(KeyCode.A))</span><br><span class="line">        &#123;</span><br><span class="line">            shader.SetBool(&quot;marble&quot;, marble);</span><br><span class="line">            marble &#x3D; !marble;</span><br><span class="line">            shader.Dispatch(kernelHandle, texResolution &#x2F; 8, texResolution &#x2F; 8, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Compute Shader脚本代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#pragma kernel CSMain</span><br><span class="line"></span><br><span class="line">RWTexture2D&lt;float4&gt; Result;</span><br><span class="line">int texResolution;</span><br><span class="line">int marble;</span><br><span class="line"></span><br><span class="line">#include &quot;noiseSimplex.cginc&quot;</span><br><span class="line"></span><br><span class="line">[numthreads(8,8,1)]</span><br><span class="line">void CSMain (uint3 id : SV_DispatchThreadID)</span><br><span class="line">&#123;</span><br><span class="line">    float3 pos &#x3D; (((float3)id)&#x2F;(float)texResolution) * 2.0;</span><br><span class="line">    float scale &#x3D; 800.0;</span><br><span class="line">    float3 color;</span><br><span class="line">    float noise;</span><br><span class="line"></span><br><span class="line">    pos *&#x3D; scale;</span><br><span class="line"></span><br><span class="line">    if (marble)&#123;</span><br><span class="line">        float d &#x3D; perlin(pos.x, pos.y) * scale; </span><br><span class="line">        float u &#x3D; pos.x + d;</span><br><span class="line">        float v &#x3D; pos.y + d;</span><br><span class="line">        d &#x3D; perlin(u, v) * scale;</span><br><span class="line">        noise &#x3D; perlin(pos.x + d, pos.y + d);</span><br><span class="line">        color &#x3D; float3(0.6 * (float3(2,2,2) * noise - float3(noise * 0.1, noise * 0.2 - sin(u &#x2F; 30.0) * 0.1, noise * 0.3 + sin(v &#x2F; 40.0) * 0.2)));</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        noise &#x3D; perlin(pos.x, pos.y);</span><br><span class="line">        color &#x3D; float3(1,1,1) * noise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Result[id.xy] &#x3D; float4( color, 1.0 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Compute Shader中，我们使用了3次 <code>perlin</code> 函数来进行图像的采样，最后将颜色混合起来，得出了如下效果：</p>
<p><img src="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/Compute_Shader_8_Pic4.png?raw=true"></p>
<p>运行后，我们可以按下键盘A键，查看值进行一次采样时的 <code>perlin</code> 函数生成的效果</p>
<p>在本章中，我们了解了怎样使用外部的代码库和使用 <code>perlin</code> 函数多次采样生成不同种类的连续平滑变化的噪点图，在下一章中，我们结合前几章和本章的内容，做一个带遮罩的噪点纹理</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><blockquote>
<p><a href="https://github.com/stegu/webgl-noise/?tab=readme-ov-file">Noise for GLSL 1.20</a></p>
</blockquote>
<blockquote>
<p><a href="https://stegu.github.io/webgl-noise/webdemo/">webGL demo</a></p>
</blockquote>
<blockquote>
<p><a href="https://github.com/Arthur-Delacroix/CrossmeSolution/blob/main/BlogPics/ComputeShader/noiseSimplex.cginc">noiseSimplex.cginc</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Unity 3D</category>
      </categories>
      <tags>
        <tag>Unity 3D</tag>
        <tag>Render</tag>
        <tag>Compute Shader</tag>
      </tags>
  </entry>
</search>
